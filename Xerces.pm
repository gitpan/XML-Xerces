# This file was automatically generated by SWIG
package XML::Xerces;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package XML::Xercesc;
bootstrap XML::Xerces;
package XML::Xerces; 
$VERSION = q[1.7.0_0];
package XML::Xerces;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package XML::Xerces;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


############# Class : XML::Xerces::XMLDeleter ##############

package XML::Xerces::XMLDeleter;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLPlatformUtils ##############

package XML::Xerces::XMLPlatformUtils;
@ISA = qw( XML::Xerces );
%OWNER = ();
*Panic_NoTransService = *XML::Xercesc::XMLPlatformUtils_Panic_NoTransService;
*Panic_NoDefTranscoder = *XML::Xercesc::XMLPlatformUtils_Panic_NoDefTranscoder;
*Panic_CantFindLib = *XML::Xercesc::XMLPlatformUtils_Panic_CantFindLib;
*Panic_UnknownMsgDomain = *XML::Xercesc::XMLPlatformUtils_Panic_UnknownMsgDomain;
*Panic_CantLoadMsgDomain = *XML::Xercesc::XMLPlatformUtils_Panic_CantLoadMsgDomain;
*Panic_SynchronizationErr = *XML::Xercesc::XMLPlatformUtils_Panic_SynchronizationErr;
*Panic_SystemInit = *XML::Xercesc::XMLPlatformUtils_Panic_SystemInit;
*PanicReasons_Count = *XML::Xercesc::XMLPlatformUtils_PanicReasons_Count;
*Initialize = *XML::Xercesc::XMLPlatformUtils_Initialize;
*Terminate = *XML::Xercesc::XMLPlatformUtils_Terminate;
*panic = *XML::Xercesc::XMLPlatformUtils_panic;
*curFilePos = *XML::Xercesc::XMLPlatformUtils_curFilePos;
*closeFile = *XML::Xercesc::XMLPlatformUtils_closeFile;
*fileSize = *XML::Xercesc::XMLPlatformUtils_fileSize;
*openFile = *XML::Xercesc::XMLPlatformUtils_openFile;
*openStdInHandle = *XML::Xercesc::XMLPlatformUtils_openStdInHandle;
*readFileBuffer = *XML::Xercesc::XMLPlatformUtils_readFileBuffer;
*resetFile = *XML::Xercesc::XMLPlatformUtils_resetFile;
*getFullPath = *XML::Xercesc::XMLPlatformUtils_getFullPath;
*isRelative = *XML::Xercesc::XMLPlatformUtils_isRelative;
*weavePaths = *XML::Xercesc::XMLPlatformUtils_weavePaths;
*getCurrentMillis = *XML::Xercesc::XMLPlatformUtils_getCurrentMillis;
*closeMutex = *XML::Xercesc::XMLPlatformUtils_closeMutex;
*lockMutex = *XML::Xercesc::XMLPlatformUtils_lockMutex;
*makeMutex = *XML::Xercesc::XMLPlatformUtils_makeMutex;
*unlockMutex = *XML::Xercesc::XMLPlatformUtils_unlockMutex;
*loadMsgSet = *XML::Xercesc::XMLPlatformUtils_loadMsgSet;
*compareAndSwap = *XML::Xercesc::XMLPlatformUtils_compareAndSwap;
*atomicIncrement = *XML::Xercesc::XMLPlatformUtils_atomicIncrement;
*atomicDecrement = *XML::Xercesc::XMLPlatformUtils_atomicDecrement;
*recognizeNEL = *XML::Xercesc::XMLPlatformUtils_recognizeNEL;
*isNELRecognized = *XML::Xercesc::XMLPlatformUtils_isNELRecognized;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLURL ##############

package XML::Xerces::XMLURL;
use overload
    "==" => sub { $_[0]->operator_equal_to($_[1])},
    "!=" => sub { $_[0]->operator_not_equal_to($_[1])},
    "=" => sub { $_[0]->operator_assignment($_[1])},
    "fallback" => 1;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
*File = *XML::Xercesc::XMLURL_File;
*HTTP = *XML::Xercesc::XMLURL_HTTP;
*FTP = *XML::Xercesc::XMLURL_FTP;
*Protocols_Count = *XML::Xercesc::XMLURL_Protocols_Count;
*Unknown = *XML::Xercesc::XMLURL_Unknown;
*lookupByName = *XML::Xercesc::XMLURL_lookupByName;
sub new {
    my $pkg = shift;
    my @args = @_;
    if (ref($args[0])) {
      if (scalar @args == 1) {
        $self = XML::Xercesc::new_XMLURL__constructor__copy(@args);
      } else {
        $self = XML::Xercesc::new_XMLURL__constructor__url_base(@args);
      }
    } elsif (! scalar @args) {
      $self = XML::Xercesc::new_XMLURL();
    } elsif (scalar @args == 1) {
      $self = XML::Xercesc::new_XMLURL__constructor__text(@args);
    } else {
      $self = XML::Xercesc::new_XMLURL__constructor__base(@args);
    }

    return undef if (!defined($self));
    bless $self, "XML::Xerces::XMLURL";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::XMLURL", $self;
    return bless \%retval, $pkg;
}






sub operator_assignment {
    my @args = @_;
    my $result = XML::Xercesc::XMLURL_operator_assignment(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*operator_equal_to = *XML::Xercesc::XMLURL_operator_equal_to;
*operator_not_equal_to = *XML::Xercesc::XMLURL_operator_not_equal_to;
*getFragment = *XML::Xercesc::XMLURL_getFragment;
*getHost = *XML::Xercesc::XMLURL_getHost;
*getPassword = *XML::Xercesc::XMLURL_getPassword;
*getPath = *XML::Xercesc::XMLURL_getPath;
*getPortNum = *XML::Xercesc::XMLURL_getPortNum;
*getProtocol = *XML::Xercesc::XMLURL_getProtocol;
*getProtocolName = *XML::Xercesc::XMLURL_getProtocolName;
*getQuery = *XML::Xercesc::XMLURL_getQuery;
*getURLText = *XML::Xercesc::XMLURL_getURLText;
*getUser = *XML::Xercesc::XMLURL_getUser;
sub setURL {
    my @args = @_;
    if (scalar @args == 2) {
      XML::Xercesc::XMLURL_setURL(@args);
    } elsif (ref($args[1])) {
      XML::Xercesc::XMLURL_setURL__overload__XMLURL(@args);
    } else {
      XML::Xercesc::XMLURL_setURL__overload__string(@args);
    }
}
*isRelative = *XML::Xercesc::XMLURL_isRelative;
sub makeNewStream {
    my @args = @_;
    my $result = XML::Xercesc::XMLURL_makeNewStream(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub makeRelativeTo {
    my @args = @_;
    if (ref($args[1])) {
      XML::Xercesc::XMLURL_makeRelativeTo__overload__XMLURL(@args);
    } else {
      XML::Xercesc::XMLURL_makeRelativeTo(@args);
    }
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLUri ##############

package XML::Xerces::XMLUri;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

sub new {
    my $pkg = shift;
    my @args = @_;
    if (scalar @args == 1) {
      $self = XML::Xercesc::new_XMLUri__constructor__uri(@args);
    } else {
      $args[0] = tied(%{$args[0]});
      $self = XML::Xercesc::new_XMLUri(@args);
    }

    return undef if (!defined($self));
    bless $self, "XML::Xerces::XMLUri";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::XMLUri", $self;
    return bless \%retval, $pkg;
}


*getScheme = *XML::Xercesc::XMLUri_getScheme;
*getUserInfo = *XML::Xercesc::XMLUri_getUserInfo;
*getHost = *XML::Xercesc::XMLUri_getHost;
*getPort = *XML::Xercesc::XMLUri_getPort;
*getPath = *XML::Xercesc::XMLUri_getPath;
*getQueryString = *XML::Xercesc::XMLUri_getQueryString;
*getFragment = *XML::Xercesc::XMLUri_getFragment;
*setScheme = *XML::Xercesc::XMLUri_setScheme;
*setUserInfo = *XML::Xercesc::XMLUri_setUserInfo;
*setHost = *XML::Xercesc::XMLUri_setHost;
*setPort = *XML::Xercesc::XMLUri_setPort;
*setPath = *XML::Xercesc::XMLUri_setPath;
*setQueryString = *XML::Xercesc::XMLUri_setQueryString;
*setFragment = *XML::Xercesc::XMLUri_setFragment;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::QName ##############

package XML::Xerces::QName;
use overload
    "==" => sub { $_[0]->operator_equal_to($_[1])},
    "fallback" => 1;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_QName(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::QName";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::QName", $self;
    return bless \%retval, $pkg;
}


*getPrefix = *XML::Xercesc::QName_getPrefix;
*getLocalPart = *XML::Xercesc::QName_getLocalPart;
*getURI = *XML::Xercesc::QName_getURI;
*getRawName = *XML::Xercesc::QName_getRawName;
*setName = *XML::Xercesc::QName_setName;
*setPrefix = *XML::Xercesc::QName_setPrefix;
*setLocalPart = *XML::Xercesc::QName_setLocalPart;
*setNPrefix = *XML::Xercesc::QName_setNPrefix;
*setNLocalPart = *XML::Xercesc::QName_setNLocalPart;
*setURI = *XML::Xercesc::QName_setURI;
*setValues = *XML::Xercesc::QName_setValues;
*operator_equal_to = *XML::Xercesc::QName_operator_equal_to;
*cleanUp = *XML::Xercesc::QName_cleanUp;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::HexBin ##############

package XML::Xerces::HexBin;
@ISA = qw( XML::Xerces );
%OWNER = ();
*getDataLength = *XML::Xercesc::HexBin_getDataLength;
*isArrayByteHex = *XML::Xercesc::HexBin_isArrayByteHex;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::Base64 ##############

package XML::Xerces::Base64;
@ISA = qw( XML::Xerces );
%OWNER = ();
*encode = *XML::Xercesc::Base64_encode;
*decode = *XML::Xercesc::Base64_decode;
*getDataLength = *XML::Xercesc::Base64_getDataLength;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLExcepts ##############

package XML::Xerces::XMLExcepts;
@ISA = qw( XML::Xerces );
%OWNER = ();
*NoError = *XML::Xercesc::XMLExcepts_NoError;
*W_LowBounds = *XML::Xercesc::XMLExcepts_W_LowBounds;
*Scan_CouldNotOpenSource_Warning = *XML::Xercesc::XMLExcepts_Scan_CouldNotOpenSource_Warning;
*W_HighBounds = *XML::Xercesc::XMLExcepts_W_HighBounds;
*F_LowBounds = *XML::Xercesc::XMLExcepts_F_LowBounds;
*Array_BadIndex = *XML::Xercesc::XMLExcepts_Array_BadIndex;
*Array_BadNewSize = *XML::Xercesc::XMLExcepts_Array_BadNewSize;
*AttrList_BadIndex = *XML::Xercesc::XMLExcepts_AttrList_BadIndex;
*AttDef_BadAttType = *XML::Xercesc::XMLExcepts_AttDef_BadAttType;
*AttDef_BadDefAttType = *XML::Xercesc::XMLExcepts_AttDef_BadDefAttType;
*Bitset_BadIndex = *XML::Xercesc::XMLExcepts_Bitset_BadIndex;
*Bitset_NotEqualSize = *XML::Xercesc::XMLExcepts_Bitset_NotEqualSize;
*BufMgr_NoMoreBuffers = *XML::Xercesc::XMLExcepts_BufMgr_NoMoreBuffers;
*BufMgr_BufferNotInPool = *XML::Xercesc::XMLExcepts_BufMgr_BufferNotInPool;
*CPtr_PointerIsZero = *XML::Xercesc::XMLExcepts_CPtr_PointerIsZero;
*CM_BinOpHadUnaryType = *XML::Xercesc::XMLExcepts_CM_BinOpHadUnaryType;
*CM_MustBeMixedOrChildren = *XML::Xercesc::XMLExcepts_CM_MustBeMixedOrChildren;
*CM_NoPCDATAHere = *XML::Xercesc::XMLExcepts_CM_NoPCDATAHere;
*CM_NotValidForSpecType = *XML::Xercesc::XMLExcepts_CM_NotValidForSpecType;
*CM_UnaryOpHadBinType = *XML::Xercesc::XMLExcepts_CM_UnaryOpHadBinType;
*CM_UnknownCMType = *XML::Xercesc::XMLExcepts_CM_UnknownCMType;
*CM_UnknownCMSpecType = *XML::Xercesc::XMLExcepts_CM_UnknownCMSpecType;
*CM_NoParentCSN = *XML::Xercesc::XMLExcepts_CM_NoParentCSN;
*CM_NotValidSpecTypeForNode = *XML::Xercesc::XMLExcepts_CM_NotValidSpecTypeForNode;
*DTD_UnknownCreateReason = *XML::Xercesc::XMLExcepts_DTD_UnknownCreateReason;
*ElemStack_EmptyStack = *XML::Xercesc::XMLExcepts_ElemStack_EmptyStack;
*ElemStack_BadIndex = *XML::Xercesc::XMLExcepts_ElemStack_BadIndex;
*ElemStack_StackUnderflow = *XML::Xercesc::XMLExcepts_ElemStack_StackUnderflow;
*ElemStack_NoParentPushed = *XML::Xercesc::XMLExcepts_ElemStack_NoParentPushed;
*Enum_NoMoreElements = *XML::Xercesc::XMLExcepts_Enum_NoMoreElements;
*File_CouldNotOpenFile = *XML::Xercesc::XMLExcepts_File_CouldNotOpenFile;
*File_CouldNotGetCurPos = *XML::Xercesc::XMLExcepts_File_CouldNotGetCurPos;
*File_CouldNotCloseFile = *XML::Xercesc::XMLExcepts_File_CouldNotCloseFile;
*File_CouldNotSeekToEnd = *XML::Xercesc::XMLExcepts_File_CouldNotSeekToEnd;
*File_CouldNotSeekToPos = *XML::Xercesc::XMLExcepts_File_CouldNotSeekToPos;
*File_CouldNotDupHandle = *XML::Xercesc::XMLExcepts_File_CouldNotDupHandle;
*File_CouldNotReadFromFile = *XML::Xercesc::XMLExcepts_File_CouldNotReadFromFile;
*File_CouldNotResetFile = *XML::Xercesc::XMLExcepts_File_CouldNotResetFile;
*File_CouldNotGetSize = *XML::Xercesc::XMLExcepts_File_CouldNotGetSize;
*File_CouldNotGetBasePathName = *XML::Xercesc::XMLExcepts_File_CouldNotGetBasePathName;
*File_BasePathUnderflow = *XML::Xercesc::XMLExcepts_File_BasePathUnderflow;
*Gen_ParseInProgress = *XML::Xercesc::XMLExcepts_Gen_ParseInProgress;
*Gen_NoDTDValidator = *XML::Xercesc::XMLExcepts_Gen_NoDTDValidator;
*Gen_CouldNotOpenDTD = *XML::Xercesc::XMLExcepts_Gen_CouldNotOpenDTD;
*Gen_CouldNotOpenExtEntity = *XML::Xercesc::XMLExcepts_Gen_CouldNotOpenExtEntity;
*Gen_UnexpectedEOF = *XML::Xercesc::XMLExcepts_Gen_UnexpectedEOF;
*HshTbl_ZeroModulus = *XML::Xercesc::XMLExcepts_HshTbl_ZeroModulus;
*HshTbl_BadHashFromKey = *XML::Xercesc::XMLExcepts_HshTbl_BadHashFromKey;
*HshTbl_NoSuchKeyExists = *XML::Xercesc::XMLExcepts_HshTbl_NoSuchKeyExists;
*Mutex_CouldNotCreate = *XML::Xercesc::XMLExcepts_Mutex_CouldNotCreate;
*Mutex_CouldNotClose = *XML::Xercesc::XMLExcepts_Mutex_CouldNotClose;
*Mutex_CouldNotLock = *XML::Xercesc::XMLExcepts_Mutex_CouldNotLock;
*Mutex_CouldNotUnlock = *XML::Xercesc::XMLExcepts_Mutex_CouldNotUnlock;
*Mutex_CouldNotDestroy = *XML::Xercesc::XMLExcepts_Mutex_CouldNotDestroy;
*NetAcc_InternalError = *XML::Xercesc::XMLExcepts_NetAcc_InternalError;
*NetAcc_InitFailed = *XML::Xercesc::XMLExcepts_NetAcc_InitFailed;
*NetAcc_TargetResolution = *XML::Xercesc::XMLExcepts_NetAcc_TargetResolution;
*NetAcc_CreateSocket = *XML::Xercesc::XMLExcepts_NetAcc_CreateSocket;
*NetAcc_ConnSocket = *XML::Xercesc::XMLExcepts_NetAcc_ConnSocket;
*NetAcc_WriteSocket = *XML::Xercesc::XMLExcepts_NetAcc_WriteSocket;
*NetAcc_ReadSocket = *XML::Xercesc::XMLExcepts_NetAcc_ReadSocket;
*Pool_ElemAlreadyExists = *XML::Xercesc::XMLExcepts_Pool_ElemAlreadyExists;
*Pool_BadHashFromKey = *XML::Xercesc::XMLExcepts_Pool_BadHashFromKey;
*Pool_InvalidId = *XML::Xercesc::XMLExcepts_Pool_InvalidId;
*Pool_ZeroModulus = *XML::Xercesc::XMLExcepts_Pool_ZeroModulus;
*RdrMgr_ReaderIdNotFound = *XML::Xercesc::XMLExcepts_RdrMgr_ReaderIdNotFound;
*Reader_BadAutoEncoding = *XML::Xercesc::XMLExcepts_Reader_BadAutoEncoding;
*Reader_CouldNotDecodeFirstLine = *XML::Xercesc::XMLExcepts_Reader_CouldNotDecodeFirstLine;
*Reader_EOIInMultiSeq = *XML::Xercesc::XMLExcepts_Reader_EOIInMultiSeq;
*Reader_SrcOfsNotSupported = *XML::Xercesc::XMLExcepts_Reader_SrcOfsNotSupported;
*Reader_EncodingStrRequired = *XML::Xercesc::XMLExcepts_Reader_EncodingStrRequired;
*Scan_CouldNotOpenSource = *XML::Xercesc::XMLExcepts_Scan_CouldNotOpenSource;
*Scan_UnbalancedStartEnd = *XML::Xercesc::XMLExcepts_Scan_UnbalancedStartEnd;
*Scan_BadPScanToken = *XML::Xercesc::XMLExcepts_Scan_BadPScanToken;
*Stack_BadIndex = *XML::Xercesc::XMLExcepts_Stack_BadIndex;
*Stack_EmptyStack = *XML::Xercesc::XMLExcepts_Stack_EmptyStack;
*Str_ZeroSizedTargetBuf = *XML::Xercesc::XMLExcepts_Str_ZeroSizedTargetBuf;
*Str_UnknownRadix = *XML::Xercesc::XMLExcepts_Str_UnknownRadix;
*Str_TargetBufTooSmall = *XML::Xercesc::XMLExcepts_Str_TargetBufTooSmall;
*Str_StartIndexPastEnd = *XML::Xercesc::XMLExcepts_Str_StartIndexPastEnd;
*Str_ConvertOverflow = *XML::Xercesc::XMLExcepts_Str_ConvertOverflow;
*Strm_StdErrWriteFailure = *XML::Xercesc::XMLExcepts_Strm_StdErrWriteFailure;
*Strm_StdOutWriteFailure = *XML::Xercesc::XMLExcepts_Strm_StdOutWriteFailure;
*Strm_ConWriteFailure = *XML::Xercesc::XMLExcepts_Strm_ConWriteFailure;
*StrPool_IllegalId = *XML::Xercesc::XMLExcepts_StrPool_IllegalId;
*Trans_CouldNotCreateDefCvtr = *XML::Xercesc::XMLExcepts_Trans_CouldNotCreateDefCvtr;
*Trans_InvalidSizeReq = *XML::Xercesc::XMLExcepts_Trans_InvalidSizeReq;
*Trans_Unrepresentable = *XML::Xercesc::XMLExcepts_Trans_Unrepresentable;
*Trans_NotValidForEncoding = *XML::Xercesc::XMLExcepts_Trans_NotValidForEncoding;
*Trans_BadBlockSize = *XML::Xercesc::XMLExcepts_Trans_BadBlockSize;
*Trans_BadSrcSeq = *XML::Xercesc::XMLExcepts_Trans_BadSrcSeq;
*Trans_BadSrcCP = *XML::Xercesc::XMLExcepts_Trans_BadSrcCP;
*Trans_BadTrailingSurrogate = *XML::Xercesc::XMLExcepts_Trans_BadTrailingSurrogate;
*Trans_CantCreateCvtrFor = *XML::Xercesc::XMLExcepts_Trans_CantCreateCvtrFor;
*URL_MalformedURL = *XML::Xercesc::XMLExcepts_URL_MalformedURL;
*URL_UnsupportedProto = *XML::Xercesc::XMLExcepts_URL_UnsupportedProto;
*URL_UnsupportedProto1 = *XML::Xercesc::XMLExcepts_URL_UnsupportedProto1;
*URL_OnlyLocalHost = *XML::Xercesc::XMLExcepts_URL_OnlyLocalHost;
*URL_NoProtocolPresent = *XML::Xercesc::XMLExcepts_URL_NoProtocolPresent;
*URL_ExpectingTwoSlashes = *XML::Xercesc::XMLExcepts_URL_ExpectingTwoSlashes;
*URL_IncorrectEscapedCharRef = *XML::Xercesc::XMLExcepts_URL_IncorrectEscapedCharRef;
*URL_UnterminatedHostComponent = *XML::Xercesc::XMLExcepts_URL_UnterminatedHostComponent;
*URL_RelativeBaseURL = *XML::Xercesc::XMLExcepts_URL_RelativeBaseURL;
*URL_BaseUnderflow = *XML::Xercesc::XMLExcepts_URL_BaseUnderflow;
*URL_BadPortField = *XML::Xercesc::XMLExcepts_URL_BadPortField;
*Vector_BadIndex = *XML::Xercesc::XMLExcepts_Vector_BadIndex;
*Val_InvalidElemId = *XML::Xercesc::XMLExcepts_Val_InvalidElemId;
*Val_CantHaveIntSS = *XML::Xercesc::XMLExcepts_Val_CantHaveIntSS;
*XMLRec_UnknownEncoding = *XML::Xercesc::XMLExcepts_XMLRec_UnknownEncoding;
*Parser_Parse1 = *XML::Xercesc::XMLExcepts_Parser_Parse1;
*Parser_Parse2 = *XML::Xercesc::XMLExcepts_Parser_Parse2;
*Parser_Next1 = *XML::Xercesc::XMLExcepts_Parser_Next1;
*Parser_Next2 = *XML::Xercesc::XMLExcepts_Parser_Next2;
*Parser_Next3 = *XML::Xercesc::XMLExcepts_Parser_Next3;
*Parser_Next4 = *XML::Xercesc::XMLExcepts_Parser_Next4;
*Parser_Factor1 = *XML::Xercesc::XMLExcepts_Parser_Factor1;
*Parser_Factor2 = *XML::Xercesc::XMLExcepts_Parser_Factor2;
*Parser_Factor3 = *XML::Xercesc::XMLExcepts_Parser_Factor3;
*Parser_Factor4 = *XML::Xercesc::XMLExcepts_Parser_Factor4;
*Parser_Factor5 = *XML::Xercesc::XMLExcepts_Parser_Factor5;
*Parser_Factor6 = *XML::Xercesc::XMLExcepts_Parser_Factor6;
*Parser_Atom1 = *XML::Xercesc::XMLExcepts_Parser_Atom1;
*Parser_Atom2 = *XML::Xercesc::XMLExcepts_Parser_Atom2;
*Parser_Atom3 = *XML::Xercesc::XMLExcepts_Parser_Atom3;
*Parser_Atom4 = *XML::Xercesc::XMLExcepts_Parser_Atom4;
*Parser_Atom5 = *XML::Xercesc::XMLExcepts_Parser_Atom5;
*Parser_CC1 = *XML::Xercesc::XMLExcepts_Parser_CC1;
*Parser_CC2 = *XML::Xercesc::XMLExcepts_Parser_CC2;
*Parser_CC3 = *XML::Xercesc::XMLExcepts_Parser_CC3;
*Parser_CC4 = *XML::Xercesc::XMLExcepts_Parser_CC4;
*Parser_CC5 = *XML::Xercesc::XMLExcepts_Parser_CC5;
*Parser_CC6 = *XML::Xercesc::XMLExcepts_Parser_CC6;
*Parser_CC7 = *XML::Xercesc::XMLExcepts_Parser_CC7;
*Parser_Ope1 = *XML::Xercesc::XMLExcepts_Parser_Ope1;
*Parser_Ope2 = *XML::Xercesc::XMLExcepts_Parser_Ope2;
*Parser_Ope3 = *XML::Xercesc::XMLExcepts_Parser_Ope3;
*Parser_Descape1 = *XML::Xercesc::XMLExcepts_Parser_Descape1;
*Parser_Descape2 = *XML::Xercesc::XMLExcepts_Parser_Descape2;
*Parser_Descape3 = *XML::Xercesc::XMLExcepts_Parser_Descape3;
*Parser_Descape4 = *XML::Xercesc::XMLExcepts_Parser_Descape4;
*Parser_Descape5 = *XML::Xercesc::XMLExcepts_Parser_Descape5;
*Parser_Process1 = *XML::Xercesc::XMLExcepts_Parser_Process1;
*Parser_Process2 = *XML::Xercesc::XMLExcepts_Parser_Process2;
*Gen_NoSchemaValidator = *XML::Xercesc::XMLExcepts_Gen_NoSchemaValidator;
*XUTIL_UnCopyableNodeType = *XML::Xercesc::XMLExcepts_XUTIL_UnCopyableNodeType;
*SubGrpComparator_NGR = *XML::Xercesc::XMLExcepts_SubGrpComparator_NGR;
*FACET_Invalid_Len = *XML::Xercesc::XMLExcepts_FACET_Invalid_Len;
*FACET_Invalid_maxLen = *XML::Xercesc::XMLExcepts_FACET_Invalid_maxLen;
*FACET_Invalid_minLen = *XML::Xercesc::XMLExcepts_FACET_Invalid_minLen;
*FACET_NonNeg_Len = *XML::Xercesc::XMLExcepts_FACET_NonNeg_Len;
*FACET_NonNeg_maxLen = *XML::Xercesc::XMLExcepts_FACET_NonNeg_maxLen;
*FACET_NonNeg_minLen = *XML::Xercesc::XMLExcepts_FACET_NonNeg_minLen;
*FACET_Len_maxLen = *XML::Xercesc::XMLExcepts_FACET_Len_maxLen;
*FACET_Len_minLen = *XML::Xercesc::XMLExcepts_FACET_Len_minLen;
*FACET_maxLen_minLen = *XML::Xercesc::XMLExcepts_FACET_maxLen_minLen;
*FACET_bool_Pattern = *XML::Xercesc::XMLExcepts_FACET_bool_Pattern;
*FACET_Invalid_Tag = *XML::Xercesc::XMLExcepts_FACET_Invalid_Tag;
*FACET_Len_baseLen = *XML::Xercesc::XMLExcepts_FACET_Len_baseLen;
*FACET_minLen_baseminLen = *XML::Xercesc::XMLExcepts_FACET_minLen_baseminLen;
*FACET_minLen_basemaxLen = *XML::Xercesc::XMLExcepts_FACET_minLen_basemaxLen;
*FACET_maxLen_basemaxLen = *XML::Xercesc::XMLExcepts_FACET_maxLen_basemaxLen;
*FACET_maxLen_baseminLen = *XML::Xercesc::XMLExcepts_FACET_maxLen_baseminLen;
*FACET_enum_base = *XML::Xercesc::XMLExcepts_FACET_enum_base;
*FACET_Invalid_WS = *XML::Xercesc::XMLExcepts_FACET_Invalid_WS;
*FACET_WS_collapse = *XML::Xercesc::XMLExcepts_FACET_WS_collapse;
*FACET_WS_replace = *XML::Xercesc::XMLExcepts_FACET_WS_replace;
*FACET_Invalid_MaxIncl = *XML::Xercesc::XMLExcepts_FACET_Invalid_MaxIncl;
*FACET_Invalid_MaxExcl = *XML::Xercesc::XMLExcepts_FACET_Invalid_MaxExcl;
*FACET_Invalid_MinIncl = *XML::Xercesc::XMLExcepts_FACET_Invalid_MinIncl;
*FACET_Invalid_MinExcl = *XML::Xercesc::XMLExcepts_FACET_Invalid_MinExcl;
*FACET_Invalid_TotalDigit = *XML::Xercesc::XMLExcepts_FACET_Invalid_TotalDigit;
*FACET_Invalid_FractDigit = *XML::Xercesc::XMLExcepts_FACET_Invalid_FractDigit;
*FACET_NonNeg_TotalDigit = *XML::Xercesc::XMLExcepts_FACET_NonNeg_TotalDigit;
*FACET_NonNeg_FractDigit = *XML::Xercesc::XMLExcepts_FACET_NonNeg_FractDigit;
*FACET_max_Incl_Excl = *XML::Xercesc::XMLExcepts_FACET_max_Incl_Excl;
*FACET_min_Incl_Excl = *XML::Xercesc::XMLExcepts_FACET_min_Incl_Excl;
*FACET_maxExcl_minExcl = *XML::Xercesc::XMLExcepts_FACET_maxExcl_minExcl;
*FACET_maxExcl_minIncl = *XML::Xercesc::XMLExcepts_FACET_maxExcl_minIncl;
*FACET_maxIncl_minExcl = *XML::Xercesc::XMLExcepts_FACET_maxIncl_minExcl;
*FACET_maxIncl_minIncl = *XML::Xercesc::XMLExcepts_FACET_maxIncl_minIncl;
*FACET_TotDigit_FractDigit = *XML::Xercesc::XMLExcepts_FACET_TotDigit_FractDigit;
*FACET_maxIncl_base_maxExcl = *XML::Xercesc::XMLExcepts_FACET_maxIncl_base_maxExcl;
*FACET_maxIncl_base_maxIncl = *XML::Xercesc::XMLExcepts_FACET_maxIncl_base_maxIncl;
*FACET_maxIncl_base_minIncl = *XML::Xercesc::XMLExcepts_FACET_maxIncl_base_minIncl;
*FACET_maxIncl_base_minExcl = *XML::Xercesc::XMLExcepts_FACET_maxIncl_base_minExcl;
*FACET_maxExcl_base_maxExcl = *XML::Xercesc::XMLExcepts_FACET_maxExcl_base_maxExcl;
*FACET_maxExcl_base_maxIncl = *XML::Xercesc::XMLExcepts_FACET_maxExcl_base_maxIncl;
*FACET_maxExcl_base_minIncl = *XML::Xercesc::XMLExcepts_FACET_maxExcl_base_minIncl;
*FACET_maxExcl_base_minExcl = *XML::Xercesc::XMLExcepts_FACET_maxExcl_base_minExcl;
*FACET_minExcl_base_maxExcl = *XML::Xercesc::XMLExcepts_FACET_minExcl_base_maxExcl;
*FACET_minExcl_base_maxIncl = *XML::Xercesc::XMLExcepts_FACET_minExcl_base_maxIncl;
*FACET_minExcl_base_minIncl = *XML::Xercesc::XMLExcepts_FACET_minExcl_base_minIncl;
*FACET_minExcl_base_minExcl = *XML::Xercesc::XMLExcepts_FACET_minExcl_base_minExcl;
*FACET_minIncl_base_maxExcl = *XML::Xercesc::XMLExcepts_FACET_minIncl_base_maxExcl;
*FACET_minIncl_base_maxIncl = *XML::Xercesc::XMLExcepts_FACET_minIncl_base_maxIncl;
*FACET_minIncl_base_minIncl = *XML::Xercesc::XMLExcepts_FACET_minIncl_base_minIncl;
*FACET_minIncl_base_minExcl = *XML::Xercesc::XMLExcepts_FACET_minIncl_base_minExcl;
*FACET_maxIncl_notFromBase = *XML::Xercesc::XMLExcepts_FACET_maxIncl_notFromBase;
*FACET_maxExcl_notFromBase = *XML::Xercesc::XMLExcepts_FACET_maxExcl_notFromBase;
*FACET_minIncl_notFromBase = *XML::Xercesc::XMLExcepts_FACET_minIncl_notFromBase;
*FACET_minExcl_notFromBase = *XML::Xercesc::XMLExcepts_FACET_minExcl_notFromBase;
*FACET_totalDigit_base_totalDigit = *XML::Xercesc::XMLExcepts_FACET_totalDigit_base_totalDigit;
*FACET_fractDigit_base_totalDigit = *XML::Xercesc::XMLExcepts_FACET_fractDigit_base_totalDigit;
*FACET_fractDigit_base_fractDigit = *XML::Xercesc::XMLExcepts_FACET_fractDigit_base_fractDigit;
*FACET_maxIncl_base_fixed = *XML::Xercesc::XMLExcepts_FACET_maxIncl_base_fixed;
*FACET_maxExcl_base_fixed = *XML::Xercesc::XMLExcepts_FACET_maxExcl_base_fixed;
*FACET_minIncl_base_fixed = *XML::Xercesc::XMLExcepts_FACET_minIncl_base_fixed;
*FACET_minExcl_base_fixed = *XML::Xercesc::XMLExcepts_FACET_minExcl_base_fixed;
*FACET_totalDigit_base_fixed = *XML::Xercesc::XMLExcepts_FACET_totalDigit_base_fixed;
*FACET_fractDigit_base_fixed = *XML::Xercesc::XMLExcepts_FACET_fractDigit_base_fixed;
*FACET_maxLen_base_fixed = *XML::Xercesc::XMLExcepts_FACET_maxLen_base_fixed;
*FACET_minLen_base_fixed = *XML::Xercesc::XMLExcepts_FACET_minLen_base_fixed;
*FACET_len_base_fixed = *XML::Xercesc::XMLExcepts_FACET_len_base_fixed;
*FACET_whitespace_base_fixed = *XML::Xercesc::XMLExcepts_FACET_whitespace_base_fixed;
*FACET_internalError_fixed = *XML::Xercesc::XMLExcepts_FACET_internalError_fixed;
*FACET_List_Null_baseValidator = *XML::Xercesc::XMLExcepts_FACET_List_Null_baseValidator;
*FACET_Union_Null_memberTypeValidators = *XML::Xercesc::XMLExcepts_FACET_Union_Null_memberTypeValidators;
*FACET_Union_Null_baseValidator = *XML::Xercesc::XMLExcepts_FACET_Union_Null_baseValidator;
*FACET_Union_invalid_baseValidatorType = *XML::Xercesc::XMLExcepts_FACET_Union_invalid_baseValidatorType;
*VALUE_NotMatch_Pattern = *XML::Xercesc::XMLExcepts_VALUE_NotMatch_Pattern;
*VALUE_Not_Base64 = *XML::Xercesc::XMLExcepts_VALUE_Not_Base64;
*VALUE_Not_HexBin = *XML::Xercesc::XMLExcepts_VALUE_Not_HexBin;
*VALUE_GT_maxLen = *XML::Xercesc::XMLExcepts_VALUE_GT_maxLen;
*VALUE_LT_minLen = *XML::Xercesc::XMLExcepts_VALUE_LT_minLen;
*VALUE_NE_Len = *XML::Xercesc::XMLExcepts_VALUE_NE_Len;
*VALUE_NotIn_Enumeration = *XML::Xercesc::XMLExcepts_VALUE_NotIn_Enumeration;
*VALUE_exceed_totalDigit = *XML::Xercesc::XMLExcepts_VALUE_exceed_totalDigit;
*VALUE_exceed_fractDigit = *XML::Xercesc::XMLExcepts_VALUE_exceed_fractDigit;
*VALUE_exceed_maxIncl = *XML::Xercesc::XMLExcepts_VALUE_exceed_maxIncl;
*VALUE_exceed_maxExcl = *XML::Xercesc::XMLExcepts_VALUE_exceed_maxExcl;
*VALUE_exceed_minIncl = *XML::Xercesc::XMLExcepts_VALUE_exceed_minIncl;
*VALUE_exceed_minExcl = *XML::Xercesc::XMLExcepts_VALUE_exceed_minExcl;
*VALUE_WS_replaced = *XML::Xercesc::XMLExcepts_VALUE_WS_replaced;
*VALUE_WS_collapsed = *XML::Xercesc::XMLExcepts_VALUE_WS_collapsed;
*VALUE_Invalid_NCName = *XML::Xercesc::XMLExcepts_VALUE_Invalid_NCName;
*VALUE_Invalid_Name = *XML::Xercesc::XMLExcepts_VALUE_Invalid_Name;
*VALUE_ID_Not_Unique = *XML::Xercesc::XMLExcepts_VALUE_ID_Not_Unique;
*VALUE_ENTITY_Invalid = *XML::Xercesc::XMLExcepts_VALUE_ENTITY_Invalid;
*VALUE_QName_Invalid = *XML::Xercesc::XMLExcepts_VALUE_QName_Invalid;
*VALUE_NOTATION_Invalid = *XML::Xercesc::XMLExcepts_VALUE_NOTATION_Invalid;
*VALUE_no_match_memberType = *XML::Xercesc::XMLExcepts_VALUE_no_match_memberType;
*VALUE_URI_Malformed = *XML::Xercesc::XMLExcepts_VALUE_URI_Malformed;
*XMLNUM_emptyString = *XML::Xercesc::XMLExcepts_XMLNUM_emptyString;
*XMLNUM_WSString = *XML::Xercesc::XMLExcepts_XMLNUM_WSString;
*XMLNUM_2ManyDecPoint = *XML::Xercesc::XMLExcepts_XMLNUM_2ManyDecPoint;
*XMLNUM_Inv_chars = *XML::Xercesc::XMLExcepts_XMLNUM_Inv_chars;
*XMLNUM_null_ptr = *XML::Xercesc::XMLExcepts_XMLNUM_null_ptr;
*XMLNUM_URI_Component_Empty = *XML::Xercesc::XMLExcepts_XMLNUM_URI_Component_Empty;
*XMLNUM_URI_Component_for_GenURI_Only = *XML::Xercesc::XMLExcepts_XMLNUM_URI_Component_for_GenURI_Only;
*XMLNUM_URI_Component_Invalid_EscapeSequence = *XML::Xercesc::XMLExcepts_XMLNUM_URI_Component_Invalid_EscapeSequence;
*XMLNUM_URI_Component_Invalid_Char = *XML::Xercesc::XMLExcepts_XMLNUM_URI_Component_Invalid_Char;
*XMLNUM_URI_Component_Set_Null = *XML::Xercesc::XMLExcepts_XMLNUM_URI_Component_Set_Null;
*XMLNUM_URI_Component_Not_Conformant = *XML::Xercesc::XMLExcepts_XMLNUM_URI_Component_Not_Conformant;
*XMLNUM_URI_No_Scheme = *XML::Xercesc::XMLExcepts_XMLNUM_URI_No_Scheme;
*XMLNUM_URI_NullHost = *XML::Xercesc::XMLExcepts_XMLNUM_URI_NullHost;
*XMLNUM_URI_NullPath = *XML::Xercesc::XMLExcepts_XMLNUM_URI_NullPath;
*XMLNUM_URI_Component_inPath = *XML::Xercesc::XMLExcepts_XMLNUM_URI_Component_inPath;
*XMLNUM_URI_PortNo_Invalid = *XML::Xercesc::XMLExcepts_XMLNUM_URI_PortNo_Invalid;
*XMLNUM_DBL_FLT_maxNeg = *XML::Xercesc::XMLExcepts_XMLNUM_DBL_FLT_maxNeg;
*XMLNUM_DBL_FLT_maxPos = *XML::Xercesc::XMLExcepts_XMLNUM_DBL_FLT_maxPos;
*XMLNUM_DBL_FLT_minNegPos = *XML::Xercesc::XMLExcepts_XMLNUM_DBL_FLT_minNegPos;
*XMLNUM_DBL_FLT_InvalidType = *XML::Xercesc::XMLExcepts_XMLNUM_DBL_FLT_InvalidType;
*XMLNUM_DBL_FLT_No_Exponent = *XML::Xercesc::XMLExcepts_XMLNUM_DBL_FLT_No_Exponent;
*Regex_Result_Not_Set = *XML::Xercesc::XMLExcepts_Regex_Result_Not_Set;
*Regex_CompactRangesError = *XML::Xercesc::XMLExcepts_Regex_CompactRangesError;
*Regex_MergeRangesTypeMismatch = *XML::Xercesc::XMLExcepts_Regex_MergeRangesTypeMismatch;
*Regex_SubtractRangesError = *XML::Xercesc::XMLExcepts_Regex_SubtractRangesError;
*Regex_IntersectRangesError = *XML::Xercesc::XMLExcepts_Regex_IntersectRangesError;
*Regex_ComplementRangesInvalidArg = *XML::Xercesc::XMLExcepts_Regex_ComplementRangesInvalidArg;
*Regex_InvalidCategoryName = *XML::Xercesc::XMLExcepts_Regex_InvalidCategoryName;
*Regex_KeywordNotFound = *XML::Xercesc::XMLExcepts_Regex_KeywordNotFound;
*Regex_BadRefNo = *XML::Xercesc::XMLExcepts_Regex_BadRefNo;
*Regex_UnknownOption = *XML::Xercesc::XMLExcepts_Regex_UnknownOption;
*Regex_UnknownTokenType = *XML::Xercesc::XMLExcepts_Regex_UnknownTokenType;
*Regex_RangeTokenGetError = *XML::Xercesc::XMLExcepts_Regex_RangeTokenGetError;
*Regex_NotSupported = *XML::Xercesc::XMLExcepts_Regex_NotSupported;
*Regex_InvalidChildIndex = *XML::Xercesc::XMLExcepts_Regex_InvalidChildIndex;
*Regex_InvalidQuantifier = *XML::Xercesc::XMLExcepts_Regex_InvalidQuantifier;
*NEL_RepeatedCalls = *XML::Xercesc::XMLExcepts_NEL_RepeatedCalls;
*RethrowError = *XML::Xercesc::XMLExcepts_RethrowError;
*Out_Of_Memory = *XML::Xercesc::XMLExcepts_Out_Of_Memory;
*DV_InvalidOperation = *XML::Xercesc::XMLExcepts_DV_InvalidOperation;
*XPath_NoAttrSelector = *XML::Xercesc::XMLExcepts_XPath_NoAttrSelector;
*XPath_NoUnionAtStart = *XML::Xercesc::XMLExcepts_XPath_NoUnionAtStart;
*XPath_NoMultipleUnion = *XML::Xercesc::XMLExcepts_XPath_NoMultipleUnion;
*XPath_MissingAttr = *XML::Xercesc::XMLExcepts_XPath_MissingAttr;
*XPath_ExpectedToken1 = *XML::Xercesc::XMLExcepts_XPath_ExpectedToken1;
*XPath_PrefixNoURI = *XML::Xercesc::XMLExcepts_XPath_PrefixNoURI;
*XPath_NoDoubleColon = *XML::Xercesc::XMLExcepts_XPath_NoDoubleColon;
*XPath_ExpectedStep1 = *XML::Xercesc::XMLExcepts_XPath_ExpectedStep1;
*XPath_ExpectedStep2 = *XML::Xercesc::XMLExcepts_XPath_ExpectedStep2;
*XPath_ExpectedStep3 = *XML::Xercesc::XMLExcepts_XPath_ExpectedStep3;
*XPath_NoForwardSlash = *XML::Xercesc::XMLExcepts_XPath_NoForwardSlash;
*XPath_NoDoubleForwardSlash = *XML::Xercesc::XMLExcepts_XPath_NoDoubleForwardSlash;
*XPath_NoForwardSlashAtStart = *XML::Xercesc::XMLExcepts_XPath_NoForwardSlashAtStart;
*XPath_NoSelectionOfRoot = *XML::Xercesc::XMLExcepts_XPath_NoSelectionOfRoot;
*XPath_EmptyExpr = *XML::Xercesc::XMLExcepts_XPath_EmptyExpr;
*XPath_NoUnionAtEnd = *XML::Xercesc::XMLExcepts_XPath_NoUnionAtEnd;
*XPath_InvalidChar = *XML::Xercesc::XMLExcepts_XPath_InvalidChar;
*XPath_TokenNotSupported = *XML::Xercesc::XMLExcepts_XPath_TokenNotSupported;
*XPath_FindSolution = *XML::Xercesc::XMLExcepts_XPath_FindSolution;
*DateTime_Assert_Buffer_Fail = *XML::Xercesc::XMLExcepts_DateTime_Assert_Buffer_Fail;
*DateTime_dt_missingT = *XML::Xercesc::XMLExcepts_DateTime_dt_missingT;
*DateTime_gDay_invalid = *XML::Xercesc::XMLExcepts_DateTime_gDay_invalid;
*DateTime_gMth_invalid = *XML::Xercesc::XMLExcepts_DateTime_gMth_invalid;
*DateTime_gMthDay_invalid = *XML::Xercesc::XMLExcepts_DateTime_gMthDay_invalid;
*DateTime_dur_Start_dashP = *XML::Xercesc::XMLExcepts_DateTime_dur_Start_dashP;
*DateTime_dur_noP = *XML::Xercesc::XMLExcepts_DateTime_dur_noP;
*DateTime_dur_DashNotFirst = *XML::Xercesc::XMLExcepts_DateTime_dur_DashNotFirst;
*DateTime_dur_inv_b4T = *XML::Xercesc::XMLExcepts_DateTime_dur_inv_b4T;
*DateTime_dur_NoTimeAfterT = *XML::Xercesc::XMLExcepts_DateTime_dur_NoTimeAfterT;
*DateTime_dur_NoElementAtAll = *XML::Xercesc::XMLExcepts_DateTime_dur_NoElementAtAll;
*DateTime_date_incomplete = *XML::Xercesc::XMLExcepts_DateTime_date_incomplete;
*DateTime_date_invalid = *XML::Xercesc::XMLExcepts_DateTime_date_invalid;
*DateTime_time_incomplete = *XML::Xercesc::XMLExcepts_DateTime_time_incomplete;
*DateTime_time_invalid = *XML::Xercesc::XMLExcepts_DateTime_time_invalid;
*DateTime_ms_noDigit = *XML::Xercesc::XMLExcepts_DateTime_ms_noDigit;
*DateTime_ym_incomplete = *XML::Xercesc::XMLExcepts_DateTime_ym_incomplete;
*DateTime_ym_invalid = *XML::Xercesc::XMLExcepts_DateTime_ym_invalid;
*DateTime_year_tooShort = *XML::Xercesc::XMLExcepts_DateTime_year_tooShort;
*DateTime_year_leadingZero = *XML::Xercesc::XMLExcepts_DateTime_year_leadingZero;
*DateTime_ym_noMonth = *XML::Xercesc::XMLExcepts_DateTime_ym_noMonth;
*DateTime_tz_noUTCsign = *XML::Xercesc::XMLExcepts_DateTime_tz_noUTCsign;
*DateTime_tz_stuffAfterZ = *XML::Xercesc::XMLExcepts_DateTime_tz_stuffAfterZ;
*DateTime_tz_invalid = *XML::Xercesc::XMLExcepts_DateTime_tz_invalid;
*DateTime_year_zero = *XML::Xercesc::XMLExcepts_DateTime_year_zero;
*DateTime_mth_invalid = *XML::Xercesc::XMLExcepts_DateTime_mth_invalid;
*DateTime_day_invalid = *XML::Xercesc::XMLExcepts_DateTime_day_invalid;
*DateTime_hour_invalid = *XML::Xercesc::XMLExcepts_DateTime_hour_invalid;
*DateTime_min_invalid = *XML::Xercesc::XMLExcepts_DateTime_min_invalid;
*DateTime_second_invalid = *XML::Xercesc::XMLExcepts_DateTime_second_invalid;
*DateTime_tz_hh_invalid = *XML::Xercesc::XMLExcepts_DateTime_tz_hh_invalid;
*PD_NSCompat1 = *XML::Xercesc::XMLExcepts_PD_NSCompat1;
*PD_OccurRangeE = *XML::Xercesc::XMLExcepts_PD_OccurRangeE;
*PD_NameTypeOK1 = *XML::Xercesc::XMLExcepts_PD_NameTypeOK1;
*PD_NameTypeOK2 = *XML::Xercesc::XMLExcepts_PD_NameTypeOK2;
*PD_NameTypeOK3 = *XML::Xercesc::XMLExcepts_PD_NameTypeOK3;
*PD_NameTypeOK4 = *XML::Xercesc::XMLExcepts_PD_NameTypeOK4;
*PD_NameTypeOK5 = *XML::Xercesc::XMLExcepts_PD_NameTypeOK5;
*PD_NameTypeOK6 = *XML::Xercesc::XMLExcepts_PD_NameTypeOK6;
*PD_NameTypeOK7 = *XML::Xercesc::XMLExcepts_PD_NameTypeOK7;
*PD_RecurseAsIfGroup = *XML::Xercesc::XMLExcepts_PD_RecurseAsIfGroup;
*PD_Recurse1 = *XML::Xercesc::XMLExcepts_PD_Recurse1;
*PD_Recurse2 = *XML::Xercesc::XMLExcepts_PD_Recurse2;
*PD_ForbiddenRes1 = *XML::Xercesc::XMLExcepts_PD_ForbiddenRes1;
*PD_ForbiddenRes2 = *XML::Xercesc::XMLExcepts_PD_ForbiddenRes2;
*PD_ForbiddenRes3 = *XML::Xercesc::XMLExcepts_PD_ForbiddenRes3;
*PD_ForbiddenRes4 = *XML::Xercesc::XMLExcepts_PD_ForbiddenRes4;
*PD_NSSubset1 = *XML::Xercesc::XMLExcepts_PD_NSSubset1;
*PD_NSSubset2 = *XML::Xercesc::XMLExcepts_PD_NSSubset2;
*PD_NSRecurseCheckCardinality1 = *XML::Xercesc::XMLExcepts_PD_NSRecurseCheckCardinality1;
*PD_RecurseUnordered = *XML::Xercesc::XMLExcepts_PD_RecurseUnordered;
*PD_MapAndSum = *XML::Xercesc::XMLExcepts_PD_MapAndSum;
*PD_InvalidContentType = *XML::Xercesc::XMLExcepts_PD_InvalidContentType;
*NodeIDMap_GrowErr = *XML::Xercesc::XMLExcepts_NodeIDMap_GrowErr;
*F_HighBounds = *XML::Xercesc::XMLExcepts_F_HighBounds;
*E_LowBounds = *XML::Xercesc::XMLExcepts_E_LowBounds;
*E_HighBounds = *XML::Xercesc::XMLExcepts_E_HighBounds;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLException ##############

package XML::Xerces::XMLException;
use overload
    "=" => sub { $_[0]->operator_assignment($_[1])},
    "fallback" => 1;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*getType = *XML::Xercesc::XMLException_getType;
*getCode = *XML::Xercesc::XMLException_getCode;
*getMessage = *XML::Xercesc::XMLException_getMessage;
*getSrcFile = *XML::Xercesc::XMLException_getSrcFile;
*getSrcLine = *XML::Xercesc::XMLException_getSrcLine;
*getErrorType = *XML::Xercesc::XMLException_getErrorType;
*setPosition = *XML::Xercesc::XMLException_setPosition;
*operator_assignment = *XML::Xercesc::XMLException_operator_assignment;
*reinitMsgMutex = *XML::Xercesc::XMLException_reinitMsgMutex;
*reinitMsgLoader = *XML::Xercesc::XMLException_reinitMsgLoader;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLValidator ##############

package XML::Xerces::XMLValidator;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*checkContent = *XML::Xercesc::XMLValidator_checkContent;
*faultInAttr = *XML::Xercesc::XMLValidator_faultInAttr;
*preContentValidation = *XML::Xercesc::XMLValidator_preContentValidation;
*postParseValidation = *XML::Xercesc::XMLValidator_postParseValidation;
*reset = *XML::Xercesc::XMLValidator_reset;
*requiresNamespaces = *XML::Xercesc::XMLValidator_requiresNamespaces;
*validateAttrValue = *XML::Xercesc::XMLValidator_validateAttrValue;
*validateElement = *XML::Xercesc::XMLValidator_validateElement;
sub getGrammar {
    my @args = @_;
    my $result = XML::Xercesc::XMLValidator_getGrammar(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*setGrammar = *XML::Xercesc::XMLValidator_setGrammar;
*handlesDTD = *XML::Xercesc::XMLValidator_handlesDTD;
*handlesSchema = *XML::Xercesc::XMLValidator_handlesSchema;
*setScannerInfo = *XML::Xercesc::XMLValidator_setScannerInfo;
*setErrorReporter = *XML::Xercesc::XMLValidator_setErrorReporter;
*emitError = *XML::Xercesc::XMLValidator_emitError;
*checkRootElement = *XML::Xercesc::XMLValidator_checkRootElement;
*reinitMsgMutex = *XML::Xercesc::XMLValidator_reinitMsgMutex;
*reinitMsgLoader = *XML::Xercesc::XMLValidator_reinitMsgLoader;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::SAXException ##############

package XML::Xerces::SAXException;
use overload
    "=" => sub { $_[0]->operator_assignment($_[1])},
    "fallback" => 1;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_SAXException(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::SAXException";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::SAXException", $self;
    return bless \%retval, $pkg;
}


sub operator_assignment {
    my @args = @_;
    my $result = XML::Xercesc::SAXException_operator_assignment(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getMessage = *XML::Xercesc::SAXException_getMessage;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::SAXNotSupportedException ##############

package XML::Xerces::SAXNotSupportedException;
@ISA = qw( XML::Xerces XML::Xerces::SAXException );
%OWNER = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_SAXNotSupportedException(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::SAXNotSupportedException";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::SAXNotSupportedException", $self;
    return bless \%retval, $pkg;
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::SAXNotRecognizedException ##############

package XML::Xerces::SAXNotRecognizedException;
@ISA = qw( XML::Xerces XML::Xerces::SAXException );
%OWNER = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_SAXNotRecognizedException(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::SAXNotRecognizedException";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::SAXNotRecognizedException", $self;
    return bless \%retval, $pkg;
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::SAXParseException ##############

package XML::Xerces::SAXParseException;
use overload
    "=" => sub { $_[0]->operator_assignment($_[1])},
    "fallback" => 1;
@ISA = qw( XML::Xerces XML::Xerces::SAXException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_SAXParseException(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::SAXParseException";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::SAXParseException", $self;
    return bless \%retval, $pkg;
}


sub operator_assignment {
    my @args = @_;
    my $result = XML::Xercesc::SAXParseException_operator_assignment(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getColumnNumber = *XML::Xercesc::SAXParseException_getColumnNumber;
*getLineNumber = *XML::Xercesc::SAXParseException_getLineNumber;
*getPublicId = *XML::Xercesc::SAXParseException_getPublicId;
*getSystemId = *XML::Xercesc::SAXParseException_getSystemId;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::ErrorHandler ##############

package XML::Xerces::ErrorHandler;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*warning = *XML::Xercesc::ErrorHandler_warning;
*error = *XML::Xercesc::ErrorHandler_error;
*fatalError = *XML::Xercesc::ErrorHandler_fatalError;
*resetErrors = *XML::Xercesc::ErrorHandler_resetErrors;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DTDHandler ##############

package XML::Xerces::DTDHandler;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*notationDecl = *XML::Xercesc::DTDHandler_notationDecl;
*unparsedEntityDecl = *XML::Xercesc::DTDHandler_unparsedEntityDecl;
*resetDocType = *XML::Xercesc::DTDHandler_resetDocType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DocumentHandler ##############

package XML::Xerces::DocumentHandler;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*characters = *XML::Xercesc::DocumentHandler_characters;
*endDocument = *XML::Xercesc::DocumentHandler_endDocument;
*endElement = *XML::Xercesc::DocumentHandler_endElement;
*ignorableWhitespace = *XML::Xercesc::DocumentHandler_ignorableWhitespace;
*processingInstruction = *XML::Xercesc::DocumentHandler_processingInstruction;
*resetDocument = *XML::Xercesc::DocumentHandler_resetDocument;
*setDocumentLocator = *XML::Xercesc::DocumentHandler_setDocumentLocator;
*startDocument = *XML::Xercesc::DocumentHandler_startDocument;
*startElement = *XML::Xercesc::DocumentHandler_startElement;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::EntityResolver ##############

package XML::Xerces::EntityResolver;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

sub resolveEntity {
    my @args = @_;
    my $result = XML::Xercesc::EntityResolver_resolveEntity(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::AttributeList ##############

package XML::Xerces::AttributeList;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*getLength = *XML::Xercesc::AttributeList_getLength;
*getName = *XML::Xercesc::AttributeList_getName;
sub getType {
    my @args = @_;
    if ($args[1] =~ /^\d+$/) {
      return XML::Xercesc::AttributeList_getType__overload__index(@args);
    } else {
      return XML::Xercesc::AttributeList_getType(@args);
    }
}
sub getValue {
    my @args = @_;
    if ($args[1] =~ /^\d+$/) {
      return XML::Xercesc::AttributeList_getValue__overload__index(@args);
    } else {
      return XML::Xercesc::AttributeList_getValue(@args);
    }
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::HandlerBase ##############

package XML::Xerces::HandlerBase;
@ISA = qw( XML::Xerces XML::Xerces::EntityResolver XML::Xerces::DTDHandler XML::Xerces::DocumentHandler XML::Xerces::ErrorHandler );
%OWNER = ();
*characters = *XML::Xercesc::HandlerBase_characters;
*endDocument = *XML::Xercesc::HandlerBase_endDocument;
*endElement = *XML::Xercesc::HandlerBase_endElement;
*ignorableWhitespace = *XML::Xercesc::HandlerBase_ignorableWhitespace;
*processingInstruction = *XML::Xercesc::HandlerBase_processingInstruction;
*resetDocument = *XML::Xercesc::HandlerBase_resetDocument;
*setDocumentLocator = *XML::Xercesc::HandlerBase_setDocumentLocator;
*startDocument = *XML::Xercesc::HandlerBase_startDocument;
*startElement = *XML::Xercesc::HandlerBase_startElement;
sub resolveEntity {
    my @args = @_;
    my $result = XML::Xercesc::HandlerBase_resolveEntity(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*error = *XML::Xercesc::HandlerBase_error;
*fatalError = *XML::Xercesc::HandlerBase_fatalError;
*warning = *XML::Xercesc::HandlerBase_warning;
*resetErrors = *XML::Xercesc::HandlerBase_resetErrors;
*notationDecl = *XML::Xercesc::HandlerBase_notationDecl;
*resetDocType = *XML::Xercesc::HandlerBase_resetDocType;
*unparsedEntityDecl = *XML::Xercesc::HandlerBase_unparsedEntityDecl;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::Locator ##############

package XML::Xerces::Locator;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*getPublicId = *XML::Xercesc::Locator_getPublicId;
*getSystemId = *XML::Xercesc::Locator_getSystemId;
*getLineNumber = *XML::Xercesc::Locator_getLineNumber;
*getColumnNumber = *XML::Xercesc::Locator_getColumnNumber;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::Attributes ##############

package XML::Xerces::Attributes;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*getLength = *XML::Xercesc::Attributes_getLength;
*getURI = *XML::Xercesc::Attributes_getURI;
*getLocalName = *XML::Xercesc::Attributes_getLocalName;
*getQName = *XML::Xercesc::Attributes_getQName;
sub getIndex {
    my @args = @_;
    if (scalar @args == 2) {
      return XML::Xercesc::Attributes_getIndex__overload__qname(@args);
    } else {
      return XML::Xercesc::Attributes_getIndex(@args);
    }
}
sub getType {
    my @args = @_;
    if (scalar @args == 2) {
      if ($args[1] =~ /^\d+$/) {
        return XML::Xercesc::Attributes_getType__overload__index(@args);
      } else {
        return XML::Xercesc::Attributes_getType__overload__qname(@args);
      }
    } else {
      return XML::Xercesc::Attributes_getType(@args);
    }
}
sub getValue {
    my @args = @_;
    if (scalar @args == 2) {
      if ($args[1] =~ /^\d+$/) {
        return XML::Xercesc::Attributes_getValue__overload__index(@args);
      } else {
        return XML::Xercesc::Attributes_getValue__overload__qname(@args);
      }
    } else {
      return XML::Xercesc::Attributes_getValue(@args);
    }
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::ContentHandler ##############

package XML::Xerces::ContentHandler;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*characters = *XML::Xercesc::ContentHandler_characters;
*endDocument = *XML::Xercesc::ContentHandler_endDocument;
*endElement = *XML::Xercesc::ContentHandler_endElement;
*ignorableWhitespace = *XML::Xercesc::ContentHandler_ignorableWhitespace;
*processingInstruction = *XML::Xercesc::ContentHandler_processingInstruction;
*setDocumentLocator = *XML::Xercesc::ContentHandler_setDocumentLocator;
*startDocument = *XML::Xercesc::ContentHandler_startDocument;
*startElement = *XML::Xercesc::ContentHandler_startElement;
*startPrefixMapping = *XML::Xercesc::ContentHandler_startPrefixMapping;
*endPrefixMapping = *XML::Xercesc::ContentHandler_endPrefixMapping;
*skippedEntity = *XML::Xercesc::ContentHandler_skippedEntity;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::LexicalHandler ##############

package XML::Xerces::LexicalHandler;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*comment = *XML::Xercesc::LexicalHandler_comment;
*endCDATA = *XML::Xercesc::LexicalHandler_endCDATA;
*endDTD = *XML::Xercesc::LexicalHandler_endDTD;
*endEntity = *XML::Xercesc::LexicalHandler_endEntity;
*startCDATA = *XML::Xercesc::LexicalHandler_startCDATA;
*startDTD = *XML::Xercesc::LexicalHandler_startDTD;
*startEntity = *XML::Xercesc::LexicalHandler_startEntity;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DefaultHandler ##############

package XML::Xerces::DefaultHandler;
@ISA = qw( XML::Xerces XML::Xerces::EntityResolver XML::Xerces::DTDHandler XML::Xerces::ContentHandler XML::Xerces::ErrorHandler XML::Xerces::LexicalHandler );
%OWNER = ();
*characters = *XML::Xercesc::DefaultHandler_characters;
*endDocument = *XML::Xercesc::DefaultHandler_endDocument;
*endElement = *XML::Xercesc::DefaultHandler_endElement;
*ignorableWhitespace = *XML::Xercesc::DefaultHandler_ignorableWhitespace;
*processingInstruction = *XML::Xercesc::DefaultHandler_processingInstruction;
*resetDocument = *XML::Xercesc::DefaultHandler_resetDocument;
*setDocumentLocator = *XML::Xercesc::DefaultHandler_setDocumentLocator;
*startDocument = *XML::Xercesc::DefaultHandler_startDocument;
*startElement = *XML::Xercesc::DefaultHandler_startElement;
*startPrefixMapping = *XML::Xercesc::DefaultHandler_startPrefixMapping;
*endPrefixMapping = *XML::Xercesc::DefaultHandler_endPrefixMapping;
*skippedEntity = *XML::Xercesc::DefaultHandler_skippedEntity;
sub resolveEntity {
    my @args = @_;
    my $result = XML::Xercesc::DefaultHandler_resolveEntity(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*error = *XML::Xercesc::DefaultHandler_error;
*fatalError = *XML::Xercesc::DefaultHandler_fatalError;
*warning = *XML::Xercesc::DefaultHandler_warning;
*resetErrors = *XML::Xercesc::DefaultHandler_resetErrors;
*notationDecl = *XML::Xercesc::DefaultHandler_notationDecl;
*resetDocType = *XML::Xercesc::DefaultHandler_resetDocType;
*unparsedEntityDecl = *XML::Xercesc::DefaultHandler_unparsedEntityDecl;
*comment = *XML::Xercesc::DefaultHandler_comment;
*endCDATA = *XML::Xercesc::DefaultHandler_endCDATA;
*endDTD = *XML::Xercesc::DefaultHandler_endDTD;
*endEntity = *XML::Xercesc::DefaultHandler_endEntity;
*startCDATA = *XML::Xercesc::DefaultHandler_startCDATA;
*startDTD = *XML::Xercesc::DefaultHandler_startDTD;
*startEntity = *XML::Xercesc::DefaultHandler_startEntity;
*elementDecl = *XML::Xercesc::DefaultHandler_elementDecl;
*attributeDecl = *XML::Xercesc::DefaultHandler_attributeDecl;
*internalEntityDecl = *XML::Xercesc::DefaultHandler_internalEntityDecl;
*externalEntityDecl = *XML::Xercesc::DefaultHandler_externalEntityDecl;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLReaderFactory ##############

package XML::Xerces::XMLReaderFactory;
@ISA = qw( XML::Xerces );
%OWNER = ();
*createXMLReader = *XML::Xercesc::XMLReaderFactory_createXMLReader;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::PerlErrorCallbackHandler ##############

package XML::Xerces::PerlErrorCallbackHandler;
@ISA = qw( XML::Xerces XML::Xerces::ErrorHandler );
%OWNER = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_PerlErrorCallbackHandler(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::PerlErrorCallbackHandler";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::PerlErrorCallbackHandler", $self;
    return bless \%retval, $pkg;
}

*set_callback_obj = *XML::Xercesc::PerlErrorCallbackHandler_set_callback_obj;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::PerlDocumentCallbackHandler ##############

package XML::Xerces::PerlDocumentCallbackHandler;
@ISA = qw( XML::Xerces XML::Xerces::DocumentHandler );
%OWNER = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_PerlDocumentCallbackHandler(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::PerlDocumentCallbackHandler";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::PerlDocumentCallbackHandler", $self;
    return bless \%retval, $pkg;
}

*set_callback_obj = *XML::Xercesc::PerlDocumentCallbackHandler_set_callback_obj;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::PerlContentCallbackHandler ##############

package XML::Xerces::PerlContentCallbackHandler;
@ISA = qw( XML::Xerces XML::Xerces::ContentHandler );
%OWNER = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_PerlContentCallbackHandler(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::PerlContentCallbackHandler";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::PerlContentCallbackHandler", $self;
    return bless \%retval, $pkg;
}

*set_callback_obj = *XML::Xercesc::PerlContentCallbackHandler_set_callback_obj;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::PerlEntityResolverHandler ##############

package XML::Xerces::PerlEntityResolverHandler;
@ISA = qw( XML::Xerces XML::Xerces::EntityResolver );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_PerlEntityResolverHandler(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::PerlEntityResolverHandler";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::PerlEntityResolverHandler", $self;
    return bless \%retval, $pkg;
}


*set_callback_obj = *XML::Xercesc::PerlEntityResolverHandler_set_callback_obj;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Node ##############

package XML::Xerces::DOM_Node;
use overload
    "==" => sub { $_[0]->operator_equal_to($_[1])},
    "!=" => sub { $_[0]->operator_not_equal_to($_[1])},
    "fallback" => 1;
*operator_not_equal_to = *XML::Xercesc::DOM_Node_operator_not_equal_to;
*operator_equal_to = *XML::Xercesc::DOM_Node_operator_equal_to;

@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

*ELEMENT_NODE = *XML::Xercesc::DOM_Node_ELEMENT_NODE;
*ATTRIBUTE_NODE = *XML::Xercesc::DOM_Node_ATTRIBUTE_NODE;
*TEXT_NODE = *XML::Xercesc::DOM_Node_TEXT_NODE;
*CDATA_SECTION_NODE = *XML::Xercesc::DOM_Node_CDATA_SECTION_NODE;
*ENTITY_REFERENCE_NODE = *XML::Xercesc::DOM_Node_ENTITY_REFERENCE_NODE;
*ENTITY_NODE = *XML::Xercesc::DOM_Node_ENTITY_NODE;
*PROCESSING_INSTRUCTION_NODE = *XML::Xercesc::DOM_Node_PROCESSING_INSTRUCTION_NODE;
*COMMENT_NODE = *XML::Xercesc::DOM_Node_COMMENT_NODE;
*DOCUMENT_NODE = *XML::Xercesc::DOM_Node_DOCUMENT_NODE;
*DOCUMENT_TYPE_NODE = *XML::Xercesc::DOM_Node_DOCUMENT_TYPE_NODE;
*DOCUMENT_FRAGMENT_NODE = *XML::Xercesc::DOM_Node_DOCUMENT_FRAGMENT_NODE;
*NOTATION_NODE = *XML::Xercesc::DOM_Node_NOTATION_NODE;
*XML_DECL_NODE = *XML::Xercesc::DOM_Node_XML_DECL_NODE;
*getNodeName = *XML::Xercesc::DOM_Node_getNodeName;
*getNodeValue = *XML::Xercesc::DOM_Node_getNodeValue;
*getNodeType = *XML::Xercesc::DOM_Node_getNodeType;
sub getParentNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getParentNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getChildNodes {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getChildNodes(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_list() if wantarray;
    $DOM_NodeList::OWNER{$result} = 1; 

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getFirstChild {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getFirstChild(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getLastChild {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getLastChild(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getPreviousSibling {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getPreviousSibling(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNextSibling {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getNextSibling(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getAttributes {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getAttributes(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_hash() if wantarray;
    $DOM_NamedNodeMap::OWNER{$result} = 1;

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getOwnerDocument {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_getOwnerDocument(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub cloneNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_cloneNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub insertBefore {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_insertBefore(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub replaceChild {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_replaceChild(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub removeChild {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_removeChild(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub appendChild {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Node_appendChild(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*hasChildNodes = *XML::Xercesc::DOM_Node_hasChildNodes;
*setNodeValue = *XML::Xercesc::DOM_Node_setNodeValue;
*normalize = *XML::Xercesc::DOM_Node_normalize;
*isSupported = *XML::Xercesc::DOM_Node_isSupported;
*getNamespaceURI = *XML::Xercesc::DOM_Node_getNamespaceURI;
*getLocalName = *XML::Xercesc::DOM_Node_getLocalName;
*setPrefix = *XML::Xercesc::DOM_Node_setPrefix;
*hasAttributes = *XML::Xercesc::DOM_Node_hasAttributes;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Attr ##############

package XML::Xerces::DOM_Attr;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

*getName = *XML::Xercesc::DOM_Attr_getName;
*getSpecified = *XML::Xercesc::DOM_Attr_getSpecified;
*getValue = *XML::Xercesc::DOM_Attr_getValue;
*setValue = *XML::Xercesc::DOM_Attr_setValue;
sub getOwnerElement {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Attr_getOwnerElement(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_CharacterData ##############

package XML::Xerces::DOM_CharacterData;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

*getData = *XML::Xercesc::DOM_CharacterData_getData;
*getLength = *XML::Xercesc::DOM_CharacterData_getLength;
*substringData = *XML::Xercesc::DOM_CharacterData_substringData;
*appendData = *XML::Xercesc::DOM_CharacterData_appendData;
*insertData = *XML::Xercesc::DOM_CharacterData_insertData;
*deleteData = *XML::Xercesc::DOM_CharacterData_deleteData;
*replaceData = *XML::Xercesc::DOM_CharacterData_replaceData;
*setData = *XML::Xercesc::DOM_CharacterData_setData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Text ##############

package XML::Xerces::DOM_Text;
@ISA = qw( XML::Xerces XML::Xerces::DOM_CharacterData );
%OWNER = ();
%ITERATORS = ();

sub splitText {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Text_splitText(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*isIgnorableWhitespace = *XML::Xercesc::DOM_Text_isIgnorableWhitespace;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_CDATASection ##############

package XML::Xerces::DOM_CDATASection;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Text );
%OWNER = ();
%ITERATORS = ();

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Comment ##############

package XML::Xerces::DOM_Comment;
@ISA = qw( XML::Xerces XML::Xerces::DOM_CharacterData );
%OWNER = ();
%ITERATORS = ();

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Document ##############

package XML::Xerces::DOM_Document;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

sub createEntity {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createEntity(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createElement {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createElement(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createDocumentFragment {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createDocumentFragment(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createTextNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createTextNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createComment {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createComment(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createCDATASection {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createCDATASection(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createDocumentType {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createDocumentType(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createNotation {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createNotation(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createProcessingInstruction {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createProcessingInstruction(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createAttribute {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createAttribute(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createEntityReference {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createEntityReference(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createNodeIterator {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createNodeIterator(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createTreeWalker {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createTreeWalker(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createRange {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createRange(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getDoctype {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_getDoctype(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getImplementation {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_getImplementation(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getDocumentElement {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_getDocumentElement(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getElementsByTagName {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_getElementsByTagName(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_list() if wantarray;
    $DOM_NodeList::OWNER{$result} = 1; 

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub importNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_importNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createElementNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createElementNS(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createAttributeNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_createAttributeNS(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getElementsByTagNameNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_getElementsByTagNameNS(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_list() if wantarray;
    $DOM_NodeList::OWNER{$result} = 1; 

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getElementById {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Document_getElementById(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_DocumentFragment ##############

package XML::Xerces::DOM_DocumentFragment;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_DocumentType ##############

package XML::Xerces::DOM_DocumentType;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

*getName = *XML::Xercesc::DOM_DocumentType_getName;
sub getEntities {
    my @args = @_;
    my $result = XML::Xercesc::DOM_DocumentType_getEntities(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_hash() if wantarray;
    $DOM_NamedNodeMap::OWNER{$result} = 1;

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNotations {
    my @args = @_;
    my $result = XML::Xercesc::DOM_DocumentType_getNotations(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_hash() if wantarray;
    $DOM_NamedNodeMap::OWNER{$result} = 1;

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getPublicId = *XML::Xercesc::DOM_DocumentType_getPublicId;
*getSystemId = *XML::Xercesc::DOM_DocumentType_getSystemId;
*getInternalSubset = *XML::Xercesc::DOM_DocumentType_getInternalSubset;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_DOMException ##############

package XML::Xerces::DOM_DOMException;
@ISA = qw( XML::Xerces );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*INDEX_SIZE_ERR = *XML::Xercesc::DOM_DOMException_INDEX_SIZE_ERR;
*DOMSTRING_SIZE_ERR = *XML::Xercesc::DOM_DOMException_DOMSTRING_SIZE_ERR;
*HIERARCHY_REQUEST_ERR = *XML::Xercesc::DOM_DOMException_HIERARCHY_REQUEST_ERR;
*WRONG_DOCUMENT_ERR = *XML::Xercesc::DOM_DOMException_WRONG_DOCUMENT_ERR;
*INVALID_CHARACTER_ERR = *XML::Xercesc::DOM_DOMException_INVALID_CHARACTER_ERR;
*NO_DATA_ALLOWED_ERR = *XML::Xercesc::DOM_DOMException_NO_DATA_ALLOWED_ERR;
*NO_MODIFICATION_ALLOWED_ERR = *XML::Xercesc::DOM_DOMException_NO_MODIFICATION_ALLOWED_ERR;
*NOT_FOUND_ERR = *XML::Xercesc::DOM_DOMException_NOT_FOUND_ERR;
*NOT_SUPPORTED_ERR = *XML::Xercesc::DOM_DOMException_NOT_SUPPORTED_ERR;
*INUSE_ATTRIBUTE_ERR = *XML::Xercesc::DOM_DOMException_INUSE_ATTRIBUTE_ERR;
*INVALID_STATE_ERR = *XML::Xercesc::DOM_DOMException_INVALID_STATE_ERR;
*SYNTAX_ERR = *XML::Xercesc::DOM_DOMException_SYNTAX_ERR;
*INVALID_MODIFICATION_ERR = *XML::Xercesc::DOM_DOMException_INVALID_MODIFICATION_ERR;
*NAMESPACE_ERR = *XML::Xercesc::DOM_DOMException_NAMESPACE_ERR;
*INVALID_ACCESS_ERR = *XML::Xercesc::DOM_DOMException_INVALID_ACCESS_ERR;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_DOM_DOMException(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::DOM_DOMException";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::DOM_DOMException", $self;
    return bless \%retval, $pkg;
}


*swig_code_get = *XML::Xercesc::DOM_DOMException_code_get;
*swig_code_set = *XML::Xercesc::DOM_DOMException_code_set;
*swig_msg_get = *XML::Xercesc::DOM_DOMException_msg_get;
*swig_msg_set = *XML::Xercesc::DOM_DOMException_msg_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : XML::Xerces::DOM_DOMImplementation ##############

package XML::Xerces::DOM_DOMImplementation;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
*getImplementation = *XML::Xercesc::DOM_DOMImplementation_getImplementation;

*hasFeature = *XML::Xercesc::DOM_DOMImplementation_hasFeature;
sub createDocumentType {
    my @args = @_;
    my $result = XML::Xercesc::DOM_DOMImplementation_createDocumentType(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub createDocument {
    my @args = @_;
    my $result = XML::Xercesc::DOM_DOMImplementation_createDocument(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Element ##############

package XML::Xerces::DOM_Element;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

*getTagName = *XML::Xercesc::DOM_Element_getTagName;
*getAttribute = *XML::Xercesc::DOM_Element_getAttribute;
sub getAttributeNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Element_getAttributeNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getElementsByTagName {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Element_getElementsByTagName(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_list() if wantarray;
    $DOM_NodeList::OWNER{$result} = 1; 

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub setAttribute {
    my ($self,$attr,$val) = @_;
    return unless defined $attr and defined $val;
    my $result = XML::Xercesc::DOM_Element_setAttribute(@_);
    return $result unless ref($result) =~ m[XML::Xerces];
    $XML::Xerces::DOM_Attr::OWNER{$result} = 1; 
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub setAttributeNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Element_setAttributeNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub removeAttributeNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Element_removeAttributeNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*removeAttribute = *XML::Xercesc::DOM_Element_removeAttribute;
*getAttributeNS = *XML::Xercesc::DOM_Element_getAttributeNS;
*setAttributeNS = *XML::Xercesc::DOM_Element_setAttributeNS;
*removeAttributeNS = *XML::Xercesc::DOM_Element_removeAttributeNS;
sub getAttributeNodeNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Element_getAttributeNodeNS(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub setAttributeNodeNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Element_setAttributeNodeNS(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getElementsByTagNameNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Element_getElementsByTagNameNS(@args);
    unless (defined $result) {
      return () if wantarray;
      return undef; # if *not* wantarray
    }
    return $result->to_list() if wantarray;
    $DOM_NodeList::OWNER{$result} = 1; 

    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*hasAttribute = *XML::Xercesc::DOM_Element_hasAttribute;
*hasAttributeNS = *XML::Xercesc::DOM_Element_hasAttributeNS;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Entity ##############

package XML::Xerces::DOM_Entity;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

*getPublicId = *XML::Xercesc::DOM_Entity_getPublicId;
*getSystemId = *XML::Xercesc::DOM_Entity_getSystemId;
*getNotationName = *XML::Xercesc::DOM_Entity_getNotationName;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_EntityReference ##############

package XML::Xerces::DOM_EntityReference;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_NamedNodeMap ##############

package XML::Xerces::DOM_NamedNodeMap;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

sub setNamedItem {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NamedNodeMap_setNamedItem(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub item {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NamedNodeMap_item(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNamedItem {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NamedNodeMap_getNamedItem(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getLength = *XML::Xercesc::DOM_NamedNodeMap_getLength;
sub removeNamedItem {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NamedNodeMap_removeNamedItem(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getNamedItemNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NamedNodeMap_getNamedItemNS(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub setNamedItemNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NamedNodeMap_setNamedItemNS(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub removeNamedItemNS {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NamedNodeMap_removeNamedItemNS(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_NodeFilter ##############

package XML::Xerces::DOM_NodeFilter;
@ISA = qw( XML::Xerces );
%OWNER = ();
*FILTER_ACCEPT = *XML::Xercesc::DOM_NodeFilter_FILTER_ACCEPT;
*FILTER_REJECT = *XML::Xercesc::DOM_NodeFilter_FILTER_REJECT;
*FILTER_SKIP = *XML::Xercesc::DOM_NodeFilter_FILTER_SKIP;
*SHOW_ALL = *XML::Xercesc::DOM_NodeFilter_SHOW_ALL;
*SHOW_ELEMENT = *XML::Xercesc::DOM_NodeFilter_SHOW_ELEMENT;
*SHOW_ATTRIBUTE = *XML::Xercesc::DOM_NodeFilter_SHOW_ATTRIBUTE;
*SHOW_TEXT = *XML::Xercesc::DOM_NodeFilter_SHOW_TEXT;
*SHOW_CDATA_SECTION = *XML::Xercesc::DOM_NodeFilter_SHOW_CDATA_SECTION;
*SHOW_ENTITY_REFERENCE = *XML::Xercesc::DOM_NodeFilter_SHOW_ENTITY_REFERENCE;
*SHOW_ENTITY = *XML::Xercesc::DOM_NodeFilter_SHOW_ENTITY;
*SHOW_PROCESSING_INSTRUCTION = *XML::Xercesc::DOM_NodeFilter_SHOW_PROCESSING_INSTRUCTION;
*SHOW_COMMENT = *XML::Xercesc::DOM_NodeFilter_SHOW_COMMENT;
*SHOW_DOCUMENT = *XML::Xercesc::DOM_NodeFilter_SHOW_DOCUMENT;
*SHOW_DOCUMENT_TYPE = *XML::Xercesc::DOM_NodeFilter_SHOW_DOCUMENT_TYPE;
*SHOW_DOCUMENT_FRAGMENT = *XML::Xercesc::DOM_NodeFilter_SHOW_DOCUMENT_FRAGMENT;
*SHOW_NOTATION = *XML::Xercesc::DOM_NodeFilter_SHOW_NOTATION;
*acceptNode = *XML::Xercesc::DOM_NodeFilter_acceptNode;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_NodeIterator ##############

package XML::Xerces::DOM_NodeIterator;
@ISA = qw( XML::Xerces );
%OWNER = ();
sub getRoot {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NodeIterator_getRoot(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getWhatToShow = *XML::Xercesc::DOM_NodeIterator_getWhatToShow;
sub getFilter {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NodeIterator_getFilter(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getExpandEntityReferences = *XML::Xercesc::DOM_NodeIterator_getExpandEntityReferences;
sub nextNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NodeIterator_nextNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub previousNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NodeIterator_previousNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*detach = *XML::Xercesc::DOM_NodeIterator_detach;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_NodeList ##############

package XML::Xerces::DOM_NodeList;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

sub item {
    my @args = @_;
    my $result = XML::Xercesc::DOM_NodeList_item(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getLength = *XML::Xercesc::DOM_NodeList_getLength;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Notation ##############

package XML::Xerces::DOM_Notation;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

*getPublicId = *XML::Xercesc::DOM_Notation_getPublicId;
*getSystemId = *XML::Xercesc::DOM_Notation_getSystemId;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_ProcessingInstruction ##############

package XML::Xerces::DOM_ProcessingInstruction;
@ISA = qw( XML::Xerces XML::Xerces::DOM_Node );
%OWNER = ();
%ITERATORS = ();

*getTarget = *XML::Xercesc::DOM_ProcessingInstruction_getTarget;
*getData = *XML::Xercesc::DOM_ProcessingInstruction_getData;
*setData = *XML::Xercesc::DOM_ProcessingInstruction_setData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_Range ##############

package XML::Xerces::DOM_Range;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
*START_TO_START = *XML::Xercesc::DOM_Range_START_TO_START;
*START_TO_END = *XML::Xercesc::DOM_Range_START_TO_END;
*END_TO_END = *XML::Xercesc::DOM_Range_END_TO_END;
*END_TO_START = *XML::Xercesc::DOM_Range_END_TO_START;

sub getStartContainer {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Range_getStartContainer(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getStartOffset = *XML::Xercesc::DOM_Range_getStartOffset;
sub getEndContainer {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Range_getEndContainer(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getEndOffset = *XML::Xercesc::DOM_Range_getEndOffset;
*getCollapsed = *XML::Xercesc::DOM_Range_getCollapsed;
sub getCommonAncestorContainer {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Range_getCommonAncestorContainer(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*setStart = *XML::Xercesc::DOM_Range_setStart;
*setEnd = *XML::Xercesc::DOM_Range_setEnd;
*setStartBefore = *XML::Xercesc::DOM_Range_setStartBefore;
*setStartAfter = *XML::Xercesc::DOM_Range_setStartAfter;
*setEndBefore = *XML::Xercesc::DOM_Range_setEndBefore;
*setEndAfter = *XML::Xercesc::DOM_Range_setEndAfter;
*collapse = *XML::Xercesc::DOM_Range_collapse;
*selectNode = *XML::Xercesc::DOM_Range_selectNode;
*selectNodeContents = *XML::Xercesc::DOM_Range_selectNodeContents;
*compareBoundaryPoints = *XML::Xercesc::DOM_Range_compareBoundaryPoints;
*deleteContents = *XML::Xercesc::DOM_Range_deleteContents;
sub extractContents {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Range_extractContents(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub cloneContents {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Range_cloneContents(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*insertNode = *XML::Xercesc::DOM_Range_insertNode;
*surroundContents = *XML::Xercesc::DOM_Range_surroundContents;
sub cloneRange {
    my @args = @_;
    my $result = XML::Xercesc::DOM_Range_cloneRange(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*toString = *XML::Xercesc::DOM_Range_toString;
*detach = *XML::Xercesc::DOM_Range_detach;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOM_RangeException ##############

package XML::Xerces::DOM_RangeException;
@ISA = qw( XML::Xerces XML::Xerces::DOM_DOMException );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
*BAD_BOUNDARYPOINTS_ERR = *XML::Xercesc::DOM_RangeException_BAD_BOUNDARYPOINTS_ERR;
*INVALID_NODE_TYPE_ERR = *XML::Xercesc::DOM_RangeException_INVALID_NODE_TYPE_ERR;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_DOM_RangeException(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::DOM_RangeException";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::DOM_RangeException", $self;
    return bless \%retval, $pkg;
}


*swig_code_get = *XML::Xercesc::DOM_RangeException_code_get;
*swig_code_set = *XML::Xercesc::DOM_RangeException_code_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    my $val = $self->$member_func();
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        $self->$member_func(tied(%{$newval}));
    } else {
        $self->$member_func($newval);
    }
}


############# Class : XML::Xerces::DOM_TreeWalker ##############

package XML::Xerces::DOM_TreeWalker;
@ISA = qw( XML::Xerces );
%OWNER = ();
sub getRoot {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_getRoot(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getWhatToShow = *XML::Xercesc::DOM_TreeWalker_getWhatToShow;
sub getFilter {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_getFilter(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getExpandEntityReferences = *XML::Xercesc::DOM_TreeWalker_getExpandEntityReferences;
sub getCurrentNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_getCurrentNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub parentNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_parentNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub firstChild {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_firstChild(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub lastChild {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_lastChild(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub previousSibling {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_previousSibling(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub nextSibling {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_nextSibling(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub previousNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_previousNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub nextNode {
    my @args = @_;
    my $result = XML::Xercesc::DOM_TreeWalker_nextNode(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*setCurrentNode = *XML::Xercesc::DOM_TreeWalker_setCurrentNode;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::InputSource ##############

package XML::Xerces::InputSource;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();

sub makeStream {
    my @args = @_;
    my $result = XML::Xercesc::InputSource_makeStream(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getEncoding = *XML::Xercesc::InputSource_getEncoding;
*getPublicId = *XML::Xercesc::InputSource_getPublicId;
*getSystemId = *XML::Xercesc::InputSource_getSystemId;
*getIssueFatalErrorIfNotFound = *XML::Xercesc::InputSource_getIssueFatalErrorIfNotFound;
*setEncoding = *XML::Xercesc::InputSource_setEncoding;
*setPublicId = *XML::Xercesc::InputSource_setPublicId;
*setSystemId = *XML::Xercesc::InputSource_setSystemId;
*setIssueFatalErrorIfNotFound = *XML::Xercesc::InputSource_setIssueFatalErrorIfNotFound;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::MemBufInputSource ##############

package XML::Xerces::MemBufInputSource;
@ISA = qw( XML::Xerces XML::Xerces::InputSource );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    # SYSTEM ID is *optional*
    if (scalar @args == 1) {
      push(@args,'FAKE_SYSTEM_ID');
    }
    my $self = XML::Xercesc::new_MemBufInputSource(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::MemBufInputSource";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::MemBufInputSource", $self;
    return bless \%retval, $pkg;
}


sub makeStream {
    my @args = @_;
    my $result = XML::Xercesc::MemBufInputSource_makeStream(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*setCopyBufToStream = *XML::Xercesc::MemBufInputSource_setCopyBufToStream;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::StdInInputSource ##############

package XML::Xerces::StdInInputSource;
@ISA = qw( XML::Xerces XML::Xerces::InputSource );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_StdInInputSource(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::StdInInputSource";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::StdInInputSource", $self;
    return bless \%retval, $pkg;
}


sub makeStream {
    my @args = @_;
    my $result = XML::Xercesc::StdInInputSource_makeStream(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::LocalFileInputSource ##############

package XML::Xerces::LocalFileInputSource;
@ISA = qw( XML::Xerces XML::Xerces::InputSource );
%OWNER = ();
%ITERATORS = ();

sub new {
    my $pkg = shift;
    my @args = @_;
    if (scalar @args == 1) {
      $self = XML::Xercesc::new_LocalFileInputSource(@args);
    } else {
      $self = XML::Xercesc::new_LocalFileInputSource__constructor__base(@args);
    }

    return undef if (!defined($self));
    bless $self, "XML::Xerces::LocalFileInputSource";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::LocalFileInputSource", $self;
    return bless \%retval, $pkg;
}


sub makeStream {
    my @args = @_;
    my $result = XML::Xercesc::LocalFileInputSource_makeStream(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::URLInputSource ##############

package XML::Xerces::URLInputSource;
@ISA = qw( XML::Xerces XML::Xerces::InputSource );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    if (ref $args[0]) {
      $args[0] = tied(%{$args[0]});
      $self = XML::Xercesc::new_URLInputSource(@args);
    } elsif (scalar @args == 2) {
      $self = XML::Xercesc::new_URLInputSource__constructor__sys(@args);
    } else {
      $self = XML::Xercesc::new_URLInputSource__constructor__pub(@args);
    }

    return undef if (!defined($self));
    bless $self, "XML::Xerces::URLInputSource";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::URLInputSource", $self;
    return bless \%retval, $pkg;
}




sub makeStream {
    my @args = @_;
    my $result = XML::Xercesc::URLInputSource_makeStream(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub urlSrc {
    my @args = @_;
    my $result = XML::Xercesc::URLInputSource_urlSrc(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::XMLPScanToken ##############

package XML::Xerces::XMLPScanToken;
use overload
    "=" => sub { $_[0]->operator_assignment($_[1])},
    "fallback" => 1;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_XMLPScanToken(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::XMLPScanToken";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::XMLPScanToken", $self;
    return bless \%retval, $pkg;
}


sub operator_assignment {
    my @args = @_;
    my $result = XML::Xercesc::XMLPScanToken_operator_assignment(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::SAX2XMLReader ##############

package XML::Xerces::SAX2XMLReader;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
*Val_Never = *XML::Xercesc::SAX2XMLReader_Val_Never;
*Val_Always = *XML::Xercesc::SAX2XMLReader_Val_Always;
*Val_Auto = *XML::Xercesc::SAX2XMLReader_Val_Auto;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        XML::Xercesc::delete_SAX2XMLReader($self);
        delete $OWNER{$self};
    }
}

*getErrorCount = *XML::Xercesc::SAX2XMLReader_getErrorCount;
sub getContentHandler {
    my @args = @_;
    my $result = XML::Xercesc::SAX2XMLReader_getContentHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getDTDHandler {
    my @args = @_;
    my $result = XML::Xercesc::SAX2XMLReader_getDTDHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getEntityResolver {
    my @args = @_;
    my $result = XML::Xercesc::SAX2XMLReader_getEntityResolver(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getErrorHandler {
    my @args = @_;
    my $result = XML::Xercesc::SAX2XMLReader_getErrorHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getLexicalHandler {
    my @args = @_;
    my $result = XML::Xercesc::SAX2XMLReader_getLexicalHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getDeclarationHandler {
    my @args = @_;
    my $result = XML::Xercesc::SAX2XMLReader_getDeclarationHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getFeature = *XML::Xercesc::SAX2XMLReader_getFeature;
*getProperty = *XML::Xercesc::SAX2XMLReader_getProperty;
*getExitOnFirstFatalError = *XML::Xercesc::SAX2XMLReader_getExitOnFirstFatalError;
*getValidationConstraintFatal = *XML::Xercesc::SAX2XMLReader_getValidationConstraintFatal;
*parse = *XML::Xercesc::SAX2XMLReader_parse;
sub setContentHandler {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlContentCallbackHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::SAX2XMLReader_setContentHandler($self,$callback);
  # maintain an internal reference
  $self{__CONTENT_HANDLER} = $callback;
}
*setDTDHandler = *XML::Xercesc::SAX2XMLReader_setDTDHandler;
sub setEntityResolver {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlEntityResolverHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::SAX2XMLReader_setEntityResolver($self,$callback);
  $self{__ENTITY_RESOLVER} = $callback;
}
sub setErrorHandler {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlErrorCallbackHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::SAX2XMLReader_setErrorHandler($self,$callback);
  $self{__ERROR_HANDLER} = $callback;
}
*setLexicalHandler = *XML::Xercesc::SAX2XMLReader_setLexicalHandler;
*setDeclarationHandler = *XML::Xercesc::SAX2XMLReader_setDeclarationHandler;
*setExitOnFirstFatalError = *XML::Xercesc::SAX2XMLReader_setExitOnFirstFatalError;
*setValidationConstraintFatal = *XML::Xercesc::SAX2XMLReader_setValidationConstraintFatal;
*setFeature = *XML::Xercesc::SAX2XMLReader_setFeature;
*setProperty = *XML::Xercesc::SAX2XMLReader_setProperty;
*parseFirst = *XML::Xercesc::SAX2XMLReader_parseFirst;
*parseNext = *XML::Xercesc::SAX2XMLReader_parseNext;
*parseReset = *XML::Xercesc::SAX2XMLReader_parseReset;
*setValidator = *XML::Xercesc::SAX2XMLReader_setValidator;
sub getValidator {
    my @args = @_;
    my $result = XML::Xercesc::SAX2XMLReader_getValidator(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*installAdvDocHandler = *XML::Xercesc::SAX2XMLReader_installAdvDocHandler;
*removeAdvDocHandler = *XML::Xercesc::SAX2XMLReader_removeAdvDocHandler;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::SAXParser ##############

package XML::Xerces::SAXParser;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
*Val_Never = *XML::Xercesc::SAXParser_Val_Never;
*Val_Always = *XML::Xercesc::SAXParser_Val_Always;
*Val_Auto = *XML::Xercesc::SAXParser_Val_Auto;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_SAXParser(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::SAXParser";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::SAXParser", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        XML::Xercesc::delete_SAXParser($self);
        delete $OWNER{$self};
    }
}

sub getDocumentHandler {
    my @args = @_;
    my $result = XML::Xercesc::SAXParser_getDocumentHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getEntityResolver {
    my @args = @_;
    my $result = XML::Xercesc::SAXParser_getEntityResolver(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getErrorHandler {
    my @args = @_;
    my $result = XML::Xercesc::SAXParser_getErrorHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getScanner {
    my @args = @_;
    my $result = XML::Xercesc::SAXParser_getScanner(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getValidator {
    my @args = @_;
    my $result = XML::Xercesc::SAXParser_getValidator(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getValidationScheme = *XML::Xercesc::SAXParser_getValidationScheme;
*getDoSchema = *XML::Xercesc::SAXParser_getDoSchema;
*getValidationSchemaFullChecking = *XML::Xercesc::SAXParser_getValidationSchemaFullChecking;
*getErrorCount = *XML::Xercesc::SAXParser_getErrorCount;
*getDoNamespaces = *XML::Xercesc::SAXParser_getDoNamespaces;
*getExitOnFirstFatalError = *XML::Xercesc::SAXParser_getExitOnFirstFatalError;
*getValidationConstraintFatal = *XML::Xercesc::SAXParser_getValidationConstraintFatal;
*getExternalSchemaLocation = *XML::Xercesc::SAXParser_getExternalSchemaLocation;
*getExternalNoNamespaceSchemaLocation = *XML::Xercesc::SAXParser_getExternalNoNamespaceSchemaLocation;
*setDoNamespaces = *XML::Xercesc::SAXParser_setDoNamespaces;
*setValidationScheme = *XML::Xercesc::SAXParser_setValidationScheme;
*setDoSchema = *XML::Xercesc::SAXParser_setDoSchema;
*setValidationSchemaFullChecking = *XML::Xercesc::SAXParser_setValidationSchemaFullChecking;
*setExitOnFirstFatalError = *XML::Xercesc::SAXParser_setExitOnFirstFatalError;
*setValidationConstraintFatal = *XML::Xercesc::SAXParser_setValidationConstraintFatal;
*setExternalSchemaLocation = *XML::Xercesc::SAXParser_setExternalSchemaLocation;
*setExternalNoNamespaceSchemaLocation = *XML::Xercesc::SAXParser_setExternalNoNamespaceSchemaLocation;
*installAdvDocHandler = *XML::Xercesc::SAXParser_installAdvDocHandler;
*removeAdvDocHandler = *XML::Xercesc::SAXParser_removeAdvDocHandler;
sub parse {
    my @args = @_;
    if (ref $args[1]) {
      XML::Xercesc::SAXParser_parse__overload__is(@args);
    } else {
      XML::Xercesc::SAXParser_parse(@args);
    }
}
sub setDocumentHandler {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlDocumentCallbackHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::SAXParser_setDocumentHandler($self,$callback);
  $self{__DOCUMENT_HANDLER} = $callback;
}
*setDTDHandler = *XML::Xercesc::SAXParser_setDTDHandler;
sub setErrorHandler {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlErrorCallbackHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::SAXParser_setErrorHandler($self,$callback);
  $self{__ERROR_HANDLER} = $callback;
}
sub setEntityResolver {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlEntityResolverHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::SAXParser_setEntityResolver($self,$callback);
  $self{__ENTITY_RESOLVER} = $callback;
}
sub parseFirst {
    my @args = @_;
    if (ref $args[1]) {
      XML::Xercesc::SAXParser_parseFirst__overload__is(@args);
    } else {
      XML::Xercesc::SAXParser_parseFirst(@args);
    }
}
*parseNext = *XML::Xercesc::SAXParser_parseNext;
*parseReset = *XML::Xercesc::SAXParser_parseReset;
*error = *XML::Xercesc::SAXParser_error;
*resetErrors = *XML::Xercesc::SAXParser_resetErrors;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::DOMParser ##############

package XML::Xerces::DOMParser;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
*Val_Never = *XML::Xercesc::DOMParser_Val_Never;
*Val_Always = *XML::Xercesc::DOMParser_Val_Always;
*Val_Auto = *XML::Xercesc::DOMParser_Val_Auto;
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = XML::Xercesc::new_DOMParser(@args);
    return undef if (!defined($self));
    bless $self, "XML::Xerces::DOMParser";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "XML::Xerces::DOMParser", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        XML::Xercesc::delete_DOMParser($self);
        delete $OWNER{$self};
    }
}

*reset = *XML::Xercesc::DOMParser_reset;
*resetDocumentPool = *XML::Xercesc::DOMParser_resetDocumentPool;
sub getDocument {
    my @args = @_;
    my $result = XML::Xercesc::DOMParser_getDocument(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getErrorHandler {
    my @args = @_;
    my $result = XML::Xercesc::DOMParser_getErrorHandler(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getEntityResolver {
    my @args = @_;
    my $result = XML::Xercesc::DOMParser_getEntityResolver(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
sub getValidator {
    my @args = @_;
    my $result = XML::Xercesc::DOMParser_getValidator(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getValidationScheme = *XML::Xercesc::DOMParser_getValidationScheme;
*getDoSchema = *XML::Xercesc::DOMParser_getDoSchema;
*getValidationSchemaFullChecking = *XML::Xercesc::DOMParser_getValidationSchemaFullChecking;
*getErrorCount = *XML::Xercesc::DOMParser_getErrorCount;
*getDoNamespaces = *XML::Xercesc::DOMParser_getDoNamespaces;
*getExitOnFirstFatalError = *XML::Xercesc::DOMParser_getExitOnFirstFatalError;
*getValidationConstraintFatal = *XML::Xercesc::DOMParser_getValidationConstraintFatal;
*getExpandEntityReferences = *XML::Xercesc::DOMParser_getExpandEntityReferences;
*getCreateEntityReferenceNodes = *XML::Xercesc::DOMParser_getCreateEntityReferenceNodes;
*getIncludeIgnorableWhitespace = *XML::Xercesc::DOMParser_getIncludeIgnorableWhitespace;
*getExternalSchemaLocation = *XML::Xercesc::DOMParser_getExternalSchemaLocation;
*getExternalNoNamespaceSchemaLocation = *XML::Xercesc::DOMParser_getExternalNoNamespaceSchemaLocation;
sub setErrorHandler {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlErrorCallbackHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::DOMParser_setErrorHandler($self,$callback);
  $self{__ERROR_HANDLER} = $callback;
}
sub setEntityResolver {
  my ($self,$handler) = @_;
  my $callback = XML::Xerces::PerlEntityResolverHandler->new();
  $callback->set_callback_obj($handler);
  XML::Xercesc::DOMParser_setEntityResolver($self,$callback);
  $self{__ENTITY_RESOLVER} = $callback;
}
*setDoNamespaces = *XML::Xercesc::DOMParser_setDoNamespaces;
*setExitOnFirstFatalError = *XML::Xercesc::DOMParser_setExitOnFirstFatalError;
*setValidationConstraintFatal = *XML::Xercesc::DOMParser_setValidationConstraintFatal;
*setExpandEntityReferences = *XML::Xercesc::DOMParser_setExpandEntityReferences;
*setCreateEntityReferenceNodes = *XML::Xercesc::DOMParser_setCreateEntityReferenceNodes;
*setIncludeIgnorableWhitespace = *XML::Xercesc::DOMParser_setIncludeIgnorableWhitespace;
*setValidationScheme = *XML::Xercesc::DOMParser_setValidationScheme;
*setDoSchema = *XML::Xercesc::DOMParser_setDoSchema;
*setValidationSchemaFullChecking = *XML::Xercesc::DOMParser_setValidationSchemaFullChecking;
*setExternalSchemaLocation = *XML::Xercesc::DOMParser_setExternalSchemaLocation;
*setExternalNoNamespaceSchemaLocation = *XML::Xercesc::DOMParser_setExternalNoNamespaceSchemaLocation;
sub parse {
    my @args = @_;
    if (ref $args[1]) {
      XML::Xercesc::DOMParser_parse__overload__is(@args);
    } else {
      XML::Xercesc::DOMParser_parse(@args);
    }
}
sub parseFirst {
    my @args = @_;
    if (ref $args[1]) {
      XML::Xercesc::DOMParser_parseFirst__overload__is(@args);
    } else {
      XML::Xercesc::DOMParser_parseFirst(@args);
    }
}
*parseNext = *XML::Xercesc::DOMParser_parseNext;
*parseReset = *XML::Xercesc::DOMParser_parseReset;
*error = *XML::Xercesc::DOMParser_error;
*resetErrors = *XML::Xercesc::DOMParser_resetErrors;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


############# Class : XML::Xerces::Grammar ##############

package XML::Xerces::Grammar;
@ISA = qw( XML::Xerces );
%OWNER = ();
%ITERATORS = ();
*DTDGrammarType = *XML::Xercesc::Grammar_DTDGrammarType;
*SchemaGrammarType = *XML::Xercesc::Grammar_SchemaGrammarType;
*UNKNOWN_SCOPE = *XML::Xercesc::Grammar_UNKNOWN_SCOPE;
*TOP_LEVEL_SCOPE = *XML::Xercesc::Grammar_TOP_LEVEL_SCOPE;

*getGrammarType = *XML::Xercesc::Grammar_getGrammarType;
*getTargetNamespace = *XML::Xercesc::Grammar_getTargetNamespace;
sub findOrAddElemDecl {
    my @args = @_;
    my $result = XML::Xercesc::Grammar_findOrAddElemDecl(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getElemId = *XML::Xercesc::Grammar_getElemId;
sub getElemDecl {
    my @args = @_;
    my $result = XML::Xercesc::Grammar_getElemDecl(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*getNotationDecl = *XML::Xercesc::Grammar_getNotationDecl;
sub putElemDecl {
    my @args = @_;
    my $result = XML::Xercesc::Grammar_putElemDecl(@args);
    return $result unless ref($result) =~ m[XML::Xerces];
    my %resulthash;
    tie %resulthash, ref($result), $result;
    return bless \%resulthash, ref($result);
}
*putNotationDecl = *XML::Xercesc::Grammar_putNotationDecl;
*reset = *XML::Xercesc::Grammar_reset;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


# ------- VARIABLE STUBS --------

package XML::Xerces;

*DEBUG_UTF8_OUT = *XML::Xercesc::DEBUG_UTF8_OUT;
*DEBUG_UTF8_IN = *XML::Xercesc::DEBUG_UTF8_IN;
1;
############# Class : XML::Xerces::PerlContentHandler ##############
package XML::Xerces::PerlContentHandler;
@ISA = qw();
sub new {
  my $class = shift;
  return bless {}, $class;
}

sub start_element {}
sub end_element {}
sub start_prefix_mapping {}
sub end_prefix_mapping {}
sub skipped_entity {}
sub start_document {}
sub end_document {}
sub reset_document {}
sub characters {}
sub processing_instruction {}
sub set_document_locator {}
sub ignorable_whitespace {}


############# Class : XML::Xerces::PerlDocumentHandler ##############
package XML::Xerces::PerlDocumentHandler;
@ISA = qw();
sub new {
  my $class = shift;
  return bless {}, $class;
}

sub start_element {}
sub end_element {}
sub start_document {}
sub end_document {}
sub reset_document {}
sub characters {}
sub processing_instruction {}
sub set_document_locator {}
sub ignorable_whitespace {}


############# Class : XML::Xerces::PerlEntityResolver ##############
package XML::Xerces::PerlEntityResolver;
@ISA = qw();
sub new {
  my $class = shift;
  return bless {}, $class;
}

sub resolve_entity {
  return undef;
}


############# Class : XML::Xerces::PerlErrorHandler ##############
package XML::Xerces::PerlErrorHandler;
@ISA = qw();
sub new {
  my $class = shift;
  return bless {}, $class;
}

sub warning {
  my $system_id = $_[1]->getSystemId;
  my $line_num = $_[1]->getLineNumber;
  my $col_num = $_[1]->getColumnNumber;
  my $msg = $_[1]->getMessage;
  warn(<<EOT);
WARNING:
FILE:    $system_id
LINE:    $line_num
COLUMN:  $col_num
MESSAGE: $msg
EOT
}

sub error {
  my $system_id = $_[1]->getSystemId;
  my $line_num = $_[1]->getLineNumber;
  my $col_num = $_[1]->getColumnNumber;
  my $msg = $_[1]->getMessage;
  die(<<EOT);
ERROR:
FILE:    $system_id
LINE:    $line_num
COLUMN:  $col_num
MESSAGE: $msg
EOT
}

sub fatal_error {
  my $system_id = $_[1]->getSystemId;
  my $line_num = $_[1]->getLineNumber;
  my $col_num = $_[1]->getColumnNumber;
  my $msg = $_[1]->getMessage;
  die(<<EOT);
FATAL ERROR:
FILE:    $system_id
LINE:    $line_num
COLUMN:  $col_num
MESSAGE: $msg
EOT
}


sub reset_errors {}

package XML::Xerces::DOM_NodeList;
# convert the NodeList to a perl list
sub to_list {
  my $self = shift;
  my @list;
  for (my $i=0;$i<$self->getLength();$i++) {
    push(@list,$self->item($i));
  }
  return @list;
}

package XML::Xerces::Attributes;
sub to_hash {
  my $self = shift;
  my %hash;
  for (my $i=0; $i < $self->getLength(); $i++) {
    my $qname = $self->getQName($i);
    $hash{$qname}->{localName} = $self->getLocalName($i);
    $hash{$qname}->{URI} = $self->getURI($i);
    $hash{$qname}->{value} = $self->getValue($i);
    $hash{$qname}->{type} = $self->getType($i);
  }
  return %hash;
}

package XML::Xerces::DOM_Entity;
sub to_hash {
  my $self = shift;
  if ($self->hasChildNodes) {
    return ($self->getNodeName(),
            $self->getFirstChild->getNodeValue());
  } else {
    return ($self->getNodeName(), '');
  }
}

package XML::Xerces::AttributeList;
sub to_hash {
  my $self = shift;
  my %hash;
  for (my $i=0;$i<$self->getLength();$i++) {
    $hash{$self->getName($i)} = $self->getValue($i)
  }
  return %hash;
}

package XML::Xerces::DOM_NamedNodeMap;
# convert the NamedNodeMap to a perl hash
sub to_hash {
  my $self = shift;
  my @list;
  for (my $i=0;$i<$self->getLength();$i++) {
    my $node = $self->item($i);
    if ($node->getNodeType == $XML::Xerces::DOM_Node::ENTITY_NODE) {
      push(@list, $node->to_hash());
    } else {
      push(@list, $node->getNodeName());
      push(@list,$node->getNodeValue());
    }
  }
  return @list;
}

package XML::Xerces::DOM_Node;

sub quote_content {
  my ($self,$node_value) = @_;

  $node_value =~ s/&/&amp;/g;
  $node_value =~ s/</&lt;/g;
  $node_value =~ s/>/&gt;/g;
  $node_value =~ s/\"/&quot;/g;
  $node_value =~ s/\'/&apos;/g;

  return $node_value;
}

package XML::Xerces::DOM_Text;
sub serialize {
  return $_[0]->quote_content($_[0]->getNodeValue);
}

package XML::Xerces::DOM_ProcessingInstruction;
sub serialize {
  my $output .= '<?' . $_[0]->getNodeName;
  if (length(my $str = $_[0]->getNodeValue)) {
    $output .= " $str"; 
  }
  $output .= '?>';
  return $output;
}

package XML::Xerces::DOM_Document;
sub serialize {
  my $output;
  my $indent = 2;
  for(my $child = $_[0]->getFirstChild() ;
     defined $child ;
     $child = $child->getNextSibling())
  {
    $output .= $child->serialize($indent);
  }
  return "$output\n";
}

package XML::Xerces::DOM_Element;
sub serialize {
  my ($self,$indent) = @_;
  my $output;
  ELEMENT: {
    my $node_name = $self->getNodeName;
    $output .= "<$node_name";

    my $attributes = $self->getAttributes;
    my $attribute_count = $attributes->getLength;

    for(my $ix = 0 ; $ix < $attribute_count ; ++$ix) {
      $attribute = $attributes->item($ix);
      $output .= ' ' . $attribute->getNodeName . '="' . $self->quote_content($attribute->getNodeValue) . '"';
    }

    my $child = $self->getFirstChild();
    if (!defined $child) {
      $output .= '/>';
      last ELEMENT;
    }

    $output .= '>';
    while (defined $child) {
      $output .= $child->serialize($indent+2);
      $child = $child->getNextSibling();
    }
    $output .= "</$node_name>";
  }
  return $output;
}

package XML::Xerces::DOM_EntityReference;
sub serialize {
  my ($self) = @_;
  my $output;
  for(my $child = $self->getFirstChild() ;
     defined $child;
     $child = $child->getNextSibling())
  {
    $output .= $child->serialize();
  }
  return $output;
}

package XML::Xerces::DOM_CDATASection;
sub serialize {
  return '<![CDATA[' . $_[0]->getNodeValue . ']]>';
}

package XML::Xerces::DOM_Comment;
sub serialize {
  return '<!--' . $_[0]->getNodeValue . "-->\n";
}

package XML::Xerces::DOM_DocumentType;
sub serialize {
  my $output;
  $output .= '<!DOCTYPE ' . $_[0]->getNodeName;

  my $id;
  if ($id = $_[0]->getPublicId) {
    $output .= qq[ PUBLIC "$id"];
    if ($id = $_[0]->getSystemId) {
      $output .= qq[ "$id"];
    }
  } elsif ($id = $_[0]->getSystemId) {
    $output .= qq[ SYSTEM "$id"];
  }

  if ($id = $_[0]->getInternalSubset) {
    $output .= " [$id]";
  }

  $output .= ">\n";
  return $output;
}

package XML::Xerces::DOM_Entity;
sub serialize {
  my $output;
  $output .= '<!ENTITY ' . $_[0]->getNodeName;

  my $id;
  if ($id = $_[0]->getPublicId) { $output .= qq[ PUBLIC "$id"]; }
  if ($id = $_[0]->getSystemId) { $output .= qq[ SYSTEM "$id"]; }
  if ($id = $_[0]->getNotationName) { $output .= qq[ NDATA "$id"]; }

  $output .= '>';
  return $output;
}

package XML::Xerces::DOM_DOMException;
sub getMessage {
  return shift->{msg};
}

package XML::Xerces::DOM_Node;
sub isNull {
  warn("using DOM_Node::isNULL() is depricated");
  return 0;
}

sub actual_cast {
  warn("using DOM_Node::actual_cast() is depricated");
  return $_[0];
}

package XML::Xerces::DOM_Document;
sub createDocument {
  warn("using DOM_Document::createDocument() is depricated");
  return undef;
}

package XML::Xerces::DOMParser;
sub setToCreateXMLDeclTypeNode {
  warn("using DOMParser::setToCreateXMLDeclTypeNode() is depricated");
}

package XML::Xerces;
#
# NOTICE: We are automatically calling XMLPlatformUtils::Initialize()
#   when the module is loaded. Do not call it on your own.
#
#
XML::Xerces::XMLPlatformUtils::Initialize();

1;

This file contains hints about how to wrap a class for use with SWIG.

* comment out all c preprocessor statements (#include, #ifdef, #endif,
  etc.). Likewise comment out any class declarations (i.e. 'class
  Foo;'). 
* comment out all private or protected attributes or methods. SWIG
  will try to access them as if they were public, and this will cause
  a compile error.
* comment out the 'const' of an pointers to const objects (i.e.
  foo(const Bar* const p) => foo(const Bar* /*const*/p). SWIG can't
  parse it.
* If the class has no superclass, comment out the colon after the
  classname, i.e 'class foo :' => 'class foo //:'. SWIG can't parse
  it. If there is a superclass, do *not* comment it out.

Things to be aware of:

* If you leave a public Destructor defined, SWIG will create a
  DESTROY() method for you.

Abstract Base Classes (Interfaces):
* It is possible to force SWIG to create a class for interfaces by
  commenting out the trailing '= 0;' for each abstract method.
* if you leave a public constructor defined, SWIG will create a new()
  method that will try to instantiate an object of that type, which
  will cause a compile error.

Overloaded Methods:
* SWIG can't handle overloaded methods or operators. You have to help
  it out, by renaming the methods in the header file, and then post
  editing the resulting .pm and .C files.
* For overloaded methods, you can give each method an __overload__XX
  suffix. In the .pm file, remove all the __overload__* methods, and
  modify the original method to invoke the appropriate C++ method
  depending on what arguments you've been given. In the C++ file, you
  must edit the __overload__* methods invoke the originally named
  method. For example, say we have two overloaded methods:

    SAX2XMLReader * createXMLReader();
    SAX2XMLReader * createXMLReader(const XMLCh* cName);

  In the header files we rename these:

    SAX2XMLReader * createXMLReader();
    SAX2XMLReader * createXMLReader__overload__1(const XMLCh* cName);

  In the .pm file we remove the createXMLReader__overload__1()
  method completely, and edit the createXMLReader() method so:

    sub createXMLReader {
    	my @args = @_;
    	if (scalar @args == 2) {
    	  XMLReaderFactory_createXMLReader__overload__1(@args);
    	} else {
    	  XMLReaderFactory_createXMLReader(@args);
    	}
    }
* for operator overloading, SWIG can't parse tthe operator names, so
  they must be renamed in the header files, and then after wrapping,
  renamed back to their original names in the .pm and .C files. For
  example, if we have:

    XMLURL& operator=(const XMLURL& toAssign);
    bool operator==(const XMLURL& toCompare) const;
    bool operator!=(const XMLURL& toCompare) const;

  These would be renamed in the header to:

    XMLURL& assignment(const XMLURL& toAssign);
    bool equal_to(const XMLURL& toCompare) const;
    bool not_equal_to(const XMLURL& toCompare) const;

  And then all *assignment methods would be renamed to operator= after
  wrapping, etc.



### *** emacs file mode definition ***
### Local Variables: 
### mode:text
### mode:filladapt
### End: 


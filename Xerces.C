/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.12u-20020420-2241
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(T t) {tt = new T(t); return *this;}
    inline operator T&() const {return *tt;}
    inline T *operator&() { return tt; }
};                                                    
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
  void                   *clientdata;	
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/* -----------------------------------------------------------------------------
 * perl5.swg
 *
 * Perl5 runtime library
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#ifndef pTHX_
#define pTHX_
#endif

#include <string.h>
#ifdef __cplusplus
}
#endif

/* Note: SwigMagicFuncHack is a typedef used to get the C++
   compiler to just shut up already */

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(SV *sv, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (sv_derived_from(sv,(char*)s->name)) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (CPerlObj::*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
#define SWIGCLASS_STATIC
#else
#define MAGIC_PPERL
#define SWIGCLASS_STATIC static
#ifndef MULTIPLICITY
#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#else
#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#endif
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE

#ifndef PERL_OBJECT
extern int SWIG_ConvertPtr(SV *, void **, swig_type_info *);
extern void SWIG_MakePtr(SV *, void *, swig_type_info *);
#else
extern int _SWIG_ConvertPtr(CPerlObj *, SV *, void **, swig_type_info *);
extern void _SWIG_MakePtr(CPerlObj *, SV *, void *, swig_type_info *);
#define SWIG_ConvertPtr(a,b,c) _SWIG_ConvertPtr(pPerl,a,b,c)
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
#endif

#else

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGRUNTIME(int) 
SWIG_ConvertPtr(SV *sv, void **ptr, swig_type_info *_t)
#else
#define SWIG_ConvertPtr(a,b,c) _SWIG_ConvertPtr(pPerl,a,b,c)
SWIGRUNTIME(int)
_SWIG_ConvertPtr(CPerlObj *pPerl, SV *sv, void **ptr, swig_type_info *_t)
#endif
{
  char *_c;
  swig_type_info *tc;
  IV   tmp;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
      *(ptr) = (void *) 0;
      return -1;
  }
  if (_t) {
    /* Now see if the types match */      
    _c = HvNAME(SvSTASH(SvRV(sv)));
    tc = SWIG_TypeCheck(sv,_t);
    if (!tc) {
      *ptr = (void *) tmp;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,(void *)tmp);
    return 0;
  }
  *ptr = (void *) tmp;
  return 0;
}
#ifndef PERL_OBJECT
SWIGRUNTIME(void) 
SWIG_MakePtr(SV *sv, void *ptr, swig_type_info *t)
#else
#define SWIG_MakePtr(a,b,c) _SWIG_MakePtr(pPerl,a,b,c)
SWIGRUNTIME(void)
_SWIG_MakePtr(CPerlObj *pPerl, SV *sv, void *ptr, swig_type_info *t)
#endif
{
  sv_setref_pv(sv, (char *) t->name, ptr);
}

#endif

typedef XS(SwigPerlWrapper);
typedef SwigPerlWrapper *SwigPerlWrapperPtr;

/* Structure for command table */
typedef struct {
  const char         *name;
  SwigPerlWrapperPtr  wrapper;
} swig_command_info;

/* Information for constant table */

#define SWIG_INT     1
#define SWIG_FLOAT   2
#define SWIG_STRING  3
#define SWIG_POINTER 4
#define SWIG_BINARY  5

/* Constant information structure */
typedef struct swig_constant_info {
    int              type;
    const char      *name;
    long             lvalue;
    double           dvalue;
    void            *pvalue;
    swig_type_info **ptype;
} swig_constant_info;

#ifdef __cplusplus
}
#endif

/* Structure for variable table */
typedef struct {
  const char   *name;
  SwigMagicFunc   set;
  SwigMagicFunc   get;
  swig_type_info  **type;
} swig_variable_info;

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
  #ifndef MULTIPLICITY 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int \
(*get)(SV *,MAGIC *)) { 
  #else 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*,\
 SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) { 
  #endif 
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',(char *) name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = (SwigMagicFuncHack) get;
  mg->mg_virtual->svt_set = (SwigMagicFuncHack) set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_IDOM_Document swig_types[0] 
#define  SWIGTYPE_p_IDOM_NodeIterator swig_types[1] 
#define  SWIGTYPE_p_IDOM_DOMImplementation swig_types[2] 
#define  SWIGTYPE_p_IDOM_Text swig_types[3] 
#define  SWIGTYPE_p_XMLAttr swig_types[4] 
#define  SWIGTYPE_p_AttributeList swig_types[5] 
#define  SWIGTYPE_p_XMLBuffer swig_types[6] 
#define  SWIGTYPE_p_bool swig_types[7] 
#define  SWIGTYPE_p_IDOM_NodeFilter swig_types[8] 
#define  SWIGTYPE_p_p_QName swig_types[9] 
#define  SWIGTYPE_p_QName swig_types[10] 
#define  SWIGTYPE_p_XMLNotationDecl swig_types[11] 
#define  SWIGTYPE_p_IDOM_DocumentType swig_types[12] 
#define  SWIGTYPE_p_XMLElementDecl swig_types[13] 
#define  SWIGTYPE_p_void swig_types[14] 
#define  SWIGTYPE_p_p_void swig_types[15] 
#define  SWIGTYPE_p_IDOM_EntityReference swig_types[16] 
#define  SWIGTYPE_p_int swig_types[17] 
#define  SWIGTYPE_p_IDOM_Notation swig_types[18] 
#define  SWIGTYPE_p_SAXParseException swig_types[19] 
#define  SWIGTYPE_p_SAXNotRecognizedException swig_types[20] 
#define  SWIGTYPE_p_SAXNotSupportedException swig_types[21] 
#define  SWIGTYPE_p_IDOM_DOMException swig_types[22] 
#define  SWIGTYPE_p_SAXException swig_types[23] 
#define  SWIGTYPE_p_XMLException swig_types[24] 
#define  SWIGTYPE_p_XMLErrorReporter swig_types[25] 
#define  SWIGTYPE_p_IDOM_RangeException swig_types[26] 
#define  SWIGTYPE_p_XMLDeleter swig_types[27] 
#define  SWIGTYPE_p_Attributes swig_types[28] 
#define  SWIGTYPE_p_FileHandle swig_types[29] 
#define  SWIGTYPE_p_IDOMParser swig_types[30] 
#define  SWIGTYPE_p_XMLScanner swig_types[31] 
#define  SWIGTYPE_p_XMLByte swig_types[32] 
#define  SWIGTYPE_p_XMLURL swig_types[33] 
#define  SWIGTYPE_p_XMLAttDef swig_types[34] 
#define  SWIGTYPE_p_EntityResolver swig_types[35] 
#define  SWIGTYPE_p_DeclHandler swig_types[36] 
#define  SWIGTYPE_p_XMLEntityHandler swig_types[37] 
#define  SWIGTYPE_p_DocTypeHandler swig_types[38] 
#define  SWIGTYPE_p_XMLDocumentHandler swig_types[39] 
#define  SWIGTYPE_p_DefaultHandler swig_types[40] 
#define  SWIGTYPE_p_LexicalHandler swig_types[41] 
#define  SWIGTYPE_p_DTDHandler swig_types[42] 
#define  SWIGTYPE_p_ErrorHandler swig_types[43] 
#define  SWIGTYPE_p_ContentHandler swig_types[44] 
#define  SWIGTYPE_p_DocumentHandler swig_types[45] 
#define  SWIGTYPE_p_PerlCallbackHandler swig_types[46] 
#define  SWIGTYPE_p_PerlNodeFilterCallbackHandler swig_types[47] 
#define  SWIGTYPE_p_PerlDocumentCallbackHandler swig_types[48] 
#define  SWIGTYPE_p_PerlContentCallbackHandler swig_types[49] 
#define  SWIGTYPE_p_PerlEntityResolverHandler swig_types[50] 
#define  SWIGTYPE_p_PerlErrorCallbackHandler swig_types[51] 
#define  SWIGTYPE_p_IDOM_TreeWalker swig_types[52] 
#define  SWIGTYPE_p_IDOM_Range swig_types[53] 
#define  SWIGTYPE_p_IDOM_Node swig_types[54] 
#define  SWIGTYPE_p_XMLValid__Codes swig_types[55] 
#define  SWIGTYPE_p_DTDEntityDecl swig_types[56] 
#define  SWIGTYPE_p_XMLMsgLoader swig_types[57] 
#define  SWIGTYPE_p_XMLBufferMgr swig_types[58] 
#define  SWIGTYPE_p_Locator swig_types[59] 
#define  SWIGTYPE_p_IDOM_CharacterData swig_types[60] 
#define  SWIGTYPE_p_IDOM_DocumentFragment swig_types[61] 
#define  SWIGTYPE_p_BinInputStream swig_types[62] 
#define  SWIGTYPE_p_URLInputSource swig_types[63] 
#define  SWIGTYPE_p_LocalFileInputSource swig_types[64] 
#define  SWIGTYPE_p_StdInInputSource swig_types[65] 
#define  SWIGTYPE_p_MemBufInputSource swig_types[66] 
#define  SWIGTYPE_p_InputSource swig_types[67] 
#define  SWIGTYPE_p_ElemStack__MapModes swig_types[68] 
#define  SWIGTYPE_p_IDOM_NamedNodeMap swig_types[69] 
#define  SWIGTYPE_p_ReaderMgr swig_types[70] 
#define  SWIGTYPE_p_IDOM_NodeList swig_types[71] 
#define  SWIGTYPE_p_Grammar swig_types[72] 
#define  SWIGTYPE_p_SAX2XMLReader swig_types[73] 
#define  SWIGTYPE_p_SAXParser swig_types[74] 
#define  SWIGTYPE_p_IDOM_Comment swig_types[75] 
#define  SWIGTYPE_p_HandlerBase swig_types[76] 
#define  SWIGTYPE_p_XMLUri swig_types[77] 
#define  SWIGTYPE_p_unsigned_int swig_types[78] 
#define  SWIGTYPE_p_IDOM_ProcessingInstruction swig_types[79] 
#define  SWIGTYPE_p_IDOM_Attr swig_types[80] 
#define  SWIGTYPE_p_IDOM_CDATASection swig_types[81] 
#define  SWIGTYPE_p_XMLErrorReporter__ErrTypes swig_types[82] 
#define  SWIGTYPE_p_XMLPScanToken swig_types[83] 
#define  SWIGTYPE_p_IDOM_Element swig_types[84] 
#define  SWIGTYPE_p_XMLValidator swig_types[85] 
#define  SWIGTYPE_p_IDOM_Entity swig_types[86] 
static swig_type_info *swig_types[87];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_XML__Xerces

#define SWIG_name   "XML::Xercesc::boot_XML__Xerces"
#define SWIG_prefix "XML::Xercesc::"

#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#ifndef MULTIPLICITY
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (pTHXo_ CV* cv);
#endif
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif

#include "stdio.h"
#include "string.h"
#include "xercesc/sax/InputSource.hpp"
#include "xercesc/sax/SAXException.hpp"
#include "xercesc/sax/SAXParseException.hpp"
#include "xercesc/sax/Locator.hpp"
#include "xercesc/sax/HandlerBase.hpp"
#include "xercesc/sax2/Attributes.hpp"
#include "xercesc/sax2/ContentHandler.hpp"
#include "xercesc/sax2/LexicalHandler.hpp"
#include "xercesc/sax2/DefaultHandler.hpp"
#include "xercesc/sax2/SAX2XMLReader.hpp"
#include "xercesc/sax2/XMLReaderFactory.hpp"
#include "xercesc/util/PlatformUtils.hpp"
#include "xercesc/util/TransService.hpp"
#include "xercesc/util/XMLString.hpp"
#include "xercesc/util/XMLUri.hpp"
#include "xercesc/util/QName.hpp"
#include "xercesc/util/HexBin.hpp"
#include "xercesc/util/Base64.hpp"
#include "xercesc/parsers/IDOMParser.hpp"
#include "xercesc/parsers/SAXParser.hpp"
#include "xercesc/idom/IDOM.hpp"
#include "xercesc/framework/LocalFileInputSource.hpp"
#include "xercesc/framework/MemBufInputSource.hpp"
#include "xercesc/framework/StdInInputSource.hpp"
#include "xercesc/framework/URLInputSource.hpp"
#include "xercesc/framework/XMLValidator.hpp"
#include "xercesc/validators/common/Grammar.hpp"

#include "PerlErrorCallbackHandler.hpp"
#include "PerlEntityResolverHandler.i"
#include "PerlNodeFilterCallbackHandler.i"
#include "PerlDocumentCallbackHandler.hpp"
#include "PerlContentCallbackHandler.hpp"

// we initialize the static UTF-8 transcoding info
// these are used by the typemaps to convert between
// Xerces internal UTF-16 and Perl's internal UTF-8
static XMLCh* UTF8_ENCODING = NULL; 
static XMLTranscoder* UTF8_TRANSCODER  = NULL;

static XMLCh* ISO_8859_1_ENCODING = NULL; 
static XMLTranscoder* ISO_8859_1_TRANSCODER  = NULL;

static bool DEBUG_UTF8_OUT = 0;
static bool DEBUG_UTF8_IN = 0;

// These exception creation methods make the Xerces.C code *much* smaller
void
makeXMLException(const XMLException& e){
    SV *tmpsv;
    HV *hash = newHV();
    char *XML_EXCEPTION = "XML::Xerces::XMLException";
    HV *XML_EXCEPTION_STASH = gv_stashpv(XML_EXCEPTION, FALSE);
    hv_magic(hash, 
	     (GV *)sv_setref_pv(sv_newmortal(), 
				XML_EXCEPTION, (void *)&e), 
	     'P');
    tmpsv = sv_bless(newRV_noinc((SV *)hash), XML_EXCEPTION_STASH);
    SV *error = ERRSV;
    SvSetSV(error,tmpsv);
    (void)SvUPGRADE(error, SVt_PV);
    Perl_die(Nullch);
}

void
makeIDOMException(const IDOM_DOMException& e){
    SV *tmpsv;
    HV *hash = newHV();
    char *IDOM_EXCEPTION = "XML::Xerces::DOM_DOMException";
    HV *IDOM_EXCEPTION_STASH = gv_stashpv(IDOM_EXCEPTION, FALSE);
    hv_magic(hash, 
	     (GV *)sv_setref_pv(sv_newmortal(), 
				IDOM_EXCEPTION, (void *)&e), 
	     'P');
    tmpsv = sv_bless(newRV_noinc((SV *)hash), IDOM_EXCEPTION_STASH);
    SV *error = ERRSV;
    SvSetSV(error,tmpsv);
    (void)SvUPGRADE(error, SVt_PV);
    Perl_die(Nullch);
}

void
makeSAXNotRecognizedException(const SAXNotRecognizedException& e){
    SV *tmpsv;
    HV *hash = newHV();
    char *SAX_NOT_RECOGNIZED_EXCEPTION = "XML::Xerces::SAXNotRecognizedException";
    HV *SAX_NOT_RECOGNIZED_EXCEPTION_STASH = gv_stashpv(SAX_NOT_RECOGNIZED_EXCEPTION, FALSE);
    hv_magic(hash, 
	     (GV *)sv_setref_pv(sv_newmortal(), 
				SAX_NOT_RECOGNIZED_EXCEPTION, (void *)&e), 
	     'P');
    tmpsv = sv_bless(newRV_noinc((SV *)hash), SAX_NOT_RECOGNIZED_EXCEPTION_STASH);
    SV *error = ERRSV;
    SvSetSV(error,tmpsv);
    (void)SvUPGRADE(error, SVt_PV);
    Perl_die(Nullch);
}

void
makeSAXNotSupportedException(const SAXNotSupportedException& e){
    SV *tmpsv;
    HV *hash = newHV();
    char *SAX_NOT_SUPPORTED_EXCEPTION = "XML::Xerces::SAXNotSupportedException";
    HV *SAX_NOT_SUPPORTED_EXCEPTION_STASH = gv_stashpv(SAX_NOT_SUPPORTED_EXCEPTION, FALSE);
    hv_magic(hash, 
	     (GV *)sv_setref_pv(sv_newmortal(), 
				SAX_NOT_SUPPORTED_EXCEPTION, (void *)&e), 
	     'P');
    tmpsv = sv_bless(newRV_noinc((SV *)hash), SAX_NOT_SUPPORTED_EXCEPTION_STASH);
    SV *error = ERRSV;
    SvSetSV(error,tmpsv);
    (void)SvUPGRADE(error, SVt_PV);
    Perl_die(Nullch);
}

SV*
XMLString2Perl(XMLCh* input){
    SV *output;
  unsigned int charsEaten = 0;
  int length  = XMLString::stringLen(input);      // string length
  XMLByte* res = new XMLByte[length * UTF8_MAXLEN];          // output string
  unsigned int total_chars =
    UTF8_TRANSCODER->transcodeTo((const XMLCh*) input, 
				   (unsigned int) length,
				   (XMLByte*) res,
				   (unsigned int) length*UTF8_MAXLEN,
				   charsEaten,
				   XMLTranscoder::UnRep_Throw
				   );
  res[total_chars] = '\0';
  if (DEBUG_UTF8_OUT) {
      printf("Xerces out length = %d: ",total_chars);
      for (int i=0;i<length;i++){
	  printf("<0x%.4X>",res[i]);
      }
      printf("\n");
  }
  output = sv_newmortal();
  sv_setpv((SV*)output, (char *)res );
  SvUTF8_on((SV*)output);
  delete[] res;
  return output;
}

XMLCh* 
Perl2XMLString(SV* input){
    XMLCh* output;

    STRLEN length;
    char *ptr = (char *)SvPV(input,length);
    if (DEBUG_UTF8_IN) {
	printf("Perl in length = %d: ",length);
	for (unsigned int i=0;i<length;i++){
	    printf("<0x%.4X>",ptr[i]);
	}
	printf("\n");
    }
    if (SvUTF8(input)) {
	unsigned int charsEaten = 0;
        unsigned char* sizes = new unsigned char[length+1];
        output = new XMLCh[length+1];
	unsigned int chars_stored = 
	    UTF8_TRANSCODER->transcodeFrom((const XMLByte*) ptr,
					   (unsigned int) length,
					   (XMLCh*) output, 
					   (unsigned int) length,
					   charsEaten,
					   (unsigned char*)sizes
					   );
	delete [] sizes;
	if (DEBUG_UTF8_IN) {
	    printf("Xerces in length = %d: ",chars_stored);
	    for (unsigned int i=0;i<chars_stored;i++){
		printf("<0x%.4X>",output[i]);
	    }
	    printf("\n");
	}
	    // indicate the end of the string
	output[chars_stored] = '\0';
    } else {
	output = XMLString::transcode(ptr);
	if (DEBUG_UTF8_IN) {
	    printf("Xerces: ");
	    for (int i=0;output[i];i++){
		printf("<0x%.4X>",output[i]);
	    }
	    printf("\n");
	}
    }
    return(output);
}

static swig_type_info *
IDOM_Node_dynamic_cast(void **ptr) {
   IDOM_Node **nptr = (IDOM_Node **) ptr;
   if (*nptr == NULL) {
       return NULL;
   }
   short int type = (*nptr)->getNodeType();
   if (type == IDOM_Node::TEXT_NODE) {
      return SWIGTYPE_p_IDOM_Text;
   }
   if (type == IDOM_Node::PROCESSING_INSTRUCTION_NODE) {
      return SWIGTYPE_p_IDOM_ProcessingInstruction;
   }
   if (type == IDOM_Node::DOCUMENT_NODE) {
      return SWIGTYPE_p_IDOM_Document;
   }
   if (type == IDOM_Node::ELEMENT_NODE) {
      return SWIGTYPE_p_IDOM_Element;
   }
   if (type == IDOM_Node::ENTITY_REFERENCE_NODE) {
      return SWIGTYPE_p_IDOM_EntityReference;
   }
   if (type == IDOM_Node::CDATA_SECTION_NODE) {
      return SWIGTYPE_p_IDOM_CDATASection;
   }
   if (type == IDOM_Node::CDATA_SECTION_NODE) {
      return SWIGTYPE_p_IDOM_CDATASection;
   }
   if (type == IDOM_Node::COMMENT_NODE) {
      return SWIGTYPE_p_IDOM_Comment;
   }
   if (type == IDOM_Node::DOCUMENT_TYPE_NODE) {
      return SWIGTYPE_p_IDOM_DocumentType;
   }
   if (type == IDOM_Node::ENTITY_NODE) {
      return SWIGTYPE_p_IDOM_Entity;
   }
   if (type == IDOM_Node::ATTRIBUTE_NODE) {
      return SWIGTYPE_p_IDOM_Attr;
   }
   if (type == IDOM_Node::NOTATION_NODE) {
      return SWIGTYPE_p_IDOM_Notation;
   }
   return NULL;
}

bool IDOM_Node_operator_ee___(IDOM_Node *self,IDOM_Node const &other){
       return self == &other;
   }
bool IDOM_Node_operator_Ne___(IDOM_Node *self,IDOM_Node const &other){
       return self != &other;
   }
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_Xerces_var::
class _wrap_Xerces_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}
SWIGCLASS_STATIC int _wrap_set_DEBUG_UTF8_OUT(pTHX_ SV* sv, MAGIC *mg) {
    MAGIC_PPERL
    mg = mg;
    DEBUG_UTF8_OUT = (bool ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_DEBUG_UTF8_OUT(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) DEBUG_UTF8_OUT);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_DEBUG_UTF8_IN(pTHX_ SV* sv, MAGIC *mg) {
    MAGIC_PPERL
    mg = mg;
    DEBUG_UTF8_IN = (bool ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_DEBUG_UTF8_IN(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) DEBUG_UTF8_IN);
    return 1;
}

#ifdef PERL_OBJECT
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
XS(_wrap_new_PerlNodeFilterCallbackHandler) {
    PerlNodeFilterCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_PerlNodeFilterCallbackHandler();");
    }
    result = (PerlNodeFilterCallbackHandler *)new PerlNodeFilterCallbackHandler();
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlNodeFilterCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_new_PerlNodeFilterCallbackHandler__constructor__arg) {
    SV *arg1 ;
    PerlNodeFilterCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_PerlNodeFilterCallbackHandler__constructor__arg(SV *);");
    }
    {
        arg1 = ST(0);
    }
    result = (PerlNodeFilterCallbackHandler *)new PerlNodeFilterCallbackHandler(arg1);
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlNodeFilterCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_PerlNodeFilterCallbackHandler_set_callback_obj) {
    PerlNodeFilterCallbackHandler *arg1 ;
    SV *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: PerlNodeFilterCallbackHandler_set_callback_obj(self,SV *);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PerlNodeFilterCallbackHandler) < 0) {
            croak("Type error in argument 1 of PerlNodeFilterCallbackHandler_set_callback_obj. Expected %s", SWIGTYPE_p_PerlNodeFilterCallbackHandler->name);
        }
    }
    {
        arg2 = ST(1);
    }
    (arg1)->set_callback_obj(arg2);
    
    
    XSRETURN(argvi);
}

XS(_wrap_new_PerlDocumentCallbackHandler) {
    PerlDocumentCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_PerlDocumentCallbackHandler();");
    }
    result = (PerlDocumentCallbackHandler *)new PerlDocumentCallbackHandler();
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlDocumentCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_new_PerlDocumentCallbackHandler__constructor__arg) {
    SV *arg1 ;
    PerlDocumentCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_PerlDocumentCallbackHandler__constructor__arg(SV *);");
    }
    {
        arg1 = ST(0);
    }
    result = (PerlDocumentCallbackHandler *)new PerlDocumentCallbackHandler(arg1);
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlDocumentCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_PerlDocumentCallbackHandler_set_callback_obj) {
    PerlDocumentCallbackHandler *arg1 ;
    SV *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: PerlDocumentCallbackHandler_set_callback_obj(self,SV *);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PerlDocumentCallbackHandler) < 0) {
            croak("Type error in argument 1 of PerlDocumentCallbackHandler_set_callback_obj. Expected %s", SWIGTYPE_p_PerlDocumentCallbackHandler->name);
        }
    }
    {
        arg2 = ST(1);
    }
    (arg1)->set_callback_obj(arg2);
    
    
    XSRETURN(argvi);
}

XS(_wrap_new_PerlContentCallbackHandler) {
    PerlContentCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_PerlContentCallbackHandler();");
    }
    result = (PerlContentCallbackHandler *)new PerlContentCallbackHandler();
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlContentCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_new_PerlContentCallbackHandler__constructor__arg) {
    SV *arg1 ;
    PerlContentCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_PerlContentCallbackHandler__constructor__arg(SV *);");
    }
    {
        arg1 = ST(0);
    }
    result = (PerlContentCallbackHandler *)new PerlContentCallbackHandler(arg1);
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlContentCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_PerlContentCallbackHandler_set_callback_obj) {
    PerlContentCallbackHandler *arg1 ;
    SV *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: PerlContentCallbackHandler_set_callback_obj(self,SV *);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PerlContentCallbackHandler) < 0) {
            croak("Type error in argument 1 of PerlContentCallbackHandler_set_callback_obj. Expected %s", SWIGTYPE_p_PerlContentCallbackHandler->name);
        }
    }
    {
        arg2 = ST(1);
    }
    (arg1)->set_callback_obj(arg2);
    
    
    XSRETURN(argvi);
}

XS(_wrap_new_PerlEntityResolverHandler) {
    PerlEntityResolverHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_PerlEntityResolverHandler();");
    }
    result = (PerlEntityResolverHandler *)new PerlEntityResolverHandler();
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlEntityResolverHandler);
    XSRETURN(argvi);
}

XS(_wrap_new_PerlEntityResolverHandler__constructor__arg) {
    SV *arg1 ;
    PerlEntityResolverHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_PerlEntityResolverHandler__constructor__arg(SV *);");
    }
    {
        arg1 = ST(0);
    }
    result = (PerlEntityResolverHandler *)new PerlEntityResolverHandler(arg1);
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlEntityResolverHandler);
    XSRETURN(argvi);
}

XS(_wrap_PerlEntityResolverHandler_set_callback_obj) {
    PerlEntityResolverHandler *arg1 ;
    SV *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: PerlEntityResolverHandler_set_callback_obj(self,SV *);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PerlEntityResolverHandler) < 0) {
            croak("Type error in argument 1 of PerlEntityResolverHandler_set_callback_obj. Expected %s", SWIGTYPE_p_PerlEntityResolverHandler->name);
        }
    }
    {
        arg2 = ST(1);
    }
    (arg1)->set_callback_obj(arg2);
    
    
    XSRETURN(argvi);
}

XS(_wrap_new_PerlErrorCallbackHandler) {
    PerlErrorCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_PerlErrorCallbackHandler();");
    }
    result = (PerlErrorCallbackHandler *)new PerlErrorCallbackHandler();
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlErrorCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_new_PerlErrorCallbackHandler__constructor__arg) {
    SV *arg1 ;
    PerlErrorCallbackHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_PerlErrorCallbackHandler__constructor__arg(SV *);");
    }
    {
        arg1 = ST(0);
    }
    result = (PerlErrorCallbackHandler *)new PerlErrorCallbackHandler(arg1);
    
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_PerlErrorCallbackHandler);
    XSRETURN(argvi);
}

XS(_wrap_PerlErrorCallbackHandler_set_callback_obj) {
    PerlErrorCallbackHandler *arg1 ;
    SV *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: PerlErrorCallbackHandler_set_callback_obj(self,SV *);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_PerlErrorCallbackHandler) < 0) {
            croak("Type error in argument 1 of PerlErrorCallbackHandler_set_callback_obj. Expected %s", SWIGTYPE_p_PerlErrorCallbackHandler->name);
        }
    }
    {
        arg2 = ST(1);
    }
    (arg1)->set_callback_obj(arg2);
    
    
    XSRETURN(argvi);
}

XS(_wrap_delete_XMLDeleter) {
    XMLDeleter *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_XMLDeleter(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLDeleter) < 0) {
            croak("Type error in argument 1 of delete_XMLDeleter. Expected %s", SWIGTYPE_p_XMLDeleter->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_Initialize) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLPlatformUtils_Initialize();");
    }
    {
        try {
            XMLPlatformUtils::Initialize();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_Terminate) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLPlatformUtils_Terminate();");
    }
    {
        try {
            XMLPlatformUtils::Terminate();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_panic) {
    int arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_panic(reason);");
    }
    arg1 = (int ) SvIV(ST(0));
    {
        try {
            XMLPlatformUtils::panic((XMLPlatformUtils::PanicReasons )arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_curFilePos) {
    FileHandle arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_curFilePos(theFile);");
    }
    {
        FileHandle * argp;
        if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_FileHandle) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_curFilePos. Expected %s", SWIGTYPE_p_FileHandle->name);	
        }
        arg1 = *argp;
    }
    {
        try {
            result = (unsigned int )XMLPlatformUtils::curFilePos(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_closeFile) {
    FileHandle arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_closeFile(theFile);");
    }
    {
        FileHandle * argp;
        if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_FileHandle) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_closeFile. Expected %s", SWIGTYPE_p_FileHandle->name);	
        }
        arg1 = *argp;
    }
    {
        try {
            XMLPlatformUtils::closeFile(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_fileSize) {
    FileHandle arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_fileSize(theFile);");
    }
    {
        FileHandle * argp;
        if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_FileHandle) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_fileSize. Expected %s", SWIGTYPE_p_FileHandle->name);	
        }
        arg1 = *argp;
    }
    {
        try {
            result = (unsigned int )XMLPlatformUtils::fileSize(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_openFile) {
    char *arg1 ;
    FileHandle result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_openFile(fileName);");
    }
    if (!SvOK((SV*) ST(0))) arg1 = 0;
    else arg1 = (char *) SvPV(ST(0), PL_na);
    {
        try {
            result = XMLPlatformUtils::openFile((char const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        FileHandle * resultobj = new FileHandle (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_FileHandle);
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_openStdInHandle) {
    FileHandle result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLPlatformUtils_openStdInHandle();");
    }
    {
        try {
            result = XMLPlatformUtils::openStdInHandle();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        FileHandle * resultobj = new FileHandle (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_FileHandle);
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_readFileBuffer) {
    FileHandle arg1 ;
    unsigned int arg2 ;
    XMLByte *arg3 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: XMLPlatformUtils_readFileBuffer(theFile,toRead,toFill);");
    }
    {
        FileHandle * argp;
        if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_FileHandle) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_readFileBuffer. Expected %s", SWIGTYPE_p_FileHandle->name);	
        }
        arg1 = *argp;
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLByte) < 0) {
            croak("Type error in argument 3 of XMLPlatformUtils_readFileBuffer. Expected %s", SWIGTYPE_p_XMLByte->name);
        }
    }
    {
        try {
            result = (unsigned int )XMLPlatformUtils::readFileBuffer(arg1,arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_resetFile) {
    FileHandle arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_resetFile(theFile);");
    }
    {
        FileHandle * argp;
        if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_FileHandle) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_resetFile. Expected %s", SWIGTYPE_p_FileHandle->name);	
        }
        arg1 = *argp;
    }
    {
        try {
            XMLPlatformUtils::resetFile(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_getFullPath) {
    XMLCh *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_getFullPath(srcPath);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of XMLPlatformUtils::getFullPath, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)XMLPlatformUtils::getFullPath((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_isRelative) {
    XMLCh *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_isRelative(toCheck);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of XMLPlatformUtils::isRelative, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (bool )XMLPlatformUtils::isRelative((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_weavePaths) {
    XMLCh *arg1 ;
    XMLCh *arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLPlatformUtils_weavePaths(basePath,relativePath);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of XMLPlatformUtils::weavePaths, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of XMLPlatformUtils::weavePaths, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)XMLPlatformUtils::weavePaths((XMLCh const *)arg1,(XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg1;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_getCurrentMillis) {
    unsigned long result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLPlatformUtils_getCurrentMillis();");
    }
    {
        try {
            result = (unsigned long )XMLPlatformUtils::getCurrentMillis();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_closeMutex) {
    void *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_closeMutex(mtxHandle);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_closeMutex. Expected %s", SWIGTYPE_p_void->name);
        }
    }
    {
        try {
            XMLPlatformUtils::closeMutex(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_lockMutex) {
    void *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_lockMutex(mtxHandle);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_lockMutex. Expected %s", SWIGTYPE_p_void->name);
        }
    }
    {
        try {
            XMLPlatformUtils::lockMutex(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_makeMutex) {
    void *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLPlatformUtils_makeMutex();");
    }
    {
        try {
            result = (void *)XMLPlatformUtils::makeMutex();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_unlockMutex) {
    void *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_unlockMutex(mtxHandle);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, 0) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_unlockMutex. Expected %s", SWIGTYPE_p_void->name);
        }
    }
    {
        try {
            XMLPlatformUtils::unlockMutex(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_loadMsgSet) {
    XMLCh *arg1 ;
    XMLMsgLoader *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_loadMsgSet(msgDomain);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of XMLPlatformUtils::loadMsgSet, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLMsgLoader *)XMLPlatformUtils::loadMsgSet((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLMsgLoader);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_compareAndSwap) {
    void **arg1 ;
    void *arg2 ;
    void *arg3 ;
    void *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: XMLPlatformUtils_compareAndSwap(toFill,newValue,toCompare);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_p_void) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_compareAndSwap. Expected %s", SWIGTYPE_p_p_void->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, 0) < 0) {
            croak("Type error in argument 2 of XMLPlatformUtils_compareAndSwap. Expected %s", SWIGTYPE_p_void->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, 0) < 0) {
            croak("Type error in argument 3 of XMLPlatformUtils_compareAndSwap. Expected %s", SWIGTYPE_p_void->name);
        }
    }
    {
        try {
            result = (void *)XMLPlatformUtils::compareAndSwap(arg1,(void const *)arg2,(void const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_atomicIncrement) {
    int *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_atomicIncrement(location);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_int) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_atomicIncrement. Expected %s", SWIGTYPE_p_int->name);
        }
    }
    {
        try {
            result = (int )XMLPlatformUtils::atomicIncrement(*arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_atomicDecrement) {
    int *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_atomicDecrement(location);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_int) < 0) {
            croak("Type error in argument 1 of XMLPlatformUtils_atomicDecrement. Expected %s", SWIGTYPE_p_int->name);
        }
    }
    {
        try {
            result = (int )XMLPlatformUtils::atomicDecrement(*arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_recognizeNEL) {
    bool arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLPlatformUtils_recognizeNEL(state);");
    }
    arg1 = (bool ) SvIV(ST(0));
    {
        try {
            XMLPlatformUtils::recognizeNEL(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPlatformUtils_isNELRecognized) {
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLPlatformUtils_isNELRecognized();");
    }
    {
        try {
            result = (bool )XMLPlatformUtils::isNELRecognized();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_lookupByName) {
    XMLURL *arg1 ;
    XMLCh *arg2 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLURL_lookupByName(self,protoName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_lookupByName. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of lookupByName, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (int )(arg1)->lookupByName((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_XMLURL) {
    XMLURL *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_XMLURL();");
    }
    {
        try {
            result = (XMLURL *)new XMLURL();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLURL);
    XSRETURN(argvi);
}

XS(_wrap_new_XMLURL__constructor__base) {
    XMLCh *arg1 ;
    XMLCh *arg2 ;
    XMLURL *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: new_XMLURL__constructor__base(baseURL,relativeURL);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of XMLURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of XMLURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLURL *)new XMLURL((XMLCh const *)arg1,(XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLURL);
    {
        delete[] arg1;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_XMLURL__constructor__url_base) {
    XMLURL *arg1 ;
    XMLCh *arg2 ;
    XMLURL *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: new_XMLURL__constructor__url_base(baseURL,relativeURL);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of new_XMLURL__constructor__url_base. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of XMLURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLURL *)new XMLURL((XMLURL const &)*arg1,(XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLURL);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_XMLURL__constructor__text) {
    XMLCh *arg1 ;
    XMLURL *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_XMLURL__constructor__text(urlText);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of XMLURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLURL *)new XMLURL((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLURL);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_XMLURL__constructor__copy) {
    XMLURL *arg1 ;
    XMLURL *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_XMLURL__constructor__copy(toCopy);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of new_XMLURL__constructor__copy. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLURL *)new XMLURL((XMLURL const &)*arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLURL);
    XSRETURN(argvi);
}

XS(_wrap_delete_XMLURL) {
    XMLURL *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_XMLURL(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of delete_XMLURL. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_operator_assignment) {
    XMLURL *arg1 ;
    XMLURL *arg2 ;
    XMLURL *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLURL_operator_assignment(self,toAssign);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_operator_assignment. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 2 of XMLURL_operator_assignment. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            XMLURL &_result_ref = (arg1)->operator =((XMLURL const &)*arg2);
            result = (XMLURL *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLURL);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_operator_equal_to) {
    XMLURL *arg1 ;
    XMLURL *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLURL_operator_equal_to(self,toCompare);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_operator_equal_to. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 2 of XMLURL_operator_equal_to. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (bool )((XMLURL const *)arg1)->operator ==((XMLURL const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_operator_not_equal_to) {
    XMLURL *arg1 ;
    XMLURL *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLURL_operator_not_equal_to(self,toCompare);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_operator_not_equal_to. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 2 of XMLURL_operator_not_equal_to. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (bool )((XMLURL const *)arg1)->operator !=((XMLURL const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getFragment) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getFragment(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getFragment. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getFragment();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getHost) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getHost(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getHost. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getHost();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getPassword) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getPassword(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getPassword. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getPassword();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getPath) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getPath(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getPath. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getPath();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getPortNum) {
    XMLURL *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getPortNum(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getPortNum. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (unsigned int )((XMLURL const *)arg1)->getPortNum();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getProtocol) {
    XMLURL *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getProtocol(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getProtocol. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (int )((XMLURL const *)arg1)->getProtocol();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getProtocolName) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getProtocolName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getProtocolName. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getProtocolName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getQuery) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getQuery(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getQuery. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getQuery();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getURLText) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getURLText(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getURLText. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getURLText();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_getUser) {
    XMLURL *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_getUser(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_getUser. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLURL const *)arg1)->getUser();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_setURL) {
    XMLURL *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLURL_setURL(self,urlText);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_setURL. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setURL((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_setURL__overload__string) {
    XMLURL *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: XMLURL_setURL__overload__string(self,baseURL,relativeURL);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_setURL__overload__string. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of setURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setURL((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_setURL__overload__XMLURL) {
    XMLURL *arg1 ;
    XMLURL *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: XMLURL_setURL__overload__XMLURL(self,baseURL,relativeURL);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_setURL__overload__XMLURL. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 2 of XMLURL_setURL__overload__XMLURL. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of setURL, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setURL((XMLURL const &)*arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_isRelative) {
    XMLURL *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_isRelative(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_isRelative. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (bool )((XMLURL const *)arg1)->isRelative();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_makeNewStream) {
    XMLURL *arg1 ;
    BinInputStream *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLURL_makeNewStream(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_makeNewStream. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (BinInputStream *)((XMLURL const *)arg1)->makeNewStream();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BinInputStream);
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_makeRelativeTo) {
    XMLURL *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLURL_makeRelativeTo(self,baseURLText);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_makeRelativeTo. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of makeRelativeTo, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->makeRelativeTo((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLURL_makeRelativeTo__overload__XMLURL) {
    XMLURL *arg1 ;
    XMLURL *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLURL_makeRelativeTo__overload__XMLURL(self,baseURL);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of XMLURL_makeRelativeTo__overload__XMLURL. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 2 of XMLURL_makeRelativeTo__overload__XMLURL. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            (arg1)->makeRelativeTo((XMLURL const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_new_XMLUri__constructor__uri) {
    XMLCh *arg1 ;
    XMLUri *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_XMLUri__constructor__uri(uriSpec);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of XMLUri, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLUri *)new XMLUri((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLUri);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_XMLUri) {
    XMLUri *arg1 ;
    XMLCh *arg2 ;
    XMLUri *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: new_XMLUri(baseURI,uriSpec);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of new_XMLUri. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of XMLUri, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLUri *)new XMLUri((XMLUri const *)arg1,(XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLUri);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_XMLUri) {
    XMLUri *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_XMLUri(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of delete_XMLUri. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_getScheme) {
    XMLUri *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLUri_getScheme(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_getScheme. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLUri const *)arg1)->getScheme();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_getUserInfo) {
    XMLUri *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLUri_getUserInfo(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_getUserInfo. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLUri const *)arg1)->getUserInfo();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_getHost) {
    XMLUri *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLUri_getHost(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_getHost. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLUri const *)arg1)->getHost();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_getPort) {
    XMLUri *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLUri_getPort(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_getPort. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            result = (int )((XMLUri const *)arg1)->getPort();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_getPath) {
    XMLUri *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLUri_getPath(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_getPath. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLUri const *)arg1)->getPath();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_getQueryString) {
    XMLUri *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLUri_getQueryString(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_getQueryString. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLUri const *)arg1)->getQueryString();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_getFragment) {
    XMLUri *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLUri_getFragment(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_getFragment. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLUri const *)arg1)->getFragment();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_setScheme) {
    XMLUri *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLUri_setScheme(self,newScheme);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_setScheme. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setScheme, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setScheme((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_setUserInfo) {
    XMLUri *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLUri_setUserInfo(self,newUserInfo);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_setUserInfo. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setUserInfo, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setUserInfo((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_setHost) {
    XMLUri *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLUri_setHost(self,newHost);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_setHost. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setHost, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setHost((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_setPort) {
    XMLUri *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLUri_setPort(self,newPort);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_setPort. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        try {
            (arg1)->setPort(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_setPath) {
    XMLUri *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLUri_setPath(self,newPath);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_setPath. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setPath, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setPath((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_setQueryString) {
    XMLUri *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLUri_setQueryString(self,newQueryString);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_setQueryString. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setQueryString, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setQueryString((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLUri_setFragment) {
    XMLUri *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLUri_setFragment(self,newFragment);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLUri) < 0) {
            croak("Type error in argument 1 of XMLUri_setFragment. Expected %s", SWIGTYPE_p_XMLUri->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setFragment, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setFragment((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_QName) {
    QName *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_QName();");
    }
    {
        try {
            result = (QName *)new QName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_QName);
    XSRETURN(argvi);
}

XS(_wrap_delete_QName) {
    QName *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_QName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of delete_QName. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_QName_getPrefix) {
    QName *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: QName_getPrefix(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_getPrefix. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            result = (XMLCh *)(arg1)->getPrefix();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_getLocalPart) {
    QName *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: QName_getLocalPart(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_getLocalPart. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            result = (XMLCh *)(arg1)->getLocalPart();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_getURI) {
    QName *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: QName_getURI(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_getURI. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            result = (unsigned int )(arg1)->getURI();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_QName_getRawName) {
    QName *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: QName_getRawName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_getRawName. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            result = (XMLCh *)(arg1)->getRawName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_setName) {
    QName *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    unsigned int arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: QName_setName(self,prefix,localPart,uriId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_setName. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setName, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of setName, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg4 = (unsigned int ) SvIV(ST(3));
    {
        try {
            (arg1)->setName((XMLCh const *)arg2,(XMLCh const *)arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_setPrefix) {
    QName *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: QName_setPrefix(self,XMLCh const *);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_setPrefix. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setPrefix, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setPrefix((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_setLocalPart) {
    QName *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: QName_setLocalPart(self,XMLCh const *);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_setLocalPart. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setLocalPart, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setLocalPart((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_setNPrefix) {
    QName *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: QName_setNPrefix(self,XMLCh const *,unsigned int const );");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_setNPrefix. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setNPrefix, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->setNPrefix((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_setNLocalPart) {
    QName *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: QName_setNLocalPart(self,XMLCh const *,unsigned int const );");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_setNLocalPart. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setNLocalPart, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->setNLocalPart((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_QName_setURI) {
    QName *arg1 ;
    unsigned int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: QName_setURI(self,unsigned int const );");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_setURI. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            (arg1)->setURI(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_QName_setValues) {
    QName *arg1 ;
    QName *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: QName_setValues(self,qname);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_setValues. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 2 of QName_setValues. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            (arg1)->setValues((QName const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_QName_operator_equal_to) {
    QName *arg1 ;
    QName *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: QName_operator_equal_to(self,QName const &);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_operator_equal_to. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 2 of QName_operator_equal_to. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->operator ==((QName const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_QName_cleanUp) {
    QName *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: QName_cleanUp(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_QName) < 0) {
            croak("Type error in argument 1 of QName_cleanUp. Expected %s", SWIGTYPE_p_QName->name);
        }
    }
    {
        try {
            (arg1)->cleanUp();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HexBin_getDataLength) {
    XMLCh *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: HexBin_getDataLength(hexData);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of HexBin::getDataLength, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (int )HexBin::getDataLength((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_HexBin_isArrayByteHex) {
    XMLCh *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: HexBin_isArrayByteHex(hexData);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of HexBin::isArrayByteHex, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (bool )HexBin::isArrayByteHex((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_Base64_encode) {
    XMLByte *arg1 ;
    unsigned int arg2 ;
    unsigned int *arg3 ;
    XMLByte *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: Base64_encode(inputData,inputLength,outputLength);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLByte) < 0) {
            croak("Type error in argument 1 of Base64_encode. Expected %s", SWIGTYPE_p_XMLByte->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_unsigned_int) < 0) {
            croak("Type error in argument 3 of Base64_encode. Expected %s", SWIGTYPE_p_unsigned_int->name);
        }
    }
    {
        try {
            result = (XMLByte *)Base64::encode((XMLByte const *)arg1,arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLByte);
    XSRETURN(argvi);
}

XS(_wrap_Base64_decode) {
    XMLByte *arg1 ;
    unsigned int *arg2 ;
    XMLByte *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Base64_decode(inputData,outputLength);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLByte) < 0) {
            croak("Type error in argument 1 of Base64_decode. Expected %s", SWIGTYPE_p_XMLByte->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_unsigned_int) < 0) {
            croak("Type error in argument 2 of Base64_decode. Expected %s", SWIGTYPE_p_unsigned_int->name);
        }
    }
    {
        try {
            result = (XMLByte *)Base64::decode((XMLByte const *)arg1,arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLByte);
    XSRETURN(argvi);
}

XS(_wrap_Base64_getDataLength) {
    XMLCh *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Base64_getDataLength(inputData);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of Base64::getDataLength, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (int )Base64::getDataLength((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_XMLException) {
    XMLException *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_XMLException(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of delete_XMLException. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLException_getType) {
    XMLException *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLException_getType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_getType. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLException const *)arg1)->getType();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLException_getCode) {
    XMLException *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLException_getCode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_getCode. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            result = (int )((XMLException const *)arg1)->getCode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLException_getMessage) {
    XMLException *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLException_getMessage(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_getMessage. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            result = (XMLCh *)((XMLException const *)arg1)->getMessage();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLException_getSrcFile) {
    XMLException *arg1 ;
    char *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLException_getSrcFile(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_getSrcFile. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            result = (char *)((XMLException const *)arg1)->getSrcFile();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++), (char *) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLException_getSrcLine) {
    XMLException *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLException_getSrcLine(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_getSrcLine. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            result = (unsigned int )((XMLException const *)arg1)->getSrcLine();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLException_getErrorType) {
    XMLException *arg1 ;
    XMLErrorReporter::ErrTypes result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLException_getErrorType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_getErrorType. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            result = ((XMLException const *)arg1)->getErrorType();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        XMLErrorReporter::ErrTypes * resultobj = new XMLErrorReporter::ErrTypes (result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_XMLErrorReporter__ErrTypes);
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLException_setPosition) {
    XMLException *arg1 ;
    char *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: XMLException_setPosition(self,file,line);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_setPosition. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->setPosition((char const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLException_operator_assignment) {
    XMLException *arg1 ;
    XMLException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLException_operator_assignment(self,toAssign);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 1 of XMLException_operator_assignment. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLException) < 0) {
            croak("Type error in argument 2 of XMLException_operator_assignment. Expected %s", SWIGTYPE_p_XMLException->name);
        }
    }
    {
        try {
            (arg1)->operator =((XMLException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLException_reinitMsgMutex) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLException_reinitMsgMutex();");
    }
    {
        try {
            XMLException::reinitMsgMutex();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLException_reinitMsgLoader) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLException_reinitMsgLoader();");
    }
    {
        try {
            XMLException::reinitMsgLoader();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_XMLValidator) {
    XMLValidator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_XMLValidator(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of delete_XMLValidator. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_checkContent) {
    XMLValidator *arg1 ;
    XMLElementDecl *arg2 ;
    QName **arg3 ;
    unsigned int arg4 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: XMLValidator_checkContent(self,elemDecl,children,childCount);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_checkContent. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLElementDecl) < 0) {
            croak("Type error in argument 2 of XMLValidator_checkContent. Expected %s", SWIGTYPE_p_XMLElementDecl->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_p_QName) < 0) {
            croak("Type error in argument 3 of XMLValidator_checkContent. Expected %s", SWIGTYPE_p_p_QName->name);
        }
    }
    arg4 = (unsigned int ) SvIV(ST(3));
    {
        try {
            result = (int )(arg1)->checkContent(arg2,arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_faultInAttr) {
    XMLValidator *arg1 ;
    XMLAttr *arg2 ;
    XMLAttDef *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: XMLValidator_faultInAttr(self,toFill,attDef);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_faultInAttr. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLAttr) < 0) {
            croak("Type error in argument 2 of XMLValidator_faultInAttr. Expected %s", SWIGTYPE_p_XMLAttr->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLAttDef) < 0) {
            croak("Type error in argument 3 of XMLValidator_faultInAttr. Expected %s", SWIGTYPE_p_XMLAttDef->name);
        }
    }
    {
        try {
            ((XMLValidator const *)arg1)->faultInAttr(*arg2,(XMLAttDef const &)*arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_preContentValidation) {
    XMLValidator *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLValidator_preContentValidation(self,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_preContentValidation. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->preContentValidation(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_postParseValidation) {
    XMLValidator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLValidator_postParseValidation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_postParseValidation. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            (arg1)->postParseValidation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_reset) {
    XMLValidator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLValidator_reset(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_reset. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            (arg1)->reset();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_requiresNamespaces) {
    XMLValidator *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLValidator_requiresNamespaces(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_requiresNamespaces. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            result = (bool )((XMLValidator const *)arg1)->requiresNamespaces();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_validateAttrValue) {
    XMLValidator *arg1 ;
    XMLAttDef *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: XMLValidator_validateAttrValue(self,attDef,attrValue);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_validateAttrValue. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLAttDef) < 0) {
            croak("Type error in argument 2 of XMLValidator_validateAttrValue. Expected %s", SWIGTYPE_p_XMLAttDef->name);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of validateAttrValue, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->validateAttrValue((XMLAttDef const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_validateElement) {
    XMLValidator *arg1 ;
    XMLElementDecl *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLValidator_validateElement(self,elemDef);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_validateElement. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLElementDecl) < 0) {
            croak("Type error in argument 2 of XMLValidator_validateElement. Expected %s", SWIGTYPE_p_XMLElementDecl->name);
        }
    }
    {
        try {
            (arg1)->validateElement((XMLElementDecl const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_getGrammar) {
    XMLValidator *arg1 ;
    Grammar *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLValidator_getGrammar(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_getGrammar. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            result = (Grammar *)((XMLValidator const *)arg1)->getGrammar();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Grammar);
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_setGrammar) {
    XMLValidator *arg1 ;
    Grammar *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLValidator_setGrammar(self,aGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_setGrammar. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 2 of XMLValidator_setGrammar. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    {
        try {
            (arg1)->setGrammar(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_handlesDTD) {
    XMLValidator *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLValidator_handlesDTD(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_handlesDTD. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            result = (bool )((XMLValidator const *)arg1)->handlesDTD();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_handlesSchema) {
    XMLValidator *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLValidator_handlesSchema(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_handlesSchema. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            result = (bool )((XMLValidator const *)arg1)->handlesSchema();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_setScannerInfo) {
    XMLValidator *arg1 ;
    XMLScanner *arg2 ;
    ReaderMgr *arg3 ;
    XMLBufferMgr *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: XMLValidator_setScannerInfo(self,owningScanner,readerMgr,bufMgr);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_setScannerInfo. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 2 of XMLValidator_setScannerInfo. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_ReaderMgr) < 0) {
            croak("Type error in argument 3 of XMLValidator_setScannerInfo. Expected %s", SWIGTYPE_p_ReaderMgr->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_XMLBufferMgr) < 0) {
            croak("Type error in argument 4 of XMLValidator_setScannerInfo. Expected %s", SWIGTYPE_p_XMLBufferMgr->name);
        }
    }
    {
        try {
            (arg1)->setScannerInfo(arg2,arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_setErrorReporter) {
    XMLValidator *arg1 ;
    XMLErrorReporter *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLValidator_setErrorReporter(self,errorReporter);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_setErrorReporter. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLErrorReporter) < 0) {
            croak("Type error in argument 2 of XMLValidator_setErrorReporter. Expected %s", SWIGTYPE_p_XMLErrorReporter->name);
        }
    }
    {
        try {
            (arg1)->setErrorReporter(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_emitError) {
    XMLValidator *arg1 ;
    XMLValid::Codes arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLValidator_emitError(self,toEmit);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_emitError. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        XMLValid::Codes * argp;
        if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_XMLValid__Codes) < 0) {
            croak("Type error in argument 2 of XMLValidator_emitError. Expected %s", SWIGTYPE_p_XMLValid__Codes->name);	
        }
        arg2 = *argp;
    }
    {
        try {
            (arg1)->emitError(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_checkRootElement) {
    XMLValidator *arg1 ;
    unsigned int arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLValidator_checkRootElement(self,elemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 1 of XMLValidator_checkRootElement. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (bool )(arg1)->checkRootElement(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_reinitMsgMutex) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLValidator_reinitMsgMutex();");
    }
    {
        try {
            XMLValidator::reinitMsgMutex();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLValidator_reinitMsgLoader) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLValidator_reinitMsgLoader();");
    }
    {
        try {
            XMLValidator::reinitMsgLoader();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_new_SAXException) {
    SAXException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_SAXException();");
    }
    {
        try {
            result = (SAXException *)new SAXException();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAXException);
    XSRETURN(argvi);
}

XS(_wrap_delete_SAXException) {
    SAXException *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_SAXException(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXException) < 0) {
            croak("Type error in argument 1 of delete_SAXException. Expected %s", SWIGTYPE_p_SAXException->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXException_operator_assignment) {
    SAXException *arg1 ;
    SAXException *arg2 ;
    SAXException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXException_operator_assignment(self,toCopy);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXException) < 0) {
            croak("Type error in argument 1 of SAXException_operator_assignment. Expected %s", SWIGTYPE_p_SAXException->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXException) < 0) {
            croak("Type error in argument 2 of SAXException_operator_assignment. Expected %s", SWIGTYPE_p_SAXException->name);
        }
    }
    {
        try {
            SAXException &_result_ref = (arg1)->operator =((SAXException const &)*arg2);
            result = (SAXException *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAXException);
    XSRETURN(argvi);
}

XS(_wrap_SAXException_getMessage) {
    SAXException *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXException_getMessage(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXException) < 0) {
            croak("Type error in argument 1 of SAXException_getMessage. Expected %s", SWIGTYPE_p_SAXException->name);
        }
    }
    {
        try {
            result = (XMLCh *)((SAXException const *)arg1)->getMessage();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_SAXNotSupportedException) {
    SAXNotSupportedException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_SAXNotSupportedException();");
    }
    {
        try {
            result = (SAXNotSupportedException *)new SAXNotSupportedException();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAXNotSupportedException);
    XSRETURN(argvi);
}

XS(_wrap_new_SAXNotRecognizedException) {
    SAXNotRecognizedException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_SAXNotRecognizedException();");
    }
    {
        try {
            result = (SAXNotRecognizedException *)new SAXNotRecognizedException();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAXNotRecognizedException);
    XSRETURN(argvi);
}

XS(_wrap_new_SAXParseException) {
    XMLCh *arg1 ;
    Locator *arg2 ;
    SAXParseException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: new_SAXParseException(message,locator);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of SAXParseException, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 2 of new_SAXParseException. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            result = (SAXParseException *)new SAXParseException((XMLCh const *)arg1,(Locator const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAXParseException);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_SAXParseException) {
    SAXParseException *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_SAXParseException(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 1 of delete_SAXParseException. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParseException_operator_assignment) {
    SAXParseException *arg1 ;
    SAXParseException *arg2 ;
    SAXParseException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParseException_operator_assignment(self,toAssign);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 1 of SAXParseException_operator_assignment. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of SAXParseException_operator_assignment. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            SAXParseException &_result_ref = (arg1)->operator =((SAXParseException const &)*arg2);
            result = (SAXParseException *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAXParseException);
    XSRETURN(argvi);
}

XS(_wrap_SAXParseException_getColumnNumber) {
    SAXParseException *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParseException_getColumnNumber(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 1 of SAXParseException_getColumnNumber. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            result = (unsigned int )((SAXParseException const *)arg1)->getColumnNumber();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParseException_getLineNumber) {
    SAXParseException *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParseException_getLineNumber(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 1 of SAXParseException_getLineNumber. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            result = (unsigned int )((SAXParseException const *)arg1)->getLineNumber();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParseException_getPublicId) {
    SAXParseException *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParseException_getPublicId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 1 of SAXParseException_getPublicId. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            result = (XMLCh *)((SAXParseException const *)arg1)->getPublicId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAXParseException_getSystemId) {
    SAXParseException *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParseException_getSystemId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 1 of SAXParseException_getSystemId. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            result = (XMLCh *)((SAXParseException const *)arg1)->getSystemId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_ErrorHandler) {
    ErrorHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_ErrorHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 1 of delete_ErrorHandler. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ErrorHandler_warning) {
    ErrorHandler *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: ErrorHandler_warning(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 1 of ErrorHandler_warning. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of ErrorHandler_warning. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->warning((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ErrorHandler_error) {
    ErrorHandler *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: ErrorHandler_error(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 1 of ErrorHandler_error. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of ErrorHandler_error. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->error((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ErrorHandler_fatalError) {
    ErrorHandler *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: ErrorHandler_fatalError(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 1 of ErrorHandler_fatalError. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of ErrorHandler_fatalError. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->fatalError((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ErrorHandler_resetErrors) {
    ErrorHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: ErrorHandler_resetErrors(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 1 of ErrorHandler_resetErrors. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        try {
            (arg1)->resetErrors();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DTDHandler) {
    DTDHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DTDHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DTDHandler) < 0) {
            croak("Type error in argument 1 of delete_DTDHandler. Expected %s", SWIGTYPE_p_DTDHandler->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DTDHandler_notationDecl) {
    DTDHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DTDHandler_notationDecl(self,name,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DTDHandler) < 0) {
            croak("Type error in argument 1 of DTDHandler_notationDecl. Expected %s", SWIGTYPE_p_DTDHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->notationDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DTDHandler_unparsedEntityDecl) {
    DTDHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    XMLCh *arg5 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: DTDHandler_unparsedEntityDecl(self,name,publicId,systemId,notationName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DTDHandler) < 0) {
            croak("Type error in argument 1 of DTDHandler_unparsedEntityDecl. Expected %s", SWIGTYPE_p_DTDHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->unparsedEntityDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(XMLCh const *)arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    {
        delete[] arg5;
    }
    XSRETURN(argvi);
}

XS(_wrap_DTDHandler_resetDocType) {
    DTDHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DTDHandler_resetDocType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DTDHandler) < 0) {
            croak("Type error in argument 1 of DTDHandler_resetDocType. Expected %s", SWIGTYPE_p_DTDHandler->name);
        }
    }
    {
        try {
            (arg1)->resetDocType();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DocumentHandler) {
    DocumentHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DocumentHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of delete_DocumentHandler. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_characters) {
    DocumentHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DocumentHandler_characters(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_characters. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of characters, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->characters((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_endDocument) {
    DocumentHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DocumentHandler_endDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_endDocument. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        try {
            (arg1)->endDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_endElement) {
    DocumentHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DocumentHandler_endElement(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_endElement. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endElement((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_ignorableWhitespace) {
    DocumentHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DocumentHandler_ignorableWhitespace(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_ignorableWhitespace. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of ignorableWhitespace, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->ignorableWhitespace((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_processingInstruction) {
    DocumentHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DocumentHandler_processingInstruction(self,target,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_processingInstruction. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->processingInstruction((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_resetDocument) {
    DocumentHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DocumentHandler_resetDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_resetDocument. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        try {
            (arg1)->resetDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_setDocumentLocator) {
    DocumentHandler *arg1 ;
    Locator *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DocumentHandler_setDocumentLocator(self,locator);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_setDocumentLocator. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 2 of DocumentHandler_setDocumentLocator. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            (arg1)->setDocumentLocator((Locator const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_startDocument) {
    DocumentHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DocumentHandler_startDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_startDocument. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        try {
            (arg1)->startDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DocumentHandler_startElement) {
    DocumentHandler *arg1 ;
    XMLCh *arg2 ;
    AttributeList *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DocumentHandler_startElement(self,name,attrs);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 1 of DocumentHandler_startElement. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 3 of DocumentHandler_startElement. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    {
        try {
            (arg1)->startElement((XMLCh const *)arg2,*arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_EntityResolver) {
    EntityResolver *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_EntityResolver(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_EntityResolver) < 0) {
            croak("Type error in argument 1 of delete_EntityResolver. Expected %s", SWIGTYPE_p_EntityResolver->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_EntityResolver_resolveEntity) {
    EntityResolver *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    InputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: EntityResolver_resolveEntity(self,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_EntityResolver) < 0) {
            croak("Type error in argument 1 of EntityResolver_resolveEntity. Expected %s", SWIGTYPE_p_EntityResolver->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of resolveEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of resolveEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (InputSource *)(arg1)->resolveEntity((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_InputSource);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_AttributeList) {
    AttributeList *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_AttributeList(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 1 of delete_AttributeList. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_AttributeList_getLength) {
    AttributeList *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: AttributeList_getLength(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 1 of AttributeList_getLength. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    {
        try {
            result = (unsigned int )((AttributeList const *)arg1)->getLength();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_AttributeList_getName) {
    AttributeList *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: AttributeList_getName(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 1 of AttributeList_getName. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((AttributeList const *)arg1)->getName(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_AttributeList_getType__overload__index) {
    AttributeList *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: AttributeList_getType__overload__index(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 1 of AttributeList_getType__overload__index. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((AttributeList const *)arg1)->getType(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_AttributeList_getValue__overload__index) {
    AttributeList *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: AttributeList_getValue__overload__index(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 1 of AttributeList_getValue__overload__index. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((AttributeList const *)arg1)->getValue(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_AttributeList_getType) {
    AttributeList *arg1 ;
    XMLCh *arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: AttributeList_getType(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 1 of AttributeList_getType. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)((AttributeList const *)arg1)->getType((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_AttributeList_getValue) {
    AttributeList *arg1 ;
    char *arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: AttributeList_getValue(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 1 of AttributeList_getValue. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    {
        try {
            result = (XMLCh *)((AttributeList const *)arg1)->getValue((char const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_characters) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: HandlerBase_characters(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_characters. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of characters, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->characters((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_endDocument) {
    HandlerBase *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: HandlerBase_endDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_endDocument. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        try {
            (arg1)->endDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_endElement) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: HandlerBase_endElement(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_endElement. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endElement((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_ignorableWhitespace) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: HandlerBase_ignorableWhitespace(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_ignorableWhitespace. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of ignorableWhitespace, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->ignorableWhitespace((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_processingInstruction) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: HandlerBase_processingInstruction(self,target,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_processingInstruction. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->processingInstruction((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_resetDocument) {
    HandlerBase *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: HandlerBase_resetDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_resetDocument. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        try {
            (arg1)->resetDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_setDocumentLocator) {
    HandlerBase *arg1 ;
    Locator *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: HandlerBase_setDocumentLocator(self,locator);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_setDocumentLocator. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 2 of HandlerBase_setDocumentLocator. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            (arg1)->setDocumentLocator((Locator const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_startDocument) {
    HandlerBase *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: HandlerBase_startDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_startDocument. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        try {
            (arg1)->startDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_startElement) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    AttributeList *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: HandlerBase_startElement(self,name,attributes);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_startElement. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_AttributeList) < 0) {
            croak("Type error in argument 3 of HandlerBase_startElement. Expected %s", SWIGTYPE_p_AttributeList->name);
        }
    }
    {
        try {
            (arg1)->startElement((XMLCh const *)arg2,*arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_resolveEntity) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    InputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: HandlerBase_resolveEntity(self,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_resolveEntity. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of resolveEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of resolveEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (InputSource *)(arg1)->resolveEntity((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_InputSource);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_error) {
    HandlerBase *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: HandlerBase_error(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_error. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of HandlerBase_error. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->error((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_fatalError) {
    HandlerBase *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: HandlerBase_fatalError(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_fatalError. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of HandlerBase_fatalError. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->fatalError((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_warning) {
    HandlerBase *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: HandlerBase_warning(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_warning. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of HandlerBase_warning. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->warning((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_resetErrors) {
    HandlerBase *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: HandlerBase_resetErrors(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_resetErrors. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        try {
            (arg1)->resetErrors();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_notationDecl) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: HandlerBase_notationDecl(self,name,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_notationDecl. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->notationDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_resetDocType) {
    HandlerBase *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: HandlerBase_resetDocType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_resetDocType. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        try {
            (arg1)->resetDocType();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_HandlerBase_unparsedEntityDecl) {
    HandlerBase *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    XMLCh *arg5 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: HandlerBase_unparsedEntityDecl(self,name,publicId,systemId,notationName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_HandlerBase) < 0) {
            croak("Type error in argument 1 of HandlerBase_unparsedEntityDecl. Expected %s", SWIGTYPE_p_HandlerBase->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->unparsedEntityDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(XMLCh const *)arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    {
        delete[] arg5;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_Locator) {
    Locator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_Locator(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 1 of delete_Locator. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_Locator_getPublicId) {
    Locator *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Locator_getPublicId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 1 of Locator_getPublicId. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            result = (XMLCh *)((Locator const *)arg1)->getPublicId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Locator_getSystemId) {
    Locator *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Locator_getSystemId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 1 of Locator_getSystemId. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            result = (XMLCh *)((Locator const *)arg1)->getSystemId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Locator_getLineNumber) {
    Locator *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Locator_getLineNumber(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 1 of Locator_getLineNumber. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            result = (int )((Locator const *)arg1)->getLineNumber();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_Locator_getColumnNumber) {
    Locator *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Locator_getColumnNumber(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 1 of Locator_getColumnNumber. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            result = (int )((Locator const *)arg1)->getColumnNumber();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_delete_Attributes) {
    Attributes *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_Attributes(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of delete_Attributes. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getLength) {
    Attributes *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Attributes_getLength(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getLength. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        try {
            result = (unsigned int )((Attributes const *)arg1)->getLength();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getURI) {
    Attributes *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getURI(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getURI. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getURI(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getLocalName) {
    Attributes *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getLocalName(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getLocalName. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getLocalName(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getQName) {
    Attributes *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getQName(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getQName. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getQName(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getType__overload__index) {
    Attributes *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getType__overload__index(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getType__overload__index. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getType(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getValue__overload__index) {
    Attributes *arg1 ;
    unsigned int arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getValue__overload__index(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getValue__overload__index. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getValue(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getIndex) {
    Attributes *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: Attributes_getIndex(self,uri,localPart);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getIndex. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getIndex, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getIndex, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (int )((Attributes const *)arg1)->getIndex((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getIndex__overload__qname) {
    Attributes *arg1 ;
    XMLCh *arg2 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getIndex__overload__qname(self,qName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getIndex__overload__qname. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getIndex, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (int )((Attributes const *)arg1)->getIndex((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getType) {
    Attributes *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: Attributes_getType(self,uri,localPart);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getType. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getType((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getType__overload__qname) {
    Attributes *arg1 ;
    XMLCh *arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getType__overload__qname(self,qName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getType__overload__qname. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getType((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getValue) {
    Attributes *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: Attributes_getValue(self,uri,localPart);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getValue. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getValue, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getValue, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getValue((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_Attributes_getValue__overload__qname) {
    Attributes *arg1 ;
    XMLCh *arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Attributes_getValue__overload__qname(self,qName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 1 of Attributes_getValue__overload__qname. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getValue, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)((Attributes const *)arg1)->getValue((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_ContentHandler) {
    ContentHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_ContentHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of delete_ContentHandler. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_characters) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: ContentHandler_characters(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_characters. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of characters, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->characters((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_endDocument) {
    ContentHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: ContentHandler_endDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_endDocument. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        try {
            (arg1)->endDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_endElement) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: ContentHandler_endElement(self,uri,localname,qname);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_endElement. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endElement((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_ignorableWhitespace) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: ContentHandler_ignorableWhitespace(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_ignorableWhitespace. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of ignorableWhitespace, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->ignorableWhitespace((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_processingInstruction) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: ContentHandler_processingInstruction(self,target,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_processingInstruction. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->processingInstruction((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_setDocumentLocator) {
    ContentHandler *arg1 ;
    Locator *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: ContentHandler_setDocumentLocator(self,locator);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_setDocumentLocator. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 2 of ContentHandler_setDocumentLocator. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            (arg1)->setDocumentLocator((Locator const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_startDocument) {
    ContentHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: ContentHandler_startDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_startDocument. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        try {
            (arg1)->startDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_startElement) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    Attributes *arg5 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: ContentHandler_startElement(self,uri,localname,qname,attrs);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_startElement. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 5 of ContentHandler_startElement. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        try {
            (arg1)->startElement((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(Attributes const &)*arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_startPrefixMapping) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: ContentHandler_startPrefixMapping(self,prefix,uri);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_startPrefixMapping. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startPrefixMapping, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of startPrefixMapping, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->startPrefixMapping((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_endPrefixMapping) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: ContentHandler_endPrefixMapping(self,prefix);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_endPrefixMapping. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endPrefixMapping, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endPrefixMapping((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_ContentHandler_skippedEntity) {
    ContentHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: ContentHandler_skippedEntity(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 1 of ContentHandler_skippedEntity. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of skippedEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->skippedEntity((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_LexicalHandler) {
    LexicalHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_LexicalHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of delete_LexicalHandler. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_LexicalHandler_comment) {
    LexicalHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: LexicalHandler_comment(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of LexicalHandler_comment. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of comment, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->comment((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_LexicalHandler_endCDATA) {
    LexicalHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: LexicalHandler_endCDATA(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of LexicalHandler_endCDATA. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        try {
            (arg1)->endCDATA();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_LexicalHandler_endDTD) {
    LexicalHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: LexicalHandler_endDTD(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of LexicalHandler_endDTD. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        try {
            (arg1)->endDTD();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_LexicalHandler_endEntity) {
    LexicalHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: LexicalHandler_endEntity(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of LexicalHandler_endEntity. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endEntity((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_LexicalHandler_startCDATA) {
    LexicalHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: LexicalHandler_startCDATA(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of LexicalHandler_startCDATA. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        try {
            (arg1)->startCDATA();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_LexicalHandler_startDTD) {
    LexicalHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: LexicalHandler_startDTD(self,name,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of LexicalHandler_startDTD. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startDTD, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of startDTD, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of startDTD, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->startDTD((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_LexicalHandler_startEntity) {
    LexicalHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: LexicalHandler_startEntity(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 1 of LexicalHandler_startEntity. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->startEntity((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_characters) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_characters(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_characters. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of characters, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->characters((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_endDocument) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_endDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_endDocument. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->endDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_endElement) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DefaultHandler_endElement(self,uri,localname,qname);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_endElement. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of endElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endElement((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_ignorableWhitespace) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_ignorableWhitespace(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_ignorableWhitespace. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of ignorableWhitespace, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->ignorableWhitespace((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_processingInstruction) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_processingInstruction(self,target,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_processingInstruction. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of processingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->processingInstruction((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_resetDocument) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_resetDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_resetDocument. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->resetDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_setDocumentLocator) {
    DefaultHandler *arg1 ;
    Locator *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_setDocumentLocator(self,locator);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_setDocumentLocator. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_Locator) < 0) {
            croak("Type error in argument 2 of DefaultHandler_setDocumentLocator. Expected %s", SWIGTYPE_p_Locator->name);
        }
    }
    {
        try {
            (arg1)->setDocumentLocator((Locator const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_startDocument) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_startDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_startDocument. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->startDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_startElement) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    Attributes *arg5 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: DefaultHandler_startElement(self,uri,localname,qname,attrs);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_startElement. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of startElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_Attributes) < 0) {
            croak("Type error in argument 5 of DefaultHandler_startElement. Expected %s", SWIGTYPE_p_Attributes->name);
        }
    }
    {
        try {
            (arg1)->startElement((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(Attributes const &)*arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_startPrefixMapping) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_startPrefixMapping(self,prefix,uri);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_startPrefixMapping. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startPrefixMapping, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of startPrefixMapping, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->startPrefixMapping((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_endPrefixMapping) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_endPrefixMapping(self,prefix);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_endPrefixMapping. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endPrefixMapping, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endPrefixMapping((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_skippedEntity) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_skippedEntity(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_skippedEntity. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of skippedEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->skippedEntity((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_resolveEntity) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    InputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_resolveEntity(self,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_resolveEntity. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of resolveEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of resolveEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (InputSource *)(arg1)->resolveEntity((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_InputSource);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_error) {
    DefaultHandler *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_error(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_error. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of DefaultHandler_error. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->error((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_fatalError) {
    DefaultHandler *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_fatalError(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_fatalError. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of DefaultHandler_fatalError. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->fatalError((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_warning) {
    DefaultHandler *arg1 ;
    SAXParseException *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_warning(self,exception);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_warning. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_SAXParseException) < 0) {
            croak("Type error in argument 2 of DefaultHandler_warning. Expected %s", SWIGTYPE_p_SAXParseException->name);
        }
    }
    {
        try {
            (arg1)->warning((SAXParseException const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_resetErrors) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_resetErrors(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_resetErrors. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->resetErrors();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_notationDecl) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DefaultHandler_notationDecl(self,name,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_notationDecl. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of notationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->notationDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_resetDocType) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_resetDocType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_resetDocType. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->resetDocType();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_unparsedEntityDecl) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    XMLCh *arg5 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: DefaultHandler_unparsedEntityDecl(self,name,publicId,systemId,notationName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_unparsedEntityDecl. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of unparsedEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->unparsedEntityDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(XMLCh const *)arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    {
        delete[] arg5;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_comment) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_comment(self,chars,length);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_comment. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of comment, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->comment((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_endCDATA) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_endCDATA(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_endCDATA. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->endCDATA();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_endDTD) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_endDTD(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_endDTD. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->endDTD();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_endEntity) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_endEntity(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_endEntity. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of endEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->endEntity((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_startCDATA) {
    DefaultHandler *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DefaultHandler_startCDATA(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_startCDATA. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        try {
            (arg1)->startCDATA();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_startDTD) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DefaultHandler_startDTD(self,name,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_startDTD. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startDTD, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of startDTD, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of startDTD, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->startDTD((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_startEntity) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DefaultHandler_startEntity(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_startEntity. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of startEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->startEntity((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_elementDecl) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_elementDecl(self,name,model);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_elementDecl. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of elementDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of elementDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->elementDecl((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_attributeDecl) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    XMLCh *arg5 ;
    XMLCh *arg6 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 6) || (items > 6)) {
        croak("Usage: DefaultHandler_attributeDecl(self,eName,aName,type,mode,value);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_attributeDecl. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of attributeDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of attributeDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of attributeDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of attributeDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(5))||SvIOK(ST(5))||SvNOK(ST(5))) {
            arg6 = Perl2XMLString(ST(5));
        }else {
            croak("Type error in argument 2 of attributeDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->attributeDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(XMLCh const *)arg5,(XMLCh const *)arg6);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    {
        delete[] arg5;
    }
    {
        delete[] arg6;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_internalEntityDecl) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DefaultHandler_internalEntityDecl(self,name,value);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_internalEntityDecl. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of internalEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of internalEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->internalEntityDecl((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DefaultHandler_externalEntityDecl) {
    DefaultHandler *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DefaultHandler_externalEntityDecl(self,name,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_DefaultHandler) < 0) {
            croak("Type error in argument 1 of DefaultHandler_externalEntityDecl. Expected %s", SWIGTYPE_p_DefaultHandler->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of externalEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of externalEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of externalEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->externalEntityDecl((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLReaderFactory_createXMLReader) {
    SAX2XMLReader *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLReaderFactory_createXMLReader();");
    }
    {
        try {
            result = (SAX2XMLReader *)XMLReaderFactory::createXMLReader();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAX2XMLReader);
    XSRETURN(argvi);
}

XS(_wrap_delete_InputSource) {
    InputSource *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_InputSource(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of delete_InputSource. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_InputSource_makeStream) {
    InputSource *arg1 ;
    BinInputStream *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: InputSource_makeStream(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_makeStream. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        try {
            result = (BinInputStream *)((InputSource const *)arg1)->makeStream();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BinInputStream);
    XSRETURN(argvi);
}

XS(_wrap_InputSource_getEncoding) {
    InputSource *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: InputSource_getEncoding(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_getEncoding. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        try {
            result = (XMLCh *)((InputSource const *)arg1)->getEncoding();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_InputSource_getPublicId) {
    InputSource *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: InputSource_getPublicId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_getPublicId. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        try {
            result = (XMLCh *)((InputSource const *)arg1)->getPublicId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_InputSource_getSystemId) {
    InputSource *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: InputSource_getSystemId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_getSystemId. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        try {
            result = (XMLCh *)((InputSource const *)arg1)->getSystemId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_InputSource_getIssueFatalErrorIfNotFound) {
    InputSource *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: InputSource_getIssueFatalErrorIfNotFound(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_getIssueFatalErrorIfNotFound. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        try {
            result = (bool )((InputSource const *)arg1)->getIssueFatalErrorIfNotFound();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_InputSource_setEncoding) {
    InputSource *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: InputSource_setEncoding(self,encodingStr);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_setEncoding. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setEncoding, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setEncoding((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_InputSource_setPublicId) {
    InputSource *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: InputSource_setPublicId(self,publicId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_setPublicId. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setPublicId, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setPublicId((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_InputSource_setSystemId) {
    InputSource *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: InputSource_setSystemId(self,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_setSystemId. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setSystemId, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setSystemId((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_InputSource_setIssueFatalErrorIfNotFound) {
    InputSource *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: InputSource_setIssueFatalErrorIfNotFound(self,flag);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 1 of InputSource_setIssueFatalErrorIfNotFound. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setIssueFatalErrorIfNotFound(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_new_MemBufInputSource) {
    XMLByte *arg1 ;
    STRLEN arg2;

    XMLCh *arg3 ;
    bool arg4 = false ;
    MemBufInputSource *result;
    int argvi = 0;
    dXSARGS;
    
    {
    }
    if ((items < 2) || (items > 3)) {
        croak("Usage: new_MemBufInputSource(srcDocBytes,bufId,adoptBuffer);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            XMLByte *xmlbytes = (XMLByte *)SvPV(ST(0), arg2);
            arg1 = new XMLByte[arg2];
            memcpy(arg1, xmlbytes, arg2);
        }else {
            croak("Type error in argument 2 of new_MemBufInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg3 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of MemBufInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    if (items > 2) {
        arg4 = (bool ) SvIV(ST(2));
    }
    {
        try {
            result = (MemBufInputSource *)new MemBufInputSource((XMLByte const *)arg1,arg2,(XMLCh const *)arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_MemBufInputSource);
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_MemBufInputSource) {
    MemBufInputSource *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_MemBufInputSource(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_MemBufInputSource) < 0) {
            croak("Type error in argument 1 of delete_MemBufInputSource. Expected %s", SWIGTYPE_p_MemBufInputSource->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_MemBufInputSource_makeStream) {
    MemBufInputSource *arg1 ;
    BinInputStream *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: MemBufInputSource_makeStream(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_MemBufInputSource) < 0) {
            croak("Type error in argument 1 of MemBufInputSource_makeStream. Expected %s", SWIGTYPE_p_MemBufInputSource->name);
        }
    }
    {
        try {
            result = (BinInputStream *)((MemBufInputSource const *)arg1)->makeStream();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BinInputStream);
    XSRETURN(argvi);
}

XS(_wrap_MemBufInputSource_setCopyBufToStream) {
    MemBufInputSource *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: MemBufInputSource_setCopyBufToStream(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_MemBufInputSource) < 0) {
            croak("Type error in argument 1 of MemBufInputSource_setCopyBufToStream. Expected %s", SWIGTYPE_p_MemBufInputSource->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setCopyBufToStream(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_new_StdInInputSource) {
    StdInInputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_StdInInputSource();");
    }
    {
        try {
            result = (StdInInputSource *)new StdInInputSource();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_StdInInputSource);
    XSRETURN(argvi);
}

XS(_wrap_delete_StdInInputSource) {
    StdInInputSource *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_StdInInputSource(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_StdInInputSource) < 0) {
            croak("Type error in argument 1 of delete_StdInInputSource. Expected %s", SWIGTYPE_p_StdInInputSource->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_StdInInputSource_makeStream) {
    StdInInputSource *arg1 ;
    BinInputStream *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: StdInInputSource_makeStream(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_StdInInputSource) < 0) {
            croak("Type error in argument 1 of StdInInputSource_makeStream. Expected %s", SWIGTYPE_p_StdInInputSource->name);
        }
    }
    {
        try {
            result = (BinInputStream *)((StdInInputSource const *)arg1)->makeStream();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BinInputStream);
    XSRETURN(argvi);
}

XS(_wrap_new_LocalFileInputSource__constructor__base) {
    XMLCh *arg1 ;
    XMLCh *arg2 ;
    LocalFileInputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: new_LocalFileInputSource__constructor__base(basePath,relativePath);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of LocalFileInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of LocalFileInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (LocalFileInputSource *)new LocalFileInputSource((XMLCh const *)arg1,(XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LocalFileInputSource);
    {
        delete[] arg1;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_LocalFileInputSource) {
    XMLCh *arg1 ;
    LocalFileInputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_LocalFileInputSource(filePath);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of LocalFileInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (LocalFileInputSource *)new LocalFileInputSource((XMLCh const *)arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LocalFileInputSource);
    {
        delete[] arg1;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_LocalFileInputSource) {
    LocalFileInputSource *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_LocalFileInputSource(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LocalFileInputSource) < 0) {
            croak("Type error in argument 1 of delete_LocalFileInputSource. Expected %s", SWIGTYPE_p_LocalFileInputSource->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_LocalFileInputSource_makeStream) {
    LocalFileInputSource *arg1 ;
    BinInputStream *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: LocalFileInputSource_makeStream(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_LocalFileInputSource) < 0) {
            croak("Type error in argument 1 of LocalFileInputSource_makeStream. Expected %s", SWIGTYPE_p_LocalFileInputSource->name);
        }
    }
    {
        try {
            result = (BinInputStream *)((LocalFileInputSource const *)arg1)->makeStream();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BinInputStream);
    XSRETURN(argvi);
}

XS(_wrap_new_URLInputSource) {
    XMLURL *arg1 ;
    URLInputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: new_URLInputSource(urlId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLURL) < 0) {
            croak("Type error in argument 1 of new_URLInputSource. Expected %s", SWIGTYPE_p_XMLURL->name);
        }
    }
    {
        try {
            result = (URLInputSource *)new URLInputSource((XMLURL const &)*arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_URLInputSource);
    XSRETURN(argvi);
}

XS(_wrap_new_URLInputSource__constructor__sys) {
    XMLCh *arg1 ;
    XMLCh *arg2 ;
    URLInputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: new_URLInputSource__constructor__sys(baseId,systemId);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of URLInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of URLInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (URLInputSource *)new URLInputSource((XMLCh const *)arg1,(XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_URLInputSource);
    {
        delete[] arg1;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_URLInputSource__constructor__pub) {
    XMLCh *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    URLInputSource *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: new_URLInputSource__constructor__pub(baseId,systemId,publicId);");
    }
    {
        if (SvPOK(ST(0))||SvIOK(ST(0))||SvNOK(ST(0))) {
            arg1 = Perl2XMLString(ST(0));
        }else {
            croak("Type error in argument 2 of URLInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of URLInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of URLInputSource, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (URLInputSource *)new URLInputSource((XMLCh const *)arg1,(XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_URLInputSource);
    {
        delete[] arg1;
    }
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_URLInputSource) {
    URLInputSource *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_URLInputSource(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_URLInputSource) < 0) {
            croak("Type error in argument 1 of delete_URLInputSource. Expected %s", SWIGTYPE_p_URLInputSource->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_URLInputSource_makeStream) {
    URLInputSource *arg1 ;
    BinInputStream *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: URLInputSource_makeStream(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_URLInputSource) < 0) {
            croak("Type error in argument 1 of URLInputSource_makeStream. Expected %s", SWIGTYPE_p_URLInputSource->name);
        }
    }
    {
        try {
            result = (BinInputStream *)((URLInputSource const *)arg1)->makeStream();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_BinInputStream);
    XSRETURN(argvi);
}

XS(_wrap_URLInputSource_urlSrc) {
    URLInputSource *arg1 ;
    XMLURL *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: URLInputSource_urlSrc(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_URLInputSource) < 0) {
            croak("Type error in argument 1 of URLInputSource_urlSrc. Expected %s", SWIGTYPE_p_URLInputSource->name);
        }
    }
    {
        try {
            XMLURL const &_result_ref = ((URLInputSource const *)arg1)->urlSrc();
            result = (XMLURL *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLURL);
    XSRETURN(argvi);
}

XS(_wrap_delete__ignore___) {
    XMLScanner *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_$ignore(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of delete_$ignore. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_getSrcOffset) {
    XMLScanner *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_getSrcOffset(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_getSrcOffset. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            result = (unsigned int )((XMLScanner const *)arg1)->getSrcOffset();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_getEntityDecl) {
    XMLScanner *arg1 ;
    XMLCh *arg2 ;
    DTDEntityDecl *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_getEntityDecl(self,entName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_getEntityDecl. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getEntityDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (DTDEntityDecl *)(arg1)->getEntityDecl((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_DTDEntityDecl);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_getEmptyNamespaceId) {
    XMLScanner *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_getEmptyNamespaceId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_getEmptyNamespaceId. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            result = (unsigned int )((XMLScanner const *)arg1)->getEmptyNamespaceId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_getUnknownNamespaceId) {
    XMLScanner *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_getUnknownNamespaceId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_getUnknownNamespaceId. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            result = (unsigned int )((XMLScanner const *)arg1)->getUnknownNamespaceId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_getXMLNamespaceId) {
    XMLScanner *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_getXMLNamespaceId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_getXMLNamespaceId. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            result = (unsigned int )((XMLScanner const *)arg1)->getXMLNamespaceId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_getXMLNSNamespaceId) {
    XMLScanner *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_getXMLNSNamespaceId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_getXMLNSNamespaceId. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            result = (unsigned int )((XMLScanner const *)arg1)->getXMLNSNamespaceId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_resolveQName) {
    XMLScanner *arg1 ;
    XMLCh *arg2 ;
    XMLBuffer *arg3 ;
    XMLBuffer *arg4 ;
    ElemStack::MapModes arg5 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: XMLScanner_resolveQName(self,qName,nameBufToFill,prefixBufToFill,mode);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_resolveQName. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of resolveQName, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLBuffer) < 0) {
            croak("Type error in argument 3 of XMLScanner_resolveQName. Expected %s", SWIGTYPE_p_XMLBuffer->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_XMLBuffer) < 0) {
            croak("Type error in argument 4 of XMLScanner_resolveQName. Expected %s", SWIGTYPE_p_XMLBuffer->name);
        }
    }
    {
        ElemStack::MapModes * argp;
        if (SWIG_ConvertPtr(ST(4),(void **) &argp, SWIGTYPE_p_ElemStack__MapModes) < 0) {
            croak("Type error in argument 5 of XMLScanner_resolveQName. Expected %s", SWIGTYPE_p_ElemStack__MapModes->name);	
        }
        arg5 = *argp;
    }
    {
        try {
            result = (unsigned int )(arg1)->resolveQName((XMLCh const *)arg2,*arg3,*arg4,arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_isValidatorFromUser) {
    XMLScanner *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_isValidatorFromUser(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_isValidatorFromUser. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->isValidatorFromUser();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setDocHandler) {
    XMLScanner *arg1 ;
    XMLDocumentHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setDocHandler(self,docHandler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setDocHandler. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLDocumentHandler) < 0) {
            croak("Type error in argument 2 of XMLScanner_setDocHandler. Expected %s", SWIGTYPE_p_XMLDocumentHandler->name);
        }
    }
    {
        try {
            (arg1)->setDocHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setDocTypeHandler) {
    XMLScanner *arg1 ;
    DocTypeHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setDocTypeHandler(self,docTypeHandler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setDocTypeHandler. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_DocTypeHandler) < 0) {
            croak("Type error in argument 2 of XMLScanner_setDocTypeHandler. Expected %s", SWIGTYPE_p_DocTypeHandler->name);
        }
    }
    {
        try {
            (arg1)->setDocTypeHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setDoNamespaces) {
    XMLScanner *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setDoNamespaces(self,doNamespaces);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setDoNamespaces. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setDoNamespaces(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setEntityHandler) {
    XMLScanner *arg1 ;
    XMLEntityHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setEntityHandler(self,docTypeHandler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setEntityHandler. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLEntityHandler) < 0) {
            croak("Type error in argument 2 of XMLScanner_setEntityHandler. Expected %s", SWIGTYPE_p_XMLEntityHandler->name);
        }
    }
    {
        try {
            (arg1)->setEntityHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setEntityResolver) {
    XMLScanner *arg1 ;
    EntityResolver *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setEntityResolver(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setEntityResolver. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_EntityResolver) < 0) {
            croak("Type error in argument 2 of XMLScanner_setEntityResolver. Expected %s", SWIGTYPE_p_EntityResolver->name);
        }
    }
    {
        try {
            (arg1)->setEntityResolver(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setErrorReporter) {
    XMLScanner *arg1 ;
    XMLErrorReporter *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setErrorReporter(self,errHandler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setErrorReporter. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLErrorReporter) < 0) {
            croak("Type error in argument 2 of XMLScanner_setErrorReporter. Expected %s", SWIGTYPE_p_XMLErrorReporter->name);
        }
    }
    {
        try {
            (arg1)->setErrorReporter(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setErrorHandler) {
    XMLScanner *arg1 ;
    ErrorHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setErrorHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setErrorHandler. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 2 of XMLScanner_setErrorHandler. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        try {
            (arg1)->setErrorHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setExitOnFirstFatal) {
    XMLScanner *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setExitOnFirstFatal(self,newValue);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setExitOnFirstFatal. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setExitOnFirstFatal(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setValidationConstraintFatal) {
    XMLScanner *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setValidationConstraintFatal(self,newValue);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setValidationConstraintFatal. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationConstraintFatal(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setValidationScheme) {
    XMLScanner *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setValidationScheme(self,newScheme);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setValidationScheme. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationScheme((XMLScanner::ValSchemes )arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setValidator) {
    XMLScanner *arg1 ;
    XMLValidator *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setValidator(self,valToAdopt);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setValidator. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 2 of XMLScanner_setValidator. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            (arg1)->setValidator(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setDoSchema) {
    XMLScanner *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setDoSchema(self,doSchema);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setDoSchema. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setDoSchema(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setValidationSchemaFullChecking) {
    XMLScanner *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setValidationSchemaFullChecking(self,schemaFullChecking);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setValidationSchemaFullChecking. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationSchemaFullChecking(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setHasNoDTD) {
    XMLScanner *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setHasNoDTD(self,hasNoDTD);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setHasNoDTD. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setHasNoDTD(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setRootElemName) {
    XMLScanner *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_setRootElemName(self,rootElemName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setRootElemName. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setRootElemName, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setRootElemName(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_incrementErrorCount) {
    XMLScanner *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_incrementErrorCount(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_incrementErrorCount. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            (arg1)->incrementErrorCount();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_getDoValidation) {
    XMLScanner *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: XMLScanner_getDoValidation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_getDoValidation. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        try {
            result = (bool )((XMLScanner const *)arg1)->getDoValidation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_setDoValidation) {
    XMLScanner *arg1 ;
    bool arg2 ;
    bool arg3 = true ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) {
        croak("Usage: XMLScanner_setDoValidation(self,validate,setValScheme);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_setDoValidation. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    if (items > 2) {
        arg3 = (bool ) SvIV(ST(2));
    }
    {
        try {
            (arg1)->setDoValidation(arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_scanNext) {
    XMLScanner *arg1 ;
    XMLPScanToken *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_scanNext(self,toFill);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_scanNext. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of XMLScanner_scanNext. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->scanNext(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_scanReset) {
    XMLScanner *arg1 ;
    XMLPScanToken *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_scanReset(self,toFill);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_scanReset. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of XMLScanner_scanReset. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            (arg1)->scanReset(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_checkXMLDecl) {
    XMLScanner *arg1 ;
    bool arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLScanner_checkXMLDecl(self,startWithAngle);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLScanner) < 0) {
            croak("Type error in argument 1 of XMLScanner_checkXMLDecl. Expected %s", SWIGTYPE_p_XMLScanner->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            result = (bool )(arg1)->checkXMLDecl(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_reinitScannerMutex) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLScanner_reinitScannerMutex();");
    }
    {
        try {
            XMLScanner::reinitScannerMutex();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLScanner_reinitMsgLoader) {
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: XMLScanner_reinitMsgLoader();");
    }
    {
        try {
            XMLScanner::reinitMsgLoader();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_new_XMLPScanToken) {
    XMLPScanToken *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_XMLPScanToken();");
    }
    {
        try {
            result = (XMLPScanToken *)new XMLPScanToken();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLPScanToken);
    XSRETURN(argvi);
}

XS(_wrap_delete_XMLPScanToken) {
    XMLPScanToken *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_XMLPScanToken(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 1 of delete_XMLPScanToken. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_XMLPScanToken_operator_assignment) {
    XMLPScanToken *arg1 ;
    XMLPScanToken *arg2 ;
    XMLPScanToken *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: XMLPScanToken_operator_assignment(self,toCopy);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 1 of XMLPScanToken_operator_assignment. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of XMLPScanToken_operator_assignment. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            XMLPScanToken &_result_ref = (arg1)->operator =((XMLPScanToken const &)*arg2);
            result = (XMLPScanToken *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLPScanToken);
    XSRETURN(argvi);
}

XS(_wrap_delete_SAX2XMLReader) {
    SAX2XMLReader *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_SAX2XMLReader(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of delete_SAX2XMLReader. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getErrorCount) {
    SAX2XMLReader *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getErrorCount(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getErrorCount. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (int )((SAX2XMLReader const *)arg1)->getErrorCount();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getContentHandler) {
    SAX2XMLReader *arg1 ;
    ContentHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getContentHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getContentHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (ContentHandler *)((SAX2XMLReader const *)arg1)->getContentHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ContentHandler);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getDTDHandler) {
    SAX2XMLReader *arg1 ;
    DTDHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getDTDHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getDTDHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (DTDHandler *)((SAX2XMLReader const *)arg1)->getDTDHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_DTDHandler);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getEntityResolver) {
    SAX2XMLReader *arg1 ;
    EntityResolver *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getEntityResolver(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getEntityResolver. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (EntityResolver *)((SAX2XMLReader const *)arg1)->getEntityResolver();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_EntityResolver);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getErrorHandler) {
    SAX2XMLReader *arg1 ;
    ErrorHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getErrorHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getErrorHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (ErrorHandler *)((SAX2XMLReader const *)arg1)->getErrorHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ErrorHandler);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getLexicalHandler) {
    SAX2XMLReader *arg1 ;
    LexicalHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getLexicalHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getLexicalHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (LexicalHandler *)((SAX2XMLReader const *)arg1)->getLexicalHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_LexicalHandler);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getDeclarationHandler) {
    SAX2XMLReader *arg1 ;
    DeclHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getDeclarationHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getDeclarationHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (DeclHandler *)((SAX2XMLReader const *)arg1)->getDeclarationHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_DeclHandler);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getFeature) {
    SAX2XMLReader *arg1 ;
    XMLCh *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_getFeature(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getFeature. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getFeature, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (bool )((SAX2XMLReader const *)arg1)->getFeature((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const SAXNotSupportedException& e)
        {
            makeSAXNotSupportedException(e);
        }
        catch (const SAXNotRecognizedException& e)
        {
            makeSAXNotRecognizedException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getProperty) {
    SAX2XMLReader *arg1 ;
    XMLCh *arg2 ;
    void *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_getProperty(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getProperty. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getProperty, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (void *)((SAX2XMLReader const *)arg1)->getProperty((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const SAXNotSupportedException& e)
        {
            makeSAXNotSupportedException(e);
        }
        catch (const SAXNotRecognizedException& e)
        {
            makeSAXNotRecognizedException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getExitOnFirstFatalError) {
    SAX2XMLReader *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getExitOnFirstFatalError(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getExitOnFirstFatalError. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (bool )((SAX2XMLReader const *)arg1)->getExitOnFirstFatalError();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getValidationConstraintFatal) {
    SAX2XMLReader *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getValidationConstraintFatal(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getValidationConstraintFatal. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (bool )((SAX2XMLReader const *)arg1)->getValidationConstraintFatal();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_parse) {
    SAX2XMLReader *arg1 ;
    InputSource *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_parse(self,source);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_parse. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_parse. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        try {
            (arg1)->parse((InputSource const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setContentHandler) {
    SAX2XMLReader *arg1 ;
    ContentHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setContentHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setContentHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ContentHandler) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_setContentHandler. Expected %s", SWIGTYPE_p_ContentHandler->name);
        }
    }
    {
        try {
            (arg1)->setContentHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setDTDHandler) {
    SAX2XMLReader *arg1 ;
    DTDHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setDTDHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setDTDHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_DTDHandler) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_setDTDHandler. Expected %s", SWIGTYPE_p_DTDHandler->name);
        }
    }
    {
        try {
            (arg1)->setDTDHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setEntityResolver) {
    SAX2XMLReader *arg1 ;
    EntityResolver *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setEntityResolver(self,resolver);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setEntityResolver. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_EntityResolver) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_setEntityResolver. Expected %s", SWIGTYPE_p_EntityResolver->name);
        }
    }
    {
        try {
            (arg1)->setEntityResolver(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setErrorHandler) {
    SAX2XMLReader *arg1 ;
    ErrorHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setErrorHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setErrorHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_setErrorHandler. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        try {
            (arg1)->setErrorHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setLexicalHandler) {
    SAX2XMLReader *arg1 ;
    LexicalHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setLexicalHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setLexicalHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_LexicalHandler) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_setLexicalHandler. Expected %s", SWIGTYPE_p_LexicalHandler->name);
        }
    }
    {
        try {
            (arg1)->setLexicalHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setDeclarationHandler) {
    SAX2XMLReader *arg1 ;
    DeclHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setDeclarationHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setDeclarationHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_DeclHandler) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_setDeclarationHandler. Expected %s", SWIGTYPE_p_DeclHandler->name);
        }
    }
    {
        try {
            (arg1)->setDeclarationHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setExitOnFirstFatalError) {
    SAX2XMLReader *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setExitOnFirstFatalError(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setExitOnFirstFatalError. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setExitOnFirstFatalError(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setValidationConstraintFatal) {
    SAX2XMLReader *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setValidationConstraintFatal(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setValidationConstraintFatal. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationConstraintFatal(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setFeature) {
    SAX2XMLReader *arg1 ;
    XMLCh *arg2 ;
    bool arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: SAX2XMLReader_setFeature(self,name,value);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setFeature. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setFeature, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg3 = (bool ) SvIV(ST(2));
    {
        try {
            (arg1)->setFeature((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const SAXNotSupportedException& e)
        {
            makeSAXNotSupportedException(e);
        }
        catch (const SAXNotRecognizedException& e)
        {
            makeSAXNotRecognizedException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setProperty) {
    SAX2XMLReader *arg1 ;
    XMLCh *arg2 ;
    void *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: SAX2XMLReader_setProperty(self,name,value);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setProperty. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setProperty, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, 0) < 0) {
            croak("Type error in argument 3 of SAX2XMLReader_setProperty. Expected %s", SWIGTYPE_p_void->name);
        }
    }
    {
        try {
            (arg1)->setProperty((XMLCh const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const SAXNotSupportedException& e)
        {
            makeSAXNotSupportedException(e);
        }
        catch (const SAXNotRecognizedException& e)
        {
            makeSAXNotRecognizedException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_parseFirst) {
    SAX2XMLReader *arg1 ;
    char *arg2 ;
    XMLPScanToken *arg3 ;
    bool arg4 = false ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) {
        croak("Usage: SAX2XMLReader_parseFirst(self,systemId,toFill,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_parseFirst. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 3 of SAX2XMLReader_parseFirst. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    if (items > 3) {
        arg4 = (bool ) SvIV(ST(3));
    }
    {
        try {
            result = (bool )(arg1)->parseFirst((char const *)arg2,*arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_parseFirst__overload__is) {
    SAX2XMLReader *arg1 ;
    InputSource *arg2 ;
    XMLPScanToken *arg3 ;
    bool arg4 = false ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) {
        croak("Usage: SAX2XMLReader_parseFirst__overload__is(self,source,toFill,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_parseFirst__overload__is. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_parseFirst__overload__is. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 3 of SAX2XMLReader_parseFirst__overload__is. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    if (items > 3) {
        arg4 = (bool ) SvIV(ST(3));
    }
    {
        try {
            result = (bool )(arg1)->parseFirst((InputSource const &)*arg2,*arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_parseNext) {
    SAX2XMLReader *arg1 ;
    XMLPScanToken *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_parseNext(self,token);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_parseNext. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_parseNext. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->parseNext(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_parseReset) {
    SAX2XMLReader *arg1 ;
    XMLPScanToken *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_parseReset(self,token);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_parseReset. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_parseReset. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            (arg1)->parseReset(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_setValidator) {
    SAX2XMLReader *arg1 ;
    XMLValidator *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_setValidator(self,valueToAdopt);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_setValidator. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLValidator) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_setValidator. Expected %s", SWIGTYPE_p_XMLValidator->name);
        }
    }
    {
        try {
            (arg1)->setValidator(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_getValidator) {
    SAX2XMLReader *arg1 ;
    XMLValidator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAX2XMLReader_getValidator(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_getValidator. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        try {
            result = (XMLValidator *)((SAX2XMLReader const *)arg1)->getValidator();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLValidator);
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_installAdvDocHandler) {
    SAX2XMLReader *arg1 ;
    XMLDocumentHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_installAdvDocHandler(self,toInstall);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_installAdvDocHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLDocumentHandler) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_installAdvDocHandler. Expected %s", SWIGTYPE_p_XMLDocumentHandler->name);
        }
    }
    {
        try {
            (arg1)->installAdvDocHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAX2XMLReader_removeAdvDocHandler) {
    SAX2XMLReader *arg1 ;
    XMLDocumentHandler *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAX2XMLReader_removeAdvDocHandler(self,toRemove);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAX2XMLReader) < 0) {
            croak("Type error in argument 1 of SAX2XMLReader_removeAdvDocHandler. Expected %s", SWIGTYPE_p_SAX2XMLReader->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLDocumentHandler) < 0) {
            croak("Type error in argument 2 of SAX2XMLReader_removeAdvDocHandler. Expected %s", SWIGTYPE_p_XMLDocumentHandler->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->removeAdvDocHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_new_SAXParser) {
    XMLValidator *arg1 = 0 ;
    SAXParser *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 1)) {
        croak("Usage: new_SAXParser(valToAdopt);");
    }
    if (items > 0) {
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
                croak("Type error in argument 1 of new_SAXParser. Expected %s", SWIGTYPE_p_XMLValidator->name);
            }
        }
    }
    {
        try {
            result = (SAXParser *)new SAXParser(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_SAXParser);
    XSRETURN(argvi);
}

XS(_wrap_delete_SAXParser) {
    SAXParser *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_SAXParser(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of delete_SAXParser. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getDocumentHandler) {
    SAXParser *arg1 ;
    DocumentHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getDocumentHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getDocumentHandler. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (DocumentHandler *)(arg1)->getDocumentHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_DocumentHandler);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getEntityResolver) {
    SAXParser *arg1 ;
    EntityResolver *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getEntityResolver(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getEntityResolver. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (EntityResolver *)(arg1)->getEntityResolver();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_EntityResolver);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getErrorHandler) {
    SAXParser *arg1 ;
    ErrorHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getErrorHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getErrorHandler. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (ErrorHandler *)(arg1)->getErrorHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ErrorHandler);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getScanner) {
    SAXParser *arg1 ;
    XMLScanner *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getScanner(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getScanner. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            XMLScanner const &_result_ref = ((SAXParser const *)arg1)->getScanner();
            result = (XMLScanner *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLScanner);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getValidator) {
    SAXParser *arg1 ;
    XMLValidator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getValidator(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getValidator. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            XMLValidator const &_result_ref = ((SAXParser const *)arg1)->getValidator();
            result = (XMLValidator *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLValidator);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getValidationScheme) {
    SAXParser *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getValidationScheme(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getValidationScheme. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (int )((SAXParser const *)arg1)->getValidationScheme();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getDoSchema) {
    SAXParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getDoSchema(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getDoSchema. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (bool )((SAXParser const *)arg1)->getDoSchema();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getValidationSchemaFullChecking) {
    SAXParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getValidationSchemaFullChecking(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getValidationSchemaFullChecking. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (bool )((SAXParser const *)arg1)->getValidationSchemaFullChecking();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getErrorCount) {
    SAXParser *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getErrorCount(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getErrorCount. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (int )((SAXParser const *)arg1)->getErrorCount();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getDoNamespaces) {
    SAXParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getDoNamespaces(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getDoNamespaces. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (bool )((SAXParser const *)arg1)->getDoNamespaces();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getExitOnFirstFatalError) {
    SAXParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getExitOnFirstFatalError(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getExitOnFirstFatalError. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (bool )((SAXParser const *)arg1)->getExitOnFirstFatalError();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getValidationConstraintFatal) {
    SAXParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getValidationConstraintFatal(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getValidationConstraintFatal. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (bool )((SAXParser const *)arg1)->getValidationConstraintFatal();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getExternalSchemaLocation) {
    SAXParser *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getExternalSchemaLocation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getExternalSchemaLocation. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (XMLCh *)((SAXParser const *)arg1)->getExternalSchemaLocation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_getExternalNoNamespaceSchemaLocation) {
    SAXParser *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_getExternalNoNamespaceSchemaLocation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_getExternalNoNamespaceSchemaLocation. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            result = (XMLCh *)((SAXParser const *)arg1)->getExternalNoNamespaceSchemaLocation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setDoNamespaces) {
    SAXParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setDoNamespaces(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setDoNamespaces. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setDoNamespaces(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setValidationScheme) {
    SAXParser *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setValidationScheme(self,newScheme);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setValidationScheme. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationScheme((SAXParser::ValSchemes )arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setDoSchema) {
    SAXParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setDoSchema(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setDoSchema. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setDoSchema(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setValidationSchemaFullChecking) {
    SAXParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setValidationSchemaFullChecking(self,schemaFullChecking);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setValidationSchemaFullChecking. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationSchemaFullChecking(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setExitOnFirstFatalError) {
    SAXParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setExitOnFirstFatalError(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setExitOnFirstFatalError. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setExitOnFirstFatalError(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setValidationConstraintFatal) {
    SAXParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setValidationConstraintFatal(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setValidationConstraintFatal. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationConstraintFatal(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setExternalSchemaLocation) {
    SAXParser *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setExternalSchemaLocation(self,schemaLocation);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setExternalSchemaLocation. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setExternalSchemaLocation, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setExternalSchemaLocation((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setExternalNoNamespaceSchemaLocation) {
    SAXParser *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setExternalNoNamespaceSchemaLocation(self,noNamespaceSchemaLocation);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setExternalNoNamespaceSchemaLocation. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setExternalNoNamespaceSchemaLocation, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setExternalNoNamespaceSchemaLocation((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_installAdvDocHandler) {
    SAXParser *arg1 ;
    XMLDocumentHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_installAdvDocHandler(self,toInstall);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_installAdvDocHandler. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLDocumentHandler) < 0) {
            croak("Type error in argument 2 of SAXParser_installAdvDocHandler. Expected %s", SWIGTYPE_p_XMLDocumentHandler->name);
        }
    }
    {
        try {
            (arg1)->installAdvDocHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_removeAdvDocHandler) {
    SAXParser *arg1 ;
    XMLDocumentHandler *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_removeAdvDocHandler(self,toRemove);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_removeAdvDocHandler. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLDocumentHandler) < 0) {
            croak("Type error in argument 2 of SAXParser_removeAdvDocHandler. Expected %s", SWIGTYPE_p_XMLDocumentHandler->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->removeAdvDocHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_parse__overload__is) {
    SAXParser *arg1 ;
    InputSource *arg2 ;
    bool arg3 = false ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) {
        croak("Usage: SAXParser_parse__overload__is(self,source,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_parse__overload__is. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 2 of SAXParser_parse__overload__is. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    if (items > 2) {
        arg3 = (bool ) SvIV(ST(2));
    }
    {
        try {
            (arg1)->parse((InputSource const &)*arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_parse) {
    SAXParser *arg1 ;
    char *arg2 ;
    bool arg3 = false ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) {
        croak("Usage: SAXParser_parse(self,systemId,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_parse. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    if (items > 2) {
        arg3 = (bool ) SvIV(ST(2));
    }
    {
        try {
            (arg1)->parse((char const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setDocumentHandler) {
    SAXParser *arg1 ;
    DocumentHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setDocumentHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setDocumentHandler. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_DocumentHandler) < 0) {
            croak("Type error in argument 2 of SAXParser_setDocumentHandler. Expected %s", SWIGTYPE_p_DocumentHandler->name);
        }
    }
    {
        try {
            (arg1)->setDocumentHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setDTDHandler) {
    SAXParser *arg1 ;
    DTDHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setDTDHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setDTDHandler. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_DTDHandler) < 0) {
            croak("Type error in argument 2 of SAXParser_setDTDHandler. Expected %s", SWIGTYPE_p_DTDHandler->name);
        }
    }
    {
        try {
            (arg1)->setDTDHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setErrorHandler) {
    SAXParser *arg1 ;
    ErrorHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setErrorHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setErrorHandler. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 2 of SAXParser_setErrorHandler. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        try {
            (arg1)->setErrorHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_setEntityResolver) {
    SAXParser *arg1 ;
    EntityResolver *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_setEntityResolver(self,resolver);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_setEntityResolver. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_EntityResolver) < 0) {
            croak("Type error in argument 2 of SAXParser_setEntityResolver. Expected %s", SWIGTYPE_p_EntityResolver->name);
        }
    }
    {
        try {
            (arg1)->setEntityResolver(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_parseFirst) {
    SAXParser *arg1 ;
    char *arg2 ;
    XMLPScanToken *arg3 ;
    bool arg4 = false ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) {
        croak("Usage: SAXParser_parseFirst(self,systemId,toFill,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_parseFirst. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 3 of SAXParser_parseFirst. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    if (items > 3) {
        arg4 = (bool ) SvIV(ST(3));
    }
    {
        try {
            result = (bool )(arg1)->parseFirst((char const *)arg2,*arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_parseFirst__overload__is) {
    SAXParser *arg1 ;
    InputSource *arg2 ;
    XMLPScanToken *arg3 ;
    bool arg4 = false ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) {
        croak("Usage: SAXParser_parseFirst__overload__is(self,source,toFill,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_parseFirst__overload__is. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 2 of SAXParser_parseFirst__overload__is. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 3 of SAXParser_parseFirst__overload__is. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    if (items > 3) {
        arg4 = (bool ) SvIV(ST(3));
    }
    {
        try {
            result = (bool )(arg1)->parseFirst((InputSource const &)*arg2,*arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_parseNext) {
    SAXParser *arg1 ;
    XMLPScanToken *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_parseNext(self,token);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_parseNext. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of SAXParser_parseNext. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->parseNext(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_parseReset) {
    SAXParser *arg1 ;
    XMLPScanToken *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: SAXParser_parseReset(self,token);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_parseReset. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of SAXParser_parseReset. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            (arg1)->parseReset(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_error) {
    SAXParser *arg1 ;
    unsigned int arg2 ;
    XMLCh *arg3 ;
    XMLErrorReporter::ErrTypes arg4 ;
    XMLCh *arg5 ;
    XMLCh *arg6 ;
    XMLCh *arg7 ;
    unsigned int arg8 ;
    unsigned int arg9 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 9) || (items > 9)) {
        croak("Usage: SAXParser_error(self,errCode,msgDomain,errType,errorText,systemId,publicId,lineNum,colNum);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_error. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        XMLErrorReporter::ErrTypes * argp;
        if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_XMLErrorReporter__ErrTypes) < 0) {
            croak("Type error in argument 4 of SAXParser_error. Expected %s", SWIGTYPE_p_XMLErrorReporter__ErrTypes->name);	
        }
        arg4 = *argp;
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(5))||SvIOK(ST(5))||SvNOK(ST(5))) {
            arg6 = Perl2XMLString(ST(5));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(6))||SvIOK(ST(6))||SvNOK(ST(6))) {
            arg7 = Perl2XMLString(ST(6));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg8 = (unsigned int ) SvIV(ST(7));
    arg9 = (unsigned int ) SvIV(ST(8));
    {
        try {
            (arg1)->error(arg2,(XMLCh const *)arg3,arg4,(XMLCh const *)arg5,(XMLCh const *)arg6,(XMLCh const *)arg7,arg8,arg9);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg3;
    }
    {
        delete[] arg5;
    }
    {
        delete[] arg6;
    }
    {
        delete[] arg7;
    }
    XSRETURN(argvi);
}

XS(_wrap_SAXParser_resetErrors) {
    SAXParser *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: SAXParser_resetErrors(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_SAXParser) < 0) {
            croak("Type error in argument 1 of SAXParser_resetErrors. Expected %s", SWIGTYPE_p_SAXParser->name);
        }
    }
    {
        try {
            (arg1)->resetErrors();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_new_DOMParser) {
    XMLValidator *arg1 = 0 ;
    IDOMParser *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 1)) {
        croak("Usage: new_DOMParser(valToAdopt);");
    }
    if (items > 0) {
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_XMLValidator) < 0) {
                croak("Type error in argument 1 of new_DOMParser. Expected %s", SWIGTYPE_p_XMLValidator->name);
            }
        }
    }
    {
        try {
            result = (IDOMParser *)new IDOMParser(arg1);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOMParser);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOMParser) {
    IDOMParser *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOMParser(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of delete_DOMParser. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_reset) {
    IDOMParser *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_reset(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_reset. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            (arg1)->reset();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_resetDocumentPool) {
    IDOMParser *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_resetDocumentPool(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_resetDocumentPool. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            (arg1)->resetDocumentPool();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getDocument) {
    IDOMParser *arg1 ;
    IDOM_Document *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getDocument. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (IDOM_Document *)(arg1)->getDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Document);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getErrorHandler) {
    IDOMParser *arg1 ;
    ErrorHandler *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getErrorHandler(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getErrorHandler. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (ErrorHandler *)(arg1)->getErrorHandler();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ErrorHandler);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getEntityResolver) {
    IDOMParser *arg1 ;
    EntityResolver *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getEntityResolver(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getEntityResolver. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (EntityResolver *)(arg1)->getEntityResolver();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_EntityResolver);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getValidator) {
    IDOMParser *arg1 ;
    XMLValidator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getValidator(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getValidator. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            XMLValidator const &_result_ref = ((IDOMParser const *)arg1)->getValidator();
            result = (XMLValidator *) &_result_ref;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLValidator);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getValidationScheme) {
    IDOMParser *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getValidationScheme(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getValidationScheme. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (int )((IDOMParser const *)arg1)->getValidationScheme();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getDoSchema) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getDoSchema(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getDoSchema. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getDoSchema();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getValidationSchemaFullChecking) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getValidationSchemaFullChecking(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getValidationSchemaFullChecking. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getValidationSchemaFullChecking();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getErrorCount) {
    IDOMParser *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getErrorCount(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getErrorCount. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (int )((IDOMParser const *)arg1)->getErrorCount();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getDoNamespaces) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getDoNamespaces(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getDoNamespaces. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getDoNamespaces();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getExitOnFirstFatalError) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getExitOnFirstFatalError(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getExitOnFirstFatalError. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getExitOnFirstFatalError();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getValidationConstraintFatal) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getValidationConstraintFatal(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getValidationConstraintFatal. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getValidationConstraintFatal();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getExpandEntityReferences) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getExpandEntityReferences(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getExpandEntityReferences. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getExpandEntityReferences();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getCreateEntityReferenceNodes) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getCreateEntityReferenceNodes(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getCreateEntityReferenceNodes. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getCreateEntityReferenceNodes();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getIncludeIgnorableWhitespace) {
    IDOMParser *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getIncludeIgnorableWhitespace(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getIncludeIgnorableWhitespace. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (bool )((IDOMParser const *)arg1)->getIncludeIgnorableWhitespace();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getExternalSchemaLocation) {
    IDOMParser *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getExternalSchemaLocation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getExternalSchemaLocation. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOMParser const *)arg1)->getExternalSchemaLocation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_getExternalNoNamespaceSchemaLocation) {
    IDOMParser *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_getExternalNoNamespaceSchemaLocation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_getExternalNoNamespaceSchemaLocation. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOMParser const *)arg1)->getExternalNoNamespaceSchemaLocation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setErrorHandler) {
    IDOMParser *arg1 ;
    ErrorHandler *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setErrorHandler(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setErrorHandler. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ErrorHandler) < 0) {
            croak("Type error in argument 2 of DOMParser_setErrorHandler. Expected %s", SWIGTYPE_p_ErrorHandler->name);
        }
    }
    {
        try {
            (arg1)->setErrorHandler(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setEntityResolver) {
    IDOMParser *arg1 ;
    EntityResolver *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setEntityResolver(self,handler);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setEntityResolver. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_EntityResolver) < 0) {
            croak("Type error in argument 2 of DOMParser_setEntityResolver. Expected %s", SWIGTYPE_p_EntityResolver->name);
        }
    }
    {
        try {
            (arg1)->setEntityResolver(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setDoNamespaces) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setDoNamespaces(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setDoNamespaces. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setDoNamespaces(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setExitOnFirstFatalError) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setExitOnFirstFatalError(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setExitOnFirstFatalError. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setExitOnFirstFatalError(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setValidationConstraintFatal) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setValidationConstraintFatal(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setValidationConstraintFatal. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationConstraintFatal(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setExpandEntityReferences) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setExpandEntityReferences(self,expand);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setExpandEntityReferences. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setExpandEntityReferences(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setCreateEntityReferenceNodes) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setCreateEntityReferenceNodes(self,create);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setCreateEntityReferenceNodes. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setCreateEntityReferenceNodes(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setIncludeIgnorableWhitespace) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setIncludeIgnorableWhitespace(self,include);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setIncludeIgnorableWhitespace. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setIncludeIgnorableWhitespace(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setValidationScheme) {
    IDOMParser *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setValidationScheme(self,newScheme);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setValidationScheme. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationScheme((IDOMParser::ValSchemes )arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setDoSchema) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setDoSchema(self,newState);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setDoSchema. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setDoSchema(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setValidationSchemaFullChecking) {
    IDOMParser *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setValidationSchemaFullChecking(self,schemaFullChecking);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setValidationSchemaFullChecking. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->setValidationSchemaFullChecking(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setExternalSchemaLocation) {
    IDOMParser *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setExternalSchemaLocation(self,schemaLocation);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setExternalSchemaLocation. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setExternalSchemaLocation, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setExternalSchemaLocation((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_setExternalNoNamespaceSchemaLocation) {
    IDOMParser *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_setExternalNoNamespaceSchemaLocation(self,noNamespaceSchemaLocation);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_setExternalNoNamespaceSchemaLocation. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setExternalNoNamespaceSchemaLocation, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setExternalNoNamespaceSchemaLocation((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_parse__overload__is) {
    IDOMParser *arg1 ;
    InputSource *arg2 ;
    bool arg3 = false ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) {
        croak("Usage: DOMParser_parse__overload__is(self,source,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_parse__overload__is. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 2 of DOMParser_parse__overload__is. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    if (items > 2) {
        arg3 = (bool ) SvIV(ST(2));
    }
    {
        try {
            (arg1)->parse((InputSource const &)*arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_parse) {
    IDOMParser *arg1 ;
    char *arg2 ;
    bool arg3 = false ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 3)) {
        croak("Usage: DOMParser_parse(self,systemId,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_parse. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    if (items > 2) {
        arg3 = (bool ) SvIV(ST(2));
    }
    {
        try {
            (arg1)->parse((char const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_parseFirst) {
    IDOMParser *arg1 ;
    char *arg2 ;
    XMLPScanToken *arg3 ;
    bool arg4 = false ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) {
        croak("Usage: DOMParser_parseFirst(self,systemId,toFill,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_parseFirst. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    if (!SvOK((SV*) ST(1))) arg2 = 0;
    else arg2 = (char *) SvPV(ST(1), PL_na);
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 3 of DOMParser_parseFirst. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    if (items > 3) {
        arg4 = (bool ) SvIV(ST(3));
    }
    {
        try {
            result = (bool )(arg1)->parseFirst((char const *)arg2,*arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_parseFirst__overload__is) {
    IDOMParser *arg1 ;
    InputSource *arg2 ;
    XMLPScanToken *arg3 ;
    bool arg4 = false ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 4)) {
        croak("Usage: DOMParser_parseFirst__overload__is(self,source,toFill,reuseGrammar);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_parseFirst__overload__is. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_InputSource) < 0) {
            croak("Type error in argument 2 of DOMParser_parseFirst__overload__is. Expected %s", SWIGTYPE_p_InputSource->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 3 of DOMParser_parseFirst__overload__is. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    if (items > 3) {
        arg4 = (bool ) SvIV(ST(3));
    }
    {
        try {
            result = (bool )(arg1)->parseFirst((InputSource const &)*arg2,*arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_parseNext) {
    IDOMParser *arg1 ;
    XMLPScanToken *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_parseNext(self,token);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_parseNext. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of DOMParser_parseNext. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->parseNext(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_parseReset) {
    IDOMParser *arg1 ;
    XMLPScanToken *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOMParser_parseReset(self,token);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_parseReset. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLPScanToken) < 0) {
            croak("Type error in argument 2 of DOMParser_parseReset. Expected %s", SWIGTYPE_p_XMLPScanToken->name);
        }
    }
    {
        try {
            (arg1)->parseReset(*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_error) {
    IDOMParser *arg1 ;
    unsigned int arg2 ;
    XMLCh *arg3 ;
    XMLErrorReporter::ErrTypes arg4 ;
    XMLCh *arg5 ;
    XMLCh *arg6 ;
    XMLCh *arg7 ;
    unsigned int arg8 ;
    unsigned int arg9 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 9) || (items > 9)) {
        croak("Usage: DOMParser_error(self,errCode,msgDomain,errType,errorText,systemId,publicId,lineNum,colNum);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_error. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        XMLErrorReporter::ErrTypes * argp;
        if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_XMLErrorReporter__ErrTypes) < 0) {
            croak("Type error in argument 4 of DOMParser_error. Expected %s", SWIGTYPE_p_XMLErrorReporter__ErrTypes->name);	
        }
        arg4 = *argp;
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(5))||SvIOK(ST(5))||SvNOK(ST(5))) {
            arg6 = Perl2XMLString(ST(5));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(6))||SvIOK(ST(6))||SvNOK(ST(6))) {
            arg7 = Perl2XMLString(ST(6));
        }else {
            croak("Type error in argument 2 of error, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg8 = (unsigned int ) SvIV(ST(7));
    arg9 = (unsigned int ) SvIV(ST(8));
    {
        try {
            (arg1)->error(arg2,(XMLCh const *)arg3,arg4,(XMLCh const *)arg5,(XMLCh const *)arg6,(XMLCh const *)arg7,arg8,arg9);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg3;
    }
    {
        delete[] arg5;
    }
    {
        delete[] arg6;
    }
    {
        delete[] arg7;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOMParser_resetErrors) {
    IDOMParser *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOMParser_resetErrors(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOMParser) < 0) {
            croak("Type error in argument 1 of DOMParser_resetErrors. Expected %s", SWIGTYPE_p_IDOMParser->name);
        }
    }
    {
        try {
            (arg1)->resetErrors();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_Grammar) {
    Grammar *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_Grammar(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of delete_Grammar. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_Grammar_getGrammarType) {
    Grammar *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Grammar_getGrammarType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_getGrammarType. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    {
        try {
            result = (int )(arg1)->getGrammarType();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_Grammar_getTargetNamespace) {
    Grammar *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Grammar_getTargetNamespace(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_getTargetNamespace. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    {
        try {
            result = (XMLCh *)((Grammar const *)arg1)->getTargetNamespace();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_Grammar_findOrAddElemDecl) {
    Grammar *arg1 ;
    unsigned int arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    XMLCh *arg5 ;
    unsigned int arg6 ;
    bool *arg7 ;
    XMLElementDecl *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 7) || (items > 7)) {
        croak("Usage: Grammar_findOrAddElemDecl(self,uriId,baseName,prefixName,qName,scope,wasAdded);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_findOrAddElemDecl. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of findOrAddElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of findOrAddElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of findOrAddElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg6 = (unsigned int ) SvIV(ST(5));
    {
        if (SWIG_ConvertPtr(ST(6), (void **) &arg7, SWIGTYPE_p_bool) < 0) {
            croak("Type error in argument 7 of Grammar_findOrAddElemDecl. Expected %s", SWIGTYPE_p_bool->name);
        }
    }
    {
        try {
            result = (XMLElementDecl *)(arg1)->findOrAddElemDecl(arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(XMLCh const *)arg5,arg6,*arg7);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLElementDecl);
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    {
        delete[] arg5;
    }
    XSRETURN(argvi);
}

XS(_wrap_Grammar_getElemId) {
    Grammar *arg1 ;
    unsigned int arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    unsigned int arg5 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: Grammar_getElemId(self,uriId,baseName,qName,scope);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_getElemId. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getElemId, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of getElemId, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg5 = (unsigned int ) SvIV(ST(4));
    {
        try {
            result = (unsigned int )((Grammar const *)arg1)->getElemId(arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_Grammar_getElemDecl) {
    Grammar *arg1 ;
    unsigned int arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    unsigned int arg5 ;
    XMLElementDecl *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: Grammar_getElemDecl(self,uriId,baseName,qName,scope);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_getElemDecl. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of getElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg5 = (unsigned int ) SvIV(ST(4));
    {
        try {
            result = (XMLElementDecl *)((Grammar const *)arg1)->getElemDecl(arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLElementDecl);
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_Grammar_getNotationDecl) {
    Grammar *arg1 ;
    XMLCh *arg2 ;
    XMLNotationDecl *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Grammar_getNotationDecl(self,notName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_getNotationDecl. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getNotationDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLNotationDecl *)((Grammar const *)arg1)->getNotationDecl((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLNotationDecl);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_Grammar_putElemDecl) {
    Grammar *arg1 ;
    unsigned int arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    XMLCh *arg5 ;
    unsigned int arg6 ;
    XMLElementDecl *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 6) || (items > 6)) {
        croak("Usage: Grammar_putElemDecl(self,uriId,baseName,prefixName,qName,scope);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_putElemDecl. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of putElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of putElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(4))||SvIOK(ST(4))||SvNOK(ST(4))) {
            arg5 = Perl2XMLString(ST(4));
        }else {
            croak("Type error in argument 2 of putElemDecl, Expected perl-string.");
            XSRETURN(1);
        }
    }
    arg6 = (unsigned int ) SvIV(ST(5));
    {
        try {
            result = (XMLElementDecl *)(arg1)->putElemDecl(arg2,(XMLCh const *)arg3,(XMLCh const *)arg4,(XMLCh const *)arg5,arg6);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_XMLElementDecl);
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    {
        delete[] arg5;
    }
    XSRETURN(argvi);
}

XS(_wrap_Grammar_putNotationDecl) {
    Grammar *arg1 ;
    XMLNotationDecl *arg2 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: Grammar_putNotationDecl(self,notationDecl);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_putNotationDecl. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_XMLNotationDecl) < 0) {
            croak("Type error in argument 2 of Grammar_putNotationDecl. Expected %s", SWIGTYPE_p_XMLNotationDecl->name);
        }
    }
    {
        try {
            result = (unsigned int )((Grammar const *)arg1)->putNotationDecl(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_Grammar_reset) {
    Grammar *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: Grammar_reset(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_Grammar) < 0) {
            croak("Type error in argument 1 of Grammar_reset. Expected %s", SWIGTYPE_p_Grammar->name);
        }
    }
    {
        try {
            (arg1)->reset();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Node) {
    IDOM_Node *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Node(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of delete_DOM_Node. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getNodeName) {
    IDOM_Node *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getNodeName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getNodeName. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Node const *)arg1)->getNodeName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getNodeValue) {
    IDOM_Node *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getNodeValue(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getNodeValue. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Node const *)arg1)->getNodeValue();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getNodeType) {
    IDOM_Node *arg1 ;
    short result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getNodeType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getNodeType. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (short )((IDOM_Node const *)arg1)->getNodeType();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getParentNode) {
    IDOM_Node *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getParentNode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getParentNode. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Node const *)arg1)->getParentNode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getChildNodes) {
    IDOM_Node *arg1 ;
    IDOM_NodeList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getChildNodes(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getChildNodes. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_NodeList *)((IDOM_Node const *)arg1)->getChildNodes();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeList);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getFirstChild) {
    IDOM_Node *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getFirstChild(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getFirstChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Node const *)arg1)->getFirstChild();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getLastChild) {
    IDOM_Node *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getLastChild(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getLastChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Node const *)arg1)->getLastChild();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getPreviousSibling) {
    IDOM_Node *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getPreviousSibling(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getPreviousSibling. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Node const *)arg1)->getPreviousSibling();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getNextSibling) {
    IDOM_Node *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getNextSibling(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getNextSibling. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Node const *)arg1)->getNextSibling();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getAttributes) {
    IDOM_Node *arg1 ;
    IDOM_NamedNodeMap *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getAttributes(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getAttributes. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_NamedNodeMap *)((IDOM_Node const *)arg1)->getAttributes();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NamedNodeMap);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getOwnerDocument) {
    IDOM_Node *arg1 ;
    IDOM_Document *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getOwnerDocument(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getOwnerDocument. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Document *)((IDOM_Node const *)arg1)->getOwnerDocument();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Document);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_cloneNode) {
    IDOM_Node *arg1 ;
    bool arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Node_cloneNode(self,deep);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_cloneNode. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            result = (IDOM_Node *)((IDOM_Node const *)arg1)->cloneNode(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_insertBefore) {
    IDOM_Node *arg1 ;
    IDOM_Node *arg2 ;
    IDOM_Node *arg3 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Node_insertBefore(self,newChild,refChild);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_insertBefore. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Node_insertBefore. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 3 of DOM_Node_insertBefore. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->insertBefore(arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_replaceChild) {
    IDOM_Node *arg1 ;
    IDOM_Node *arg2 ;
    IDOM_Node *arg3 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Node_replaceChild(self,newChild,oldChild);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_replaceChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Node_replaceChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 3 of DOM_Node_replaceChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->replaceChild(arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_removeChild) {
    IDOM_Node *arg1 ;
    IDOM_Node *arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Node_removeChild(self,oldChild);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_removeChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Node_removeChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->removeChild(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_appendChild) {
    IDOM_Node *arg1 ;
    IDOM_Node *arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Node_appendChild(self,newChild);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_appendChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Node_appendChild. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->appendChild(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_hasChildNodes) {
    IDOM_Node *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_hasChildNodes(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_hasChildNodes. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (bool )((IDOM_Node const *)arg1)->hasChildNodes();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_setNodeValue) {
    IDOM_Node *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Node_setNodeValue(self,nodeValue);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_setNodeValue. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setNodeValue, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setNodeValue((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_normalize) {
    IDOM_Node *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_normalize(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_normalize. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->normalize();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_isSupported) {
    IDOM_Node *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Node_isSupported(self,feature,version);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_isSupported. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of isSupported, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of isSupported, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (bool )((IDOM_Node const *)arg1)->isSupported((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getNamespaceURI) {
    IDOM_Node *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getNamespaceURI(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getNamespaceURI. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Node const *)arg1)->getNamespaceURI();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_getLocalName) {
    IDOM_Node *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_getLocalName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_getLocalName. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Node const *)arg1)->getLocalName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_setPrefix) {
    IDOM_Node *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Node_setPrefix(self,prefix);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_setPrefix. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setPrefix, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setPrefix((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_hasAttributes) {
    IDOM_Node *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Node_hasAttributes(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_hasAttributes. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (bool )((IDOM_Node const *)arg1)->hasAttributes();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_operator_equal_to) {
    IDOM_Node *arg1 ;
    IDOM_Node *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Node_operator_equal_to(self,other);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_operator_equal_to. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Node_operator_equal_to. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (bool )IDOM_Node_operator_ee___(arg1,(IDOM_Node const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Node_operator_not_equal_to) {
    IDOM_Node *arg1 ;
    IDOM_Node *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Node_operator_not_equal_to(self,other);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 1 of DOM_Node_operator_not_equal_to. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Node_operator_not_equal_to. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (bool )IDOM_Node_operator_Ne___(arg1,(IDOM_Node const &)*arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Attr) {
    IDOM_Attr *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Attr(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 1 of delete_DOM_Attr. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Attr_getName) {
    IDOM_Attr *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Attr_getName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 1 of DOM_Attr_getName. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Attr const *)arg1)->getName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Attr_getSpecified) {
    IDOM_Attr *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Attr_getSpecified(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 1 of DOM_Attr_getSpecified. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            result = (bool )((IDOM_Attr const *)arg1)->getSpecified();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Attr_getValue) {
    IDOM_Attr *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Attr_getValue(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 1 of DOM_Attr_getValue. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Attr const *)arg1)->getValue();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Attr_setValue) {
    IDOM_Attr *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Attr_setValue(self,value);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 1 of DOM_Attr_setValue. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setValue, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setValue((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Attr_getOwnerElement) {
    IDOM_Attr *arg1 ;
    IDOM_Element *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Attr_getOwnerElement(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 1 of DOM_Attr_getOwnerElement. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            result = (IDOM_Element *)((IDOM_Attr const *)arg1)->getOwnerElement();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Element);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_CharacterData) {
    IDOM_CharacterData *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_CharacterData(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of delete_DOM_CharacterData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_getData) {
    IDOM_CharacterData *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_CharacterData_getData(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_getData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_CharacterData const *)arg1)->getData();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_getLength) {
    IDOM_CharacterData *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_CharacterData_getLength(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_getLength. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    {
        try {
            result = (unsigned int )((IDOM_CharacterData const *)arg1)->getLength();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_substringData) {
    IDOM_CharacterData *arg1 ;
    unsigned int arg2 ;
    unsigned int arg3 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_CharacterData_substringData(self,offset,count);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_substringData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            result = (XMLCh *)((IDOM_CharacterData const *)arg1)->substringData(arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_appendData) {
    IDOM_CharacterData *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_CharacterData_appendData(self,arg);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_appendData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of appendData, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->appendData((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_insertData) {
    IDOM_CharacterData *arg1 ;
    unsigned int arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_CharacterData_insertData(self,offset,arg);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_insertData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of insertData, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->insertData(arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_deleteData) {
    IDOM_CharacterData *arg1 ;
    unsigned int arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_CharacterData_deleteData(self,offset,count);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_deleteData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->deleteData(arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_replaceData) {
    IDOM_CharacterData *arg1 ;
    unsigned int arg2 ;
    unsigned int arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DOM_CharacterData_replaceData(self,offset,count,arg);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_replaceData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of replaceData, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->replaceData(arg2,arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_CharacterData_setData) {
    IDOM_CharacterData *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_CharacterData_setData(self,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CharacterData) < 0) {
            croak("Type error in argument 1 of DOM_CharacterData_setData. Expected %s", SWIGTYPE_p_IDOM_CharacterData->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setData, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setData((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Text) {
    IDOM_Text *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Text(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Text) < 0) {
            croak("Type error in argument 1 of delete_DOM_Text. Expected %s", SWIGTYPE_p_IDOM_Text->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Text_splitText) {
    IDOM_Text *arg1 ;
    unsigned int arg2 ;
    IDOM_Text *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Text_splitText(self,offset);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Text) < 0) {
            croak("Type error in argument 1 of DOM_Text_splitText. Expected %s", SWIGTYPE_p_IDOM_Text->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (IDOM_Text *)(arg1)->splitText(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Text);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Text_isIgnorableWhitespace) {
    IDOM_Text *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Text_isIgnorableWhitespace(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Text) < 0) {
            croak("Type error in argument 1 of DOM_Text_isIgnorableWhitespace. Expected %s", SWIGTYPE_p_IDOM_Text->name);
        }
    }
    {
        try {
            result = (bool )((IDOM_Text const *)arg1)->isIgnorableWhitespace();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_CDATASection) {
    IDOM_CDATASection *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_CDATASection(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_CDATASection) < 0) {
            croak("Type error in argument 1 of delete_DOM_CDATASection. Expected %s", SWIGTYPE_p_IDOM_CDATASection->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Comment) {
    IDOM_Comment *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Comment(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Comment) < 0) {
            croak("Type error in argument 1 of delete_DOM_Comment. Expected %s", SWIGTYPE_p_IDOM_Comment->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Document) {
    IDOM_Document *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Document(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of delete_DOM_Document. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createEntity) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_Entity *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createEntity(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createEntity. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createEntity, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Entity *)(arg1)->createEntity((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Entity);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createElement) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_Element *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createElement(self,tagName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createElement. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createElement, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Element *)(arg1)->createElement((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Element);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createDocumentFragment) {
    IDOM_Document *arg1 ;
    IDOM_DocumentFragment *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Document_createDocumentFragment(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createDocumentFragment. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        try {
            result = (IDOM_DocumentFragment *)(arg1)->createDocumentFragment();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DocumentFragment);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createTextNode) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_Text *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createTextNode(self,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createTextNode. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createTextNode, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Text *)(arg1)->createTextNode((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Text);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createComment) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_Comment *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createComment(self,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createComment. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createComment, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Comment *)(arg1)->createComment((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Comment);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createCDATASection) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_CDATASection *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createCDATASection(self,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createCDATASection. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createCDATASection, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_CDATASection *)(arg1)->createCDATASection((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_CDATASection);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createDocumentType) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_DocumentType *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createDocumentType(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createDocumentType. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createDocumentType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_DocumentType *)(arg1)->createDocumentType((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DocumentType);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createNotation) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_Notation *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createNotation(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createNotation. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createNotation, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Notation *)(arg1)->createNotation((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Notation);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createProcessingInstruction) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_ProcessingInstruction *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Document_createProcessingInstruction(self,target,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createProcessingInstruction. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createProcessingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of createProcessingInstruction, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_ProcessingInstruction *)(arg1)->createProcessingInstruction((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_ProcessingInstruction);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createAttribute) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_Attr *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createAttribute(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createAttribute. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createAttribute, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Attr *)(arg1)->createAttribute((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Attr);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createEntityReference) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_EntityReference *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_createEntityReference(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createEntityReference. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createEntityReference, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_EntityReference *)(arg1)->createEntityReference((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_EntityReference);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createNodeIterator) {
    IDOM_Document *arg1 ;
    IDOM_Node *arg2 ;
    unsigned long arg3 ;
    IDOM_NodeFilter *arg4 ;
    bool arg5 ;
    IDOM_NodeIterator *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: DOM_Document_createNodeIterator(self,root,whatToShow,filter,entityReferenceExpansion);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createNodeIterator. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Document_createNodeIterator. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    arg3 = (unsigned long ) SvIV(ST(2));
    {
        if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_IDOM_NodeFilter) < 0) {
            croak("Type error in argument 4 of DOM_Document_createNodeIterator. Expected %s", SWIGTYPE_p_IDOM_NodeFilter->name);
        }
    }
    arg5 = (bool ) SvIV(ST(4));
    {
        try {
            result = (IDOM_NodeIterator *)(arg1)->createNodeIterator(arg2,arg3,arg4,arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeIterator);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createTreeWalker) {
    IDOM_Document *arg1 ;
    IDOM_Node *arg2 ;
    unsigned long arg3 ;
    IDOM_NodeFilter *arg4 ;
    bool arg5 ;
    IDOM_TreeWalker *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 5) || (items > 5)) {
        croak("Usage: DOM_Document_createTreeWalker(self,root,whatToShow,filter,entityReferenceExpansion);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createTreeWalker. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Document_createTreeWalker. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    arg3 = (unsigned long ) SvIV(ST(2));
    {
        if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_IDOM_NodeFilter) < 0) {
            croak("Type error in argument 4 of DOM_Document_createTreeWalker. Expected %s", SWIGTYPE_p_IDOM_NodeFilter->name);
        }
    }
    arg5 = (bool ) SvIV(ST(4));
    {
        try {
            result = (IDOM_TreeWalker *)(arg1)->createTreeWalker(arg2,arg3,arg4,arg5);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_TreeWalker);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createRange) {
    IDOM_Document *arg1 ;
    IDOM_Range *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Document_createRange(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createRange. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        try {
            result = (IDOM_Range *)(arg1)->createRange();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Range);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_getDoctype) {
    IDOM_Document *arg1 ;
    IDOM_DocumentType *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Document_getDoctype(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_getDoctype. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        try {
            result = (IDOM_DocumentType *)((IDOM_Document const *)arg1)->getDoctype();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DocumentType);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_getImplementation) {
    IDOM_Document *arg1 ;
    IDOM_DOMImplementation *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Document_getImplementation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_getImplementation. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        try {
            result = (IDOM_DOMImplementation *)((IDOM_Document const *)arg1)->getImplementation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DOMImplementation);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_getDocumentElement) {
    IDOM_Document *arg1 ;
    IDOM_Element *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Document_getDocumentElement(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_getDocumentElement. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        try {
            result = (IDOM_Element *)((IDOM_Document const *)arg1)->getDocumentElement();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Element);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_getElementsByTagName) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_NodeList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_getElementsByTagName(self,tagname);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_getElementsByTagName. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getElementsByTagName, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_NodeList *)((IDOM_Document const *)arg1)->getElementsByTagName((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeList);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_importNode) {
    IDOM_Document *arg1 ;
    IDOM_Node *arg2 ;
    bool arg3 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Document_importNode(self,importedNode,deep);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_importNode. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Document_importNode. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    arg3 = (bool ) SvIV(ST(2));
    {
        try {
            result = (IDOM_Node *)(arg1)->importNode(arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createElementNS) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_Element *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Document_createElementNS(self,namespaceURI,qualifiedName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createElementNS. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createElementNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of createElementNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Element *)(arg1)->createElementNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Element);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_createAttributeNS) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_Attr *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Document_createAttributeNS(self,namespaceURI,qualifiedName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_createAttributeNS. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of createAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Attr *)(arg1)->createAttributeNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Attr);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_getElementsByTagNameNS) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_NodeList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Document_getElementsByTagNameNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_getElementsByTagNameNS. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getElementsByTagNameNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getElementsByTagNameNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_NodeList *)((IDOM_Document const *)arg1)->getElementsByTagNameNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeList);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Document_getElementById) {
    IDOM_Document *arg1 ;
    XMLCh *arg2 ;
    IDOM_Element *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Document_getElementById(self,elementId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Document) < 0) {
            croak("Type error in argument 1 of DOM_Document_getElementById. Expected %s", SWIGTYPE_p_IDOM_Document->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getElementById, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Element *)((IDOM_Document const *)arg1)->getElementById((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Element);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_DocumentFragment) {
    IDOM_DocumentFragment *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_DocumentFragment(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentFragment) < 0) {
            croak("Type error in argument 1 of delete_DOM_DocumentFragment. Expected %s", SWIGTYPE_p_IDOM_DocumentFragment->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_DocumentType) {
    IDOM_DocumentType *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_DocumentType(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 1 of delete_DOM_DocumentType. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_DocumentType_getName) {
    IDOM_DocumentType *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DocumentType_getName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 1 of DOM_DocumentType_getName. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_DocumentType const *)arg1)->getName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_DocumentType_getEntities) {
    IDOM_DocumentType *arg1 ;
    IDOM_NamedNodeMap *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DocumentType_getEntities(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 1 of DOM_DocumentType_getEntities. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            result = (IDOM_NamedNodeMap *)((IDOM_DocumentType const *)arg1)->getEntities();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NamedNodeMap);
    XSRETURN(argvi);
}

XS(_wrap_DOM_DocumentType_getNotations) {
    IDOM_DocumentType *arg1 ;
    IDOM_NamedNodeMap *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DocumentType_getNotations(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 1 of DOM_DocumentType_getNotations. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            result = (IDOM_NamedNodeMap *)((IDOM_DocumentType const *)arg1)->getNotations();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NamedNodeMap);
    XSRETURN(argvi);
}

XS(_wrap_DOM_DocumentType_getPublicId) {
    IDOM_DocumentType *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DocumentType_getPublicId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 1 of DOM_DocumentType_getPublicId. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_DocumentType const *)arg1)->getPublicId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_DocumentType_getSystemId) {
    IDOM_DocumentType *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DocumentType_getSystemId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 1 of DOM_DocumentType_getSystemId. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_DocumentType const *)arg1)->getSystemId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_DocumentType_getInternalSubset) {
    IDOM_DocumentType *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DocumentType_getInternalSubset(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 1 of DOM_DocumentType_getInternalSubset. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_DocumentType const *)arg1)->getInternalSubset();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_new_DOM_DOMException) {
    IDOM_DOMException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_DOM_DOMException();");
    }
    {
        try {
            result = (IDOM_DOMException *)new IDOM_DOMException();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DOMException);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_DOMException) {
    IDOM_DOMException *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_DOMException(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMException) < 0) {
            croak("Type error in argument 1 of delete_DOM_DOMException. Expected %s", SWIGTYPE_p_IDOM_DOMException->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMException_code_set) {
    IDOM_DOMException *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_DOMException_code_set(self,code);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMException) < 0) {
            croak("Type error in argument 1 of DOM_DOMException_code_set. Expected %s", SWIGTYPE_p_IDOM_DOMException->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        try {
            if (arg1) arg1->code = (IDOM_DOMException::ExceptionCode )arg2;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMException_code_get) {
    IDOM_DOMException *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DOMException_code_get(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMException) < 0) {
            croak("Type error in argument 1 of DOM_DOMException_code_get. Expected %s", SWIGTYPE_p_IDOM_DOMException->name);
        }
    }
    {
        try {
            result = (int ) (arg1->code);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMException_msg_set) {
    IDOM_DOMException *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_DOMException_msg_set(self,msg);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMException) < 0) {
            croak("Type error in argument 1 of DOM_DOMException_msg_set. Expected %s", SWIGTYPE_p_IDOM_DOMException->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of msg, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            if (arg1) arg1->msg = (XMLCh const *)arg2;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMException_msg_get) {
    IDOM_DOMException *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_DOMException_msg_get(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMException) < 0) {
            croak("Type error in argument 1 of DOM_DOMException_msg_get. Expected %s", SWIGTYPE_p_IDOM_DOMException->name);
        }
    }
    {
        try {
            result = (XMLCh *) (arg1->msg);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMImplementation_getImplementation) {
    IDOM_DOMImplementation *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: DOM_DOMImplementation_getImplementation();");
    }
    {
        try {
            result = (IDOM_DOMImplementation *)IDOM_DOMImplementation::getImplementation();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DOMImplementation);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_DOMImplementation) {
    IDOM_DOMImplementation *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_DOMImplementation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMImplementation) < 0) {
            croak("Type error in argument 1 of delete_DOM_DOMImplementation. Expected %s", SWIGTYPE_p_IDOM_DOMImplementation->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMImplementation_hasFeature) {
    IDOM_DOMImplementation *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_DOMImplementation_hasFeature(self,feature,version);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMImplementation) < 0) {
            croak("Type error in argument 1 of DOM_DOMImplementation_hasFeature. Expected %s", SWIGTYPE_p_IDOM_DOMImplementation->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of hasFeature, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of hasFeature, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (bool )(arg1)->hasFeature((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMImplementation_createDocumentType) {
    IDOM_DOMImplementation *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    IDOM_DocumentType *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DOM_DOMImplementation_createDocumentType(self,qualifiedName,publicId,systemId);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMImplementation) < 0) {
            croak("Type error in argument 1 of DOM_DOMImplementation_createDocumentType. Expected %s", SWIGTYPE_p_IDOM_DOMImplementation->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createDocumentType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of createDocumentType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of createDocumentType, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_DocumentType *)(arg1)->createDocumentType((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DocumentType);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_DOMImplementation_createDocument) {
    IDOM_DOMImplementation *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_DocumentType *arg4 ;
    IDOM_Document *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DOM_DOMImplementation_createDocument(self,namespaceURI,qualifiedName,doctype);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_DOMImplementation) < 0) {
            croak("Type error in argument 1 of DOM_DOMImplementation_createDocument. Expected %s", SWIGTYPE_p_IDOM_DOMImplementation->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of createDocument, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of createDocument, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_IDOM_DocumentType) < 0) {
            croak("Type error in argument 4 of DOM_DOMImplementation_createDocument. Expected %s", SWIGTYPE_p_IDOM_DocumentType->name);
        }
    }
    {
        try {
            result = (IDOM_Document *)(arg1)->createDocument((XMLCh const *)arg2,(XMLCh const *)arg3,arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Document);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Element) {
    IDOM_Element *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Element(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of delete_DOM_Element. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_getTagName) {
    IDOM_Element *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Element_getTagName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_getTagName. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Element const *)arg1)->getTagName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_getAttribute) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_getAttribute(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_getAttribute. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getAttribute, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Element const *)arg1)->getAttribute((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_getAttributeNode) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    IDOM_Attr *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_getAttributeNode(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_getAttributeNode. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getAttributeNode, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Attr *)((IDOM_Element const *)arg1)->getAttributeNode((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Attr);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_getElementsByTagName) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    IDOM_NodeList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_getElementsByTagName(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_getElementsByTagName. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getElementsByTagName, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_NodeList *)((IDOM_Element const *)arg1)->getElementsByTagName((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeList);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_setAttribute) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Element_setAttribute(self,name,value);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_setAttribute. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setAttribute, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of setAttribute, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setAttribute((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_setAttributeNode) {
    IDOM_Element *arg1 ;
    IDOM_Attr *arg2 ;
    IDOM_Attr *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_setAttributeNode(self,newAttr);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_setAttributeNode. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 2 of DOM_Element_setAttributeNode. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            result = (IDOM_Attr *)(arg1)->setAttributeNode(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Attr);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_removeAttributeNode) {
    IDOM_Element *arg1 ;
    IDOM_Attr *arg2 ;
    IDOM_Attr *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_removeAttributeNode(self,oldAttr);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_removeAttributeNode. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 2 of DOM_Element_removeAttributeNode. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            result = (IDOM_Attr *)(arg1)->removeAttributeNode(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Attr);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_removeAttribute) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_removeAttribute(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_removeAttribute. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of removeAttribute, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->removeAttribute((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_getAttributeNS) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Element_getAttributeNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_getAttributeNS. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Element const *)arg1)->getAttributeNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_setAttributeNS) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    XMLCh *arg4 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 4) || (items > 4)) {
        croak("Usage: DOM_Element_setAttributeNS(self,namespaceURI,qualifiedName,value);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_setAttributeNS. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of setAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(3))||SvIOK(ST(3))||SvNOK(ST(3))) {
            arg4 = Perl2XMLString(ST(3));
        }else {
            croak("Type error in argument 2 of setAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setAttributeNS((XMLCh const *)arg2,(XMLCh const *)arg3,(XMLCh const *)arg4);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    {
        delete[] arg4;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_removeAttributeNS) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Element_removeAttributeNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_removeAttributeNS. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of removeAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of removeAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->removeAttributeNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_getAttributeNodeNS) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_Attr *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Element_getAttributeNodeNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_getAttributeNodeNS. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getAttributeNodeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getAttributeNodeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Attr *)((IDOM_Element const *)arg1)->getAttributeNodeNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Attr);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_setAttributeNodeNS) {
    IDOM_Element *arg1 ;
    IDOM_Attr *arg2 ;
    IDOM_Attr *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_setAttributeNodeNS(self,newAttr);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_setAttributeNodeNS. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Attr) < 0) {
            croak("Type error in argument 2 of DOM_Element_setAttributeNodeNS. Expected %s", SWIGTYPE_p_IDOM_Attr->name);
        }
    }
    {
        try {
            result = (IDOM_Attr *)(arg1)->setAttributeNodeNS(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Attr);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_getElementsByTagNameNS) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_NodeList *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Element_getElementsByTagNameNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_getElementsByTagNameNS. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getElementsByTagNameNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getElementsByTagNameNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_NodeList *)((IDOM_Element const *)arg1)->getElementsByTagNameNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeList);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_hasAttribute) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Element_hasAttribute(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_hasAttribute. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of hasAttribute, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (bool )((IDOM_Element const *)arg1)->hasAttribute((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Element_hasAttributeNS) {
    IDOM_Element *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Element_hasAttributeNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Element) < 0) {
            croak("Type error in argument 1 of DOM_Element_hasAttributeNS. Expected %s", SWIGTYPE_p_IDOM_Element->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of hasAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of hasAttributeNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (bool )((IDOM_Element const *)arg1)->hasAttributeNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Entity) {
    IDOM_Entity *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Entity(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Entity) < 0) {
            croak("Type error in argument 1 of delete_DOM_Entity. Expected %s", SWIGTYPE_p_IDOM_Entity->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Entity_getPublicId) {
    IDOM_Entity *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Entity_getPublicId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Entity) < 0) {
            croak("Type error in argument 1 of DOM_Entity_getPublicId. Expected %s", SWIGTYPE_p_IDOM_Entity->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Entity const *)arg1)->getPublicId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Entity_getSystemId) {
    IDOM_Entity *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Entity_getSystemId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Entity) < 0) {
            croak("Type error in argument 1 of DOM_Entity_getSystemId. Expected %s", SWIGTYPE_p_IDOM_Entity->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Entity const *)arg1)->getSystemId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Entity_getNotationName) {
    IDOM_Entity *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Entity_getNotationName(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Entity) < 0) {
            croak("Type error in argument 1 of DOM_Entity_getNotationName. Expected %s", SWIGTYPE_p_IDOM_Entity->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Entity const *)arg1)->getNotationName();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_EntityReference) {
    IDOM_EntityReference *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_EntityReference(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_EntityReference) < 0) {
            croak("Type error in argument 1 of delete_DOM_EntityReference. Expected %s", SWIGTYPE_p_IDOM_EntityReference->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_NamedNodeMap) {
    IDOM_NamedNodeMap *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_NamedNodeMap(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of delete_DOM_NamedNodeMap. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_setNamedItem) {
    IDOM_NamedNodeMap *arg1 ;
    IDOM_Node *arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_NamedNodeMap_setNamedItem(self,arg);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_setNamedItem. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_NamedNodeMap_setNamedItem. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->setNamedItem(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_item) {
    IDOM_NamedNodeMap *arg1 ;
    unsigned int arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_NamedNodeMap_item(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_item. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (IDOM_Node *)((IDOM_NamedNodeMap const *)arg1)->item(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_getNamedItem) {
    IDOM_NamedNodeMap *arg1 ;
    XMLCh *arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_NamedNodeMap_getNamedItem(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_getNamedItem. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getNamedItem, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_NamedNodeMap const *)arg1)->getNamedItem((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_getLength) {
    IDOM_NamedNodeMap *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NamedNodeMap_getLength(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_getLength. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        try {
            result = (unsigned int )((IDOM_NamedNodeMap const *)arg1)->getLength();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_removeNamedItem) {
    IDOM_NamedNodeMap *arg1 ;
    XMLCh *arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_NamedNodeMap_removeNamedItem(self,name);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_removeNamedItem. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of removeNamedItem, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->removeNamedItem((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_getNamedItemNS) {
    IDOM_NamedNodeMap *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_NamedNodeMap_getNamedItemNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_getNamedItemNS. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of getNamedItemNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of getNamedItemNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_NamedNodeMap const *)arg1)->getNamedItemNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_setNamedItemNS) {
    IDOM_NamedNodeMap *arg1 ;
    IDOM_Node *arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_NamedNodeMap_setNamedItemNS(self,arg);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_setNamedItemNS. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_NamedNodeMap_setNamedItemNS. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->setNamedItemNS(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NamedNodeMap_removeNamedItemNS) {
    IDOM_NamedNodeMap *arg1 ;
    XMLCh *arg2 ;
    XMLCh *arg3 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_NamedNodeMap_removeNamedItemNS(self,namespaceURI,localName);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NamedNodeMap) < 0) {
            croak("Type error in argument 1 of DOM_NamedNodeMap_removeNamedItemNS. Expected %s", SWIGTYPE_p_IDOM_NamedNodeMap->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of removeNamedItemNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        if (SvPOK(ST(2))||SvIOK(ST(2))||SvNOK(ST(2))) {
            arg3 = Perl2XMLString(ST(2));
        }else {
            croak("Type error in argument 2 of removeNamedItemNS, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->removeNamedItemNS((XMLCh const *)arg2,(XMLCh const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    {
        delete[] arg2;
    }
    {
        delete[] arg3;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeFilter_acceptNode) {
    IDOM_NodeFilter *arg1 ;
    IDOM_Node *arg2 ;
    short result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_NodeFilter_acceptNode(self,node);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeFilter) < 0) {
            croak("Type error in argument 1 of DOM_NodeFilter_acceptNode. Expected %s", SWIGTYPE_p_IDOM_NodeFilter->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_NodeFilter_acceptNode. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            result = (short )((IDOM_NodeFilter const *)arg1)->acceptNode((IDOM_Node const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeIterator_getRoot) {
    IDOM_NodeIterator *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeIterator_getRoot(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeIterator) < 0) {
            croak("Type error in argument 1 of DOM_NodeIterator_getRoot. Expected %s", SWIGTYPE_p_IDOM_NodeIterator->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->getRoot();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeIterator_getWhatToShow) {
    IDOM_NodeIterator *arg1 ;
    unsigned long result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeIterator_getWhatToShow(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeIterator) < 0) {
            croak("Type error in argument 1 of DOM_NodeIterator_getWhatToShow. Expected %s", SWIGTYPE_p_IDOM_NodeIterator->name);
        }
    }
    {
        try {
            result = (unsigned long )(arg1)->getWhatToShow();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeIterator_getFilter) {
    IDOM_NodeIterator *arg1 ;
    IDOM_NodeFilter *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeIterator_getFilter(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeIterator) < 0) {
            croak("Type error in argument 1 of DOM_NodeIterator_getFilter. Expected %s", SWIGTYPE_p_IDOM_NodeIterator->name);
        }
    }
    {
        try {
            result = (IDOM_NodeFilter *)(arg1)->getFilter();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeFilter);
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeIterator_getExpandEntityReferences) {
    IDOM_NodeIterator *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeIterator_getExpandEntityReferences(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeIterator) < 0) {
            croak("Type error in argument 1 of DOM_NodeIterator_getExpandEntityReferences. Expected %s", SWIGTYPE_p_IDOM_NodeIterator->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->getExpandEntityReferences();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeIterator_nextNode) {
    IDOM_NodeIterator *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeIterator_nextNode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeIterator) < 0) {
            croak("Type error in argument 1 of DOM_NodeIterator_nextNode. Expected %s", SWIGTYPE_p_IDOM_NodeIterator->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->nextNode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeIterator_previousNode) {
    IDOM_NodeIterator *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeIterator_previousNode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeIterator) < 0) {
            croak("Type error in argument 1 of DOM_NodeIterator_previousNode. Expected %s", SWIGTYPE_p_IDOM_NodeIterator->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->previousNode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeIterator_detach) {
    IDOM_NodeIterator *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeIterator_detach(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeIterator) < 0) {
            croak("Type error in argument 1 of DOM_NodeIterator_detach. Expected %s", SWIGTYPE_p_IDOM_NodeIterator->name);
        }
    }
    {
        try {
            (arg1)->detach();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_NodeList) {
    IDOM_NodeList *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_NodeList(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeList) < 0) {
            croak("Type error in argument 1 of delete_DOM_NodeList. Expected %s", SWIGTYPE_p_IDOM_NodeList->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeList_item) {
    IDOM_NodeList *arg1 ;
    unsigned int arg2 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_NodeList_item(self,index);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeList) < 0) {
            croak("Type error in argument 1 of DOM_NodeList_item. Expected %s", SWIGTYPE_p_IDOM_NodeList->name);
        }
    }
    arg2 = (unsigned int ) SvIV(ST(1));
    {
        try {
            result = (IDOM_Node *)(arg1)->item(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_NodeList_getLength) {
    IDOM_NodeList *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_NodeList_getLength(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_NodeList) < 0) {
            croak("Type error in argument 1 of DOM_NodeList_getLength. Expected %s", SWIGTYPE_p_IDOM_NodeList->name);
        }
    }
    {
        try {
            result = (unsigned int )(arg1)->getLength();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Notation) {
    IDOM_Notation *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Notation(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Notation) < 0) {
            croak("Type error in argument 1 of delete_DOM_Notation. Expected %s", SWIGTYPE_p_IDOM_Notation->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Notation_getPublicId) {
    IDOM_Notation *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Notation_getPublicId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Notation) < 0) {
            croak("Type error in argument 1 of DOM_Notation_getPublicId. Expected %s", SWIGTYPE_p_IDOM_Notation->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Notation const *)arg1)->getPublicId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Notation_getSystemId) {
    IDOM_Notation *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Notation_getSystemId(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Notation) < 0) {
            croak("Type error in argument 1 of DOM_Notation_getSystemId. Expected %s", SWIGTYPE_p_IDOM_Notation->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Notation const *)arg1)->getSystemId();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_ProcessingInstruction) {
    IDOM_ProcessingInstruction *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_ProcessingInstruction(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_ProcessingInstruction) < 0) {
            croak("Type error in argument 1 of delete_DOM_ProcessingInstruction. Expected %s", SWIGTYPE_p_IDOM_ProcessingInstruction->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_ProcessingInstruction_getTarget) {
    IDOM_ProcessingInstruction *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_ProcessingInstruction_getTarget(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_ProcessingInstruction) < 0) {
            croak("Type error in argument 1 of DOM_ProcessingInstruction_getTarget. Expected %s", SWIGTYPE_p_IDOM_ProcessingInstruction->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_ProcessingInstruction const *)arg1)->getTarget();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_ProcessingInstruction_getData) {
    IDOM_ProcessingInstruction *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_ProcessingInstruction_getData(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_ProcessingInstruction) < 0) {
            croak("Type error in argument 1 of DOM_ProcessingInstruction_getData. Expected %s", SWIGTYPE_p_IDOM_ProcessingInstruction->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_ProcessingInstruction const *)arg1)->getData();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_ProcessingInstruction_setData) {
    IDOM_ProcessingInstruction *arg1 ;
    XMLCh *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_ProcessingInstruction_setData(self,data);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_ProcessingInstruction) < 0) {
            croak("Type error in argument 1 of DOM_ProcessingInstruction_setData. Expected %s", SWIGTYPE_p_IDOM_ProcessingInstruction->name);
        }
    }
    {
        if (SvPOK(ST(1))||SvIOK(ST(1))||SvNOK(ST(1))) {
            arg2 = Perl2XMLString(ST(1));
        }else {
            croak("Type error in argument 2 of setData, Expected perl-string.");
            XSRETURN(1);
        }
    }
    {
        try {
            (arg1)->setData((XMLCh const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    {
        delete[] arg2;
    }
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_Range) {
    IDOM_Range *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_Range(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of delete_DOM_Range. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_getStartContainer) {
    IDOM_Range *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_getStartContainer(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_getStartContainer. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Range const *)arg1)->getStartContainer();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_getStartOffset) {
    IDOM_Range *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_getStartOffset(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_getStartOffset. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (unsigned int )((IDOM_Range const *)arg1)->getStartOffset();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_getEndContainer) {
    IDOM_Range *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_getEndContainer(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_getEndContainer. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Range const *)arg1)->getEndContainer();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_getEndOffset) {
    IDOM_Range *arg1 ;
    unsigned int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_getEndOffset(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_getEndOffset. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (unsigned int )((IDOM_Range const *)arg1)->getEndOffset();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_getCollapsed) {
    IDOM_Range *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_getCollapsed(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_getCollapsed. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (bool )((IDOM_Range const *)arg1)->getCollapsed();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_getCommonAncestorContainer) {
    IDOM_Range *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_getCommonAncestorContainer(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_getCommonAncestorContainer. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)((IDOM_Range const *)arg1)->getCommonAncestorContainer();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_setStart) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Range_setStart(self,parent,offset);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_setStart. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_setStart. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->setStart((IDOM_Node const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_setEnd) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    unsigned int arg3 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Range_setEnd(self,parent,offset);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_setEnd. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_setEnd. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    arg3 = (unsigned int ) SvIV(ST(2));
    {
        try {
            (arg1)->setEnd((IDOM_Node const *)arg2,arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_setStartBefore) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_setStartBefore(self,refNode);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_setStartBefore. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_setStartBefore. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->setStartBefore((IDOM_Node const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_setStartAfter) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_setStartAfter(self,refNode);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_setStartAfter. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_setStartAfter. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->setStartAfter((IDOM_Node const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_setEndBefore) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_setEndBefore(self,refNode);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_setEndBefore. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_setEndBefore. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->setEndBefore((IDOM_Node const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_setEndAfter) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_setEndAfter(self,refNode);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_setEndAfter. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_setEndAfter. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->setEndAfter((IDOM_Node const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_collapse) {
    IDOM_Range *arg1 ;
    bool arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_collapse(self,toStart);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_collapse. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    arg2 = (bool ) SvIV(ST(1));
    {
        try {
            (arg1)->collapse(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_selectNode) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_selectNode(self,node);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_selectNode. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_selectNode. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->selectNode((IDOM_Node const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_selectNodeContents) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_selectNodeContents(self,node);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_selectNodeContents. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_selectNodeContents. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->selectNodeContents((IDOM_Node const *)arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_compareBoundaryPoints) {
    IDOM_Range *arg1 ;
    int arg2 ;
    IDOM_Range *arg3 ;
    short result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 3) || (items > 3)) {
        croak("Usage: DOM_Range_compareBoundaryPoints(self,how,range);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_compareBoundaryPoints. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 3 of DOM_Range_compareBoundaryPoints. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (short )((IDOM_Range const *)arg1)->compareBoundaryPoints((IDOM_Range::CompareHow )arg2,(IDOM_Range const *)arg3);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_deleteContents) {
    IDOM_Range *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_deleteContents(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_deleteContents. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            (arg1)->deleteContents();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_extractContents) {
    IDOM_Range *arg1 ;
    IDOM_DocumentFragment *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_extractContents(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_extractContents. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (IDOM_DocumentFragment *)(arg1)->extractContents();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DocumentFragment);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_cloneContents) {
    IDOM_Range *arg1 ;
    IDOM_DocumentFragment *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_cloneContents(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_cloneContents. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (IDOM_DocumentFragment *)((IDOM_Range const *)arg1)->cloneContents();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_DocumentFragment);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_insertNode) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_insertNode(self,node);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_insertNode. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_insertNode. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->insertNode(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_surroundContents) {
    IDOM_Range *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_Range_surroundContents(self,node);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_surroundContents. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_Range_surroundContents. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->surroundContents(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_cloneRange) {
    IDOM_Range *arg1 ;
    IDOM_Range *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_cloneRange(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_cloneRange. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (IDOM_Range *)((IDOM_Range const *)arg1)->cloneRange();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_Range);
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_toString) {
    IDOM_Range *arg1 ;
    XMLCh *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_toString(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_toString. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            result = (XMLCh *)((IDOM_Range const *)arg1)->toString();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        ST(argvi) = XMLString2Perl(result);
        ++argvi;
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_Range_detach) {
    IDOM_Range *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_Range_detach(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_Range) < 0) {
            croak("Type error in argument 1 of DOM_Range_detach. Expected %s", SWIGTYPE_p_IDOM_Range->name);
        }
    }
    {
        try {
            (arg1)->detach();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_new_DOM_RangeException) {
    IDOM_RangeException *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 0) || (items > 0)) {
        croak("Usage: new_DOM_RangeException();");
    }
    {
        try {
            result = (IDOM_RangeException *)new IDOM_RangeException();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_RangeException);
    XSRETURN(argvi);
}

XS(_wrap_delete_DOM_RangeException) {
    IDOM_RangeException *arg1 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: delete_DOM_RangeException(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_RangeException) < 0) {
            croak("Type error in argument 1 of delete_DOM_RangeException. Expected %s", SWIGTYPE_p_IDOM_RangeException->name);
        }
    }
    {
        try {
            delete arg1;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_RangeException_code_set) {
    IDOM_RangeException *arg1 ;
    int arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_RangeException_code_set(self,code);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_RangeException) < 0) {
            croak("Type error in argument 1 of DOM_RangeException_code_set. Expected %s", SWIGTYPE_p_IDOM_RangeException->name);
        }
    }
    arg2 = (int ) SvIV(ST(1));
    {
        try {
            if (arg1) arg1->code = (IDOM_RangeException::RangeExceptionCode )arg2;
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

XS(_wrap_DOM_RangeException_code_get) {
    IDOM_RangeException *arg1 ;
    int result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_RangeException_code_get(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_RangeException) < 0) {
            croak("Type error in argument 1 of DOM_RangeException_code_get. Expected %s", SWIGTYPE_p_IDOM_RangeException->name);
        }
    }
    {
        try {
            result = (int ) (arg1->code);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_getRoot) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_getRoot(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_getRoot. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->getRoot();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_getWhatToShow) {
    IDOM_TreeWalker *arg1 ;
    unsigned long result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_getWhatToShow(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_getWhatToShow. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (unsigned long )(arg1)->getWhatToShow();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_getFilter) {
    IDOM_TreeWalker *arg1 ;
    IDOM_NodeFilter *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_getFilter(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_getFilter. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_NodeFilter *)(arg1)->getFilter();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_IDOM_NodeFilter);
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_getExpandEntityReferences) {
    IDOM_TreeWalker *arg1 ;
    bool result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_getExpandEntityReferences(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_getExpandEntityReferences. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (bool )(arg1)->getExpandEntityReferences();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++), (IV) result);
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_getCurrentNode) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_getCurrentNode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_getCurrentNode. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->getCurrentNode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_parentNode) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_parentNode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_parentNode. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->parentNode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_firstChild) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_firstChild(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_firstChild. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->firstChild();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_lastChild) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_lastChild(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_lastChild. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->lastChild();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_previousSibling) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_previousSibling(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_previousSibling. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->previousSibling();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_nextSibling) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_nextSibling(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_nextSibling. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->nextSibling();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_previousNode) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_previousNode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_previousNode. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->previousNode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_nextNode) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *result;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 1) || (items > 1)) {
        croak("Usage: DOM_TreeWalker_nextNode(self);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_nextNode. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        try {
            result = (IDOM_Node *)(arg1)->nextNode();
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    {
        swig_type_info *ty = SWIG_TypeDynamicCast(SWIGTYPE_p_IDOM_Node, (void **) &result);
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, ty);
    }
    XSRETURN(argvi);
}

XS(_wrap_DOM_TreeWalker_setCurrentNode) {
    IDOM_TreeWalker *arg1 ;
    IDOM_Node *arg2 ;
    int argvi = 0;
    dXSARGS;
    
    if ((items < 2) || (items > 2)) {
        croak("Usage: DOM_TreeWalker_setCurrentNode(self,currentNode);");
    }
    {
        if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_IDOM_TreeWalker) < 0) {
            croak("Type error in argument 1 of DOM_TreeWalker_setCurrentNode. Expected %s", SWIGTYPE_p_IDOM_TreeWalker->name);
        }
    }
    {
        if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_IDOM_Node) < 0) {
            croak("Type error in argument 2 of DOM_TreeWalker_setCurrentNode. Expected %s", SWIGTYPE_p_IDOM_Node->name);
        }
    }
    {
        try {
            (arg1)->setCurrentNode(arg2);
            
        }
        catch (const XMLException& e)
        {
            makeXMLException(e);
        }
        catch (const IDOM_DOMException& e)
        {
            makeIDOMException(e);
        }
        catch (...)
        {
            XMLPlatformUtils::Terminate();
            croak("%s", "Handling Unknown exception");
        }
    }
    
    XSRETURN(argvi);
}

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_IDOM_CDATASectionTo_p_IDOM_Text(void *x) {
    return (void *)((IDOM_Text *) ((IDOM_CDATASection *) x));
}
static void *_p_PerlNodeFilterCallbackHandlerTo_p_IDOM_NodeFilter(void *x) {
    return (void *)((IDOM_NodeFilter *) ((PerlNodeFilterCallbackHandler *) x));
}
static void *_p_SAXNotSupportedExceptionTo_p_SAXException(void *x) {
    return (void *)((SAXException *) ((SAXNotSupportedException *) x));
}
static void *_p_SAXNotRecognizedExceptionTo_p_SAXException(void *x) {
    return (void *)((SAXException *) ((SAXNotRecognizedException *) x));
}
static void *_p_SAXParseExceptionTo_p_SAXException(void *x) {
    return (void *)((SAXException *) ((SAXParseException *) x));
}
static void *_p_IDOM_RangeExceptionTo_p_IDOM_DOMException(void *x) {
    return (void *)((IDOM_DOMException *) ((IDOM_RangeException *) x));
}
static void *_p_SAXParserTo_p_XMLErrorReporter(void *x) {
    return (void *)((XMLErrorReporter *) ((SAXParser *) x));
}
static void *_p_IDOMParserTo_p_XMLErrorReporter(void *x) {
    return (void *)((XMLErrorReporter *) ((IDOMParser *) x));
}
static void *_p_HandlerBaseTo_p_EntityResolver(void *x) {
    return (void *)((EntityResolver *) ((HandlerBase *) x));
}
static void *_p_PerlEntityResolverHandlerTo_p_EntityResolver(void *x) {
    return (void *)((EntityResolver *) ((PerlEntityResolverHandler *) x));
}
static void *_p_DefaultHandlerTo_p_EntityResolver(void *x) {
    return (void *)((EntityResolver *) ((DefaultHandler *) x));
}
static void *_p_SAXParserTo_p_XMLEntityHandler(void *x) {
    return (void *)((XMLEntityHandler *) ((SAXParser *) x));
}
static void *_p_IDOMParserTo_p_XMLEntityHandler(void *x) {
    return (void *)((XMLEntityHandler *) ((IDOMParser *) x));
}
static void *_p_SAXParserTo_p_DocTypeHandler(void *x) {
    return (void *)((DocTypeHandler *) ((SAXParser *) x));
}
static void *_p_IDOMParserTo_p_DocTypeHandler(void *x) {
    return (void *)((DocTypeHandler *) ((IDOMParser *) x));
}
static void *_p_SAXParserTo_p_XMLDocumentHandler(void *x) {
    return (void *)((XMLDocumentHandler *) ((SAXParser *) x));
}
static void *_p_IDOMParserTo_p_XMLDocumentHandler(void *x) {
    return (void *)((XMLDocumentHandler *) ((IDOMParser *) x));
}
static void *_p_DefaultHandlerTo_p_LexicalHandler(void *x) {
    return (void *)((LexicalHandler *) ((DefaultHandler *) x));
}
static void *_p_HandlerBaseTo_p_DTDHandler(void *x) {
    return (void *)((DTDHandler *) ((HandlerBase *) x));
}
static void *_p_DefaultHandlerTo_p_DTDHandler(void *x) {
    return (void *)((DTDHandler *) ((DefaultHandler *) x));
}
static void *_p_HandlerBaseTo_p_ErrorHandler(void *x) {
    return (void *)((ErrorHandler *) ((HandlerBase *) x));
}
static void *_p_PerlErrorCallbackHandlerTo_p_ErrorHandler(void *x) {
    return (void *)((ErrorHandler *) ((PerlErrorCallbackHandler *) x));
}
static void *_p_DefaultHandlerTo_p_ErrorHandler(void *x) {
    return (void *)((ErrorHandler *) ((DefaultHandler *) x));
}
static void *_p_PerlContentCallbackHandlerTo_p_ContentHandler(void *x) {
    return (void *)((ContentHandler *) ((PerlContentCallbackHandler *) x));
}
static void *_p_DefaultHandlerTo_p_ContentHandler(void *x) {
    return (void *)((ContentHandler *) ((DefaultHandler *) x));
}
static void *_p_HandlerBaseTo_p_DocumentHandler(void *x) {
    return (void *)((DocumentHandler *) ((HandlerBase *) x));
}
static void *_p_PerlDocumentCallbackHandlerTo_p_DocumentHandler(void *x) {
    return (void *)((DocumentHandler *) ((PerlDocumentCallbackHandler *) x));
}
static void *_p_PerlNodeFilterCallbackHandlerTo_p_PerlCallbackHandler(void *x) {
    return (void *)((PerlCallbackHandler *) ((PerlNodeFilterCallbackHandler *) x));
}
static void *_p_PerlDocumentCallbackHandlerTo_p_PerlCallbackHandler(void *x) {
    return (void *)((PerlCallbackHandler *) ((PerlDocumentCallbackHandler *) x));
}
static void *_p_PerlContentCallbackHandlerTo_p_PerlCallbackHandler(void *x) {
    return (void *)((PerlCallbackHandler *) ((PerlContentCallbackHandler *) x));
}
static void *_p_PerlEntityResolverHandlerTo_p_PerlCallbackHandler(void *x) {
    return (void *)((PerlCallbackHandler *) ((PerlEntityResolverHandler *) x));
}
static void *_p_PerlErrorCallbackHandlerTo_p_PerlCallbackHandler(void *x) {
    return (void *)((PerlCallbackHandler *) ((PerlErrorCallbackHandler *) x));
}
static void *_p_DefaultHandlerTo_p_DeclHandler(void *x) {
    return (void *)((DeclHandler *) ((DefaultHandler *) x));
}
static void *_p_IDOM_ElementTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_Element *) x));
}
static void *_p_IDOM_AttrTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_Attr *) x));
}
static void *_p_IDOM_TextTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_Text *) x));
}
static void *_p_IDOM_DocumentFragmentTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_DocumentFragment *) x));
}
static void *_p_IDOM_CharacterDataTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_CharacterData *) x));
}
static void *_p_IDOM_DocumentTypeTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_DocumentType *) x));
}
static void *_p_IDOM_CommentTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_Comment *) x));
}
static void *_p_IDOM_ProcessingInstructionTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_ProcessingInstruction *) x));
}
static void *_p_IDOM_DocumentTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_Document *) x));
}
static void *_p_IDOM_EntityTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_Entity *) x));
}
static void *_p_IDOM_EntityReferenceTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_EntityReference *) x));
}
static void *_p_IDOM_CDATASectionTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_CDATASection *) x));
}
static void *_p_IDOM_NotationTo_p_IDOM_Node(void *x) {
    return (void *)((IDOM_Node *) ((IDOM_Notation *) x));
}
static void *_p_IDOM_TextTo_p_IDOM_CharacterData(void *x) {
    return (void *)((IDOM_CharacterData *) ((IDOM_Text *) x));
}
static void *_p_IDOM_CommentTo_p_IDOM_CharacterData(void *x) {
    return (void *)((IDOM_CharacterData *) ((IDOM_Comment *) x));
}
static void *_p_IDOM_CDATASectionTo_p_IDOM_CharacterData(void *x) {
    return (void *)((IDOM_CharacterData *) ((IDOM_CDATASection *) x));
}
static void *_p_MemBufInputSourceTo_p_InputSource(void *x) {
    return (void *)((InputSource *) ((MemBufInputSource *) x));
}
static void *_p_StdInInputSourceTo_p_InputSource(void *x) {
    return (void *)((InputSource *) ((StdInInputSource *) x));
}
static void *_p_LocalFileInputSourceTo_p_InputSource(void *x) {
    return (void *)((InputSource *) ((LocalFileInputSource *) x));
}
static void *_p_URLInputSourceTo_p_InputSource(void *x) {
    return (void *)((InputSource *) ((URLInputSource *) x));
}
static swig_type_info _swigt__p_IDOM_Document[] = {{"XML::Xerces::DOM_Document", 0, "IDOM_Document *"},{"XML::Xerces::DOM_Document"},{0}};
static swig_type_info _swigt__p_IDOM_NodeIterator[] = {{"XML::Xerces::DOM_NodeIterator", 0, "IDOM_NodeIterator *"},{"XML::Xerces::DOM_NodeIterator"},{0}};
static swig_type_info _swigt__p_IDOM_DOMImplementation[] = {{"XML::Xerces::DOM_DOMImplementation", 0, "IDOM_DOMImplementation *"},{"XML::Xerces::DOM_DOMImplementation"},{0}};
static swig_type_info _swigt__p_IDOM_Text[] = {{"XML::Xerces::DOM_Text", 0, "IDOM_Text *"},{"XML::Xerces::DOM_Text"},{"XML::Xerces::DOM_CDATASection", _p_IDOM_CDATASectionTo_p_IDOM_Text},{0}};
static swig_type_info _swigt__p_XMLAttr[] = {{"_p_XMLAttr", 0, "XMLAttr *"},{"_p_XMLAttr"},{0}};
static swig_type_info _swigt__p_AttributeList[] = {{"XML::Xerces::AttributeList", 0, "AttributeList *"},{"XML::Xerces::AttributeList"},{0}};
static swig_type_info _swigt__p_XMLBuffer[] = {{"XML::Xerces::XMLBuffer", 0, "XMLBuffer *"},{"XML::Xerces::XMLBuffer"},{0}};
static swig_type_info _swigt__p_bool[] = {{"_p_bool", 0, "bool *"},{"_p_bool"},{0}};
static swig_type_info _swigt__p_IDOM_NodeFilter[] = {{"XML::Xerces::DOM_NodeFilter", 0, "IDOM_NodeFilter *"},{"XML::Xerces::DOM_NodeFilter"},{"XML::Xerces::PerlNodeFilterCallbackHandler", _p_PerlNodeFilterCallbackHandlerTo_p_IDOM_NodeFilter},{0}};
static swig_type_info _swigt__p_p_QName[] = {{"_p_p_QName", 0, "QName **"},{"_p_p_QName"},{0}};
static swig_type_info _swigt__p_QName[] = {{"XML::Xerces::QName", 0, "QName *"},{"XML::Xerces::QName"},{0}};
static swig_type_info _swigt__p_XMLNotationDecl[] = {{"_p_XMLNotationDecl", 0, "XMLNotationDecl *"},{"_p_XMLNotationDecl"},{0}};
static swig_type_info _swigt__p_IDOM_DocumentType[] = {{"XML::Xerces::DOM_DocumentType", 0, "IDOM_DocumentType *"},{"XML::Xerces::DOM_DocumentType"},{0}};
static swig_type_info _swigt__p_XMLElementDecl[] = {{"XML::Xerces::XMLElementDecl", 0, "XMLElementDecl *"},{"XML::Xerces::XMLElementDecl"},{0}};
static swig_type_info _swigt__p_void[] = {{"_p_void", 0, "void *"},{"_p_void"},{0}};
static swig_type_info _swigt__p_p_void[] = {{"_p_p_void", 0, "void **"},{"_p_p_void"},{0}};
static swig_type_info _swigt__p_IDOM_EntityReference[] = {{"XML::Xerces::DOM_EntityReference", 0, "IDOM_EntityReference *"},{"XML::Xerces::DOM_EntityReference"},{0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *"},{"_p_int"},{0}};
static swig_type_info _swigt__p_IDOM_Notation[] = {{"XML::Xerces::DOM_Notation", 0, "IDOM_Notation *"},{"XML::Xerces::DOM_Notation"},{0}};
static swig_type_info _swigt__p_SAXParseException[] = {{"XML::Xerces::SAXParseException", 0, "SAXParseException *"},{"XML::Xerces::SAXParseException"},{0}};
static swig_type_info _swigt__p_SAXNotRecognizedException[] = {{"XML::Xerces::SAXNotRecognizedException", 0, "SAXNotRecognizedException *"},{"XML::Xerces::SAXNotRecognizedException"},{0}};
static swig_type_info _swigt__p_SAXNotSupportedException[] = {{"XML::Xerces::SAXNotSupportedException", 0, "SAXNotSupportedException *"},{"XML::Xerces::SAXNotSupportedException"},{0}};
static swig_type_info _swigt__p_IDOM_DOMException[] = {{"XML::Xerces::DOM_DOMException", 0, "IDOM_DOMException *"},{"XML::Xerces::DOM_DOMException"},{"XML::Xerces::DOM_RangeException", _p_IDOM_RangeExceptionTo_p_IDOM_DOMException},{0}};
static swig_type_info _swigt__p_SAXException[] = {{"XML::Xerces::SAXException", 0, "SAXException *"},{"XML::Xerces::SAXException"},{"XML::Xerces::SAXNotSupportedException", _p_SAXNotSupportedExceptionTo_p_SAXException},{"XML::Xerces::SAXNotRecognizedException", _p_SAXNotRecognizedExceptionTo_p_SAXException},{"XML::Xerces::SAXParseException", _p_SAXParseExceptionTo_p_SAXException},{0}};
static swig_type_info _swigt__p_XMLException[] = {{"XML::Xerces::XMLException", 0, "XMLException *"},{"XML::Xerces::XMLException"},{0}};
static swig_type_info _swigt__p_XMLErrorReporter[] = {{"XML::Xerces::XMLErrorReporter", 0, "XMLErrorReporter *"},{"XML::Xerces::SAXParser", _p_SAXParserTo_p_XMLErrorReporter},{"XML::Xerces::DOMParser", _p_IDOMParserTo_p_XMLErrorReporter},{"XML::Xerces::XMLErrorReporter"},{0}};
static swig_type_info _swigt__p_IDOM_RangeException[] = {{"XML::Xerces::DOM_RangeException", 0, "IDOM_RangeException *"},{"XML::Xerces::DOM_RangeException"},{0}};
static swig_type_info _swigt__p_XMLDeleter[] = {{"XML::Xerces::XMLDeleter", 0, "XMLDeleter *"},{"XML::Xerces::XMLDeleter"},{0}};
static swig_type_info _swigt__p_Attributes[] = {{"XML::Xerces::Attributes", 0, "Attributes *"},{"XML::Xerces::Attributes"},{0}};
static swig_type_info _swigt__p_FileHandle[] = {{"_p_FileHandle", 0, "FileHandle *"},{"_p_FileHandle"},{0}};
static swig_type_info _swigt__p_IDOMParser[] = {{"XML::Xerces::DOMParser", 0, "IDOMParser *"},{"XML::Xerces::DOMParser"},{0}};
static swig_type_info _swigt__p_XMLScanner[] = {{"XML::Xerces::XMLScanner", 0, "XMLScanner *"},{"XML::Xerces::XMLScanner"},{0}};
static swig_type_info _swigt__p_XMLByte[] = {{"_p_XMLByte", 0, "XMLByte *"},{"_p_XMLByte"},{0}};
static swig_type_info _swigt__p_XMLURL[] = {{"XML::Xerces::XMLURL", 0, "XMLURL *"},{"XML::Xerces::XMLURL"},{0}};
static swig_type_info _swigt__p_XMLAttDef[] = {{"_p_XMLAttDef", 0, "XMLAttDef *"},{"_p_XMLAttDef"},{0}};
static swig_type_info _swigt__p_EntityResolver[] = {{"XML::Xerces::EntityResolver", 0, "EntityResolver *"},{"XML::Xerces::EntityResolver"},{"XML::Xerces::HandlerBase", _p_HandlerBaseTo_p_EntityResolver},{"XML::Xerces::PerlEntityResolverHandler", _p_PerlEntityResolverHandlerTo_p_EntityResolver},{"XML::Xerces::DefaultHandler", _p_DefaultHandlerTo_p_EntityResolver},{0}};
static swig_type_info _swigt__p_DeclHandler[] = {{"XML::Xerces::DeclHandler", 0, "DeclHandler *"},{"XML::Xerces::DeclHandler"},{"XML::Xerces::DefaultHandler", _p_DefaultHandlerTo_p_DeclHandler},{0}};
static swig_type_info _swigt__p_XMLEntityHandler[] = {{"XML::Xerces::XMLEntityHandler", 0, "XMLEntityHandler *"},{"XML::Xerces::SAXParser", _p_SAXParserTo_p_XMLEntityHandler},{"XML::Xerces::DOMParser", _p_IDOMParserTo_p_XMLEntityHandler},{"XML::Xerces::XMLEntityHandler"},{0}};
static swig_type_info _swigt__p_DocTypeHandler[] = {{"XML::Xerces::DocTypeHandler", 0, "DocTypeHandler *"},{"XML::Xerces::SAXParser", _p_SAXParserTo_p_DocTypeHandler},{"XML::Xerces::DOMParser", _p_IDOMParserTo_p_DocTypeHandler},{"XML::Xerces::DocTypeHandler"},{0}};
static swig_type_info _swigt__p_XMLDocumentHandler[] = {{"XML::Xerces::XMLDocumentHandler", 0, "XMLDocumentHandler *"},{"XML::Xerces::SAXParser", _p_SAXParserTo_p_XMLDocumentHandler},{"XML::Xerces::DOMParser", _p_IDOMParserTo_p_XMLDocumentHandler},{"XML::Xerces::XMLDocumentHandler"},{0}};
static swig_type_info _swigt__p_DefaultHandler[] = {{"XML::Xerces::DefaultHandler", 0, "DefaultHandler *"},{"XML::Xerces::DefaultHandler"},{0}};
static swig_type_info _swigt__p_LexicalHandler[] = {{"XML::Xerces::LexicalHandler", 0, "LexicalHandler *"},{"XML::Xerces::LexicalHandler"},{"XML::Xerces::DefaultHandler", _p_DefaultHandlerTo_p_LexicalHandler},{0}};
static swig_type_info _swigt__p_DTDHandler[] = {{"XML::Xerces::DTDHandler", 0, "DTDHandler *"},{"XML::Xerces::HandlerBase", _p_HandlerBaseTo_p_DTDHandler},{"XML::Xerces::DTDHandler"},{"XML::Xerces::DefaultHandler", _p_DefaultHandlerTo_p_DTDHandler},{0}};
static swig_type_info _swigt__p_ErrorHandler[] = {{"XML::Xerces::ErrorHandler", 0, "ErrorHandler *"},{"XML::Xerces::HandlerBase", _p_HandlerBaseTo_p_ErrorHandler},{"XML::Xerces::ErrorHandler"},{"XML::Xerces::PerlErrorCallbackHandler", _p_PerlErrorCallbackHandlerTo_p_ErrorHandler},{"XML::Xerces::DefaultHandler", _p_DefaultHandlerTo_p_ErrorHandler},{0}};
static swig_type_info _swigt__p_ContentHandler[] = {{"XML::Xerces::ContentHandler", 0, "ContentHandler *"},{"XML::Xerces::ContentHandler"},{"XML::Xerces::PerlContentCallbackHandler", _p_PerlContentCallbackHandlerTo_p_ContentHandler},{"XML::Xerces::DefaultHandler", _p_DefaultHandlerTo_p_ContentHandler},{0}};
static swig_type_info _swigt__p_DocumentHandler[] = {{"XML::Xerces::DocumentHandler", 0, "DocumentHandler *"},{"XML::Xerces::HandlerBase", _p_HandlerBaseTo_p_DocumentHandler},{"XML::Xerces::DocumentHandler"},{"XML::Xerces::PerlDocumentCallbackHandler", _p_PerlDocumentCallbackHandlerTo_p_DocumentHandler},{0}};
static swig_type_info _swigt__p_PerlCallbackHandler[] = {{"XML::Xerces::PerlCallbackHandler", 0, "PerlCallbackHandler *"},{"XML::Xerces::PerlCallbackHandler"},{"XML::Xerces::PerlNodeFilterCallbackHandler", _p_PerlNodeFilterCallbackHandlerTo_p_PerlCallbackHandler},{"XML::Xerces::PerlDocumentCallbackHandler", _p_PerlDocumentCallbackHandlerTo_p_PerlCallbackHandler},{"XML::Xerces::PerlContentCallbackHandler", _p_PerlContentCallbackHandlerTo_p_PerlCallbackHandler},{"XML::Xerces::PerlEntityResolverHandler", _p_PerlEntityResolverHandlerTo_p_PerlCallbackHandler},{"XML::Xerces::PerlErrorCallbackHandler", _p_PerlErrorCallbackHandlerTo_p_PerlCallbackHandler},{0}};
static swig_type_info _swigt__p_PerlNodeFilterCallbackHandler[] = {{"XML::Xerces::PerlNodeFilterCallbackHandler", 0, "PerlNodeFilterCallbackHandler *"},{"XML::Xerces::PerlNodeFilterCallbackHandler"},{0}};
static swig_type_info _swigt__p_PerlDocumentCallbackHandler[] = {{"XML::Xerces::PerlDocumentCallbackHandler", 0, "PerlDocumentCallbackHandler *"},{"XML::Xerces::PerlDocumentCallbackHandler"},{0}};
static swig_type_info _swigt__p_PerlContentCallbackHandler[] = {{"XML::Xerces::PerlContentCallbackHandler", 0, "PerlContentCallbackHandler *"},{"XML::Xerces::PerlContentCallbackHandler"},{0}};
static swig_type_info _swigt__p_PerlEntityResolverHandler[] = {{"XML::Xerces::PerlEntityResolverHandler", 0, "PerlEntityResolverHandler *"},{"XML::Xerces::PerlEntityResolverHandler"},{0}};
static swig_type_info _swigt__p_PerlErrorCallbackHandler[] = {{"XML::Xerces::PerlErrorCallbackHandler", 0, "PerlErrorCallbackHandler *"},{"XML::Xerces::PerlErrorCallbackHandler"},{0}};
static swig_type_info _swigt__p_IDOM_TreeWalker[] = {{"XML::Xerces::DOM_TreeWalker", 0, "IDOM_TreeWalker *"},{"XML::Xerces::DOM_TreeWalker"},{0}};
static swig_type_info _swigt__p_IDOM_Range[] = {{"XML::Xerces::DOM_Range", 0, "IDOM_Range *"},{"XML::Xerces::DOM_Range"},{0}};
static swig_type_info _swigt__p_IDOM_Node[] = {{"XML::Xerces::DOM_Node", 0, "IDOM_Node *"},{"XML::Xerces::DOM_Notation", _p_IDOM_NotationTo_p_IDOM_Node},{"XML::Xerces::DOM_DocumentFragment", _p_IDOM_DocumentFragmentTo_p_IDOM_Node},{"XML::Xerces::DOM_CDATASection", _p_IDOM_CDATASectionTo_p_IDOM_Node},{"XML::Xerces::DOM_EntityReference", _p_IDOM_EntityReferenceTo_p_IDOM_Node},{"XML::Xerces::DOM_Node"},{"XML::Xerces::DOM_Entity", _p_IDOM_EntityTo_p_IDOM_Node},{"XML::Xerces::DOM_Attr", _p_IDOM_AttrTo_p_IDOM_Node},{"XML::Xerces::DOM_CharacterData", _p_IDOM_CharacterDataTo_p_IDOM_Node},{"XML::Xerces::DOM_DocumentType", _p_IDOM_DocumentTypeTo_p_IDOM_Node},{"XML::Xerces::DOM_Text", _p_IDOM_TextTo_p_IDOM_Node},{"XML::Xerces::DOM_Comment", _p_IDOM_CommentTo_p_IDOM_Node},{"XML::Xerces::DOM_Document", _p_IDOM_DocumentTo_p_IDOM_Node},{"XML::Xerces::DOM_Element", _p_IDOM_ElementTo_p_IDOM_Node},{"XML::Xerces::DOM_ProcessingInstruction", _p_IDOM_ProcessingInstructionTo_p_IDOM_Node},{0}};
static swig_type_info _swigt__p_XMLValid__Codes[] = {{"_p_XMLValid__Codes", 0, "XMLValid::Codes *"},{"_p_XMLValid__Codes"},{0}};
static swig_type_info _swigt__p_DTDEntityDecl[] = {{"_p_DTDEntityDecl", 0, "DTDEntityDecl *"},{"_p_DTDEntityDecl"},{0}};
static swig_type_info _swigt__p_XMLMsgLoader[] = {{"XML::Xerces::XMLMsgLoader", 0, "XMLMsgLoader *"},{"XML::Xerces::XMLMsgLoader"},{0}};
static swig_type_info _swigt__p_XMLBufferMgr[] = {{"XML::Xerces::XMLBufferMgr", 0, "XMLBufferMgr *"},{"XML::Xerces::XMLBufferMgr"},{0}};
static swig_type_info _swigt__p_Locator[] = {{"XML::Xerces::Locator", 0, "Locator *"},{"XML::Xerces::Locator"},{0}};
static swig_type_info _swigt__p_IDOM_CharacterData[] = {{"XML::Xerces::DOM_CharacterData", 0, "IDOM_CharacterData *"},{"XML::Xerces::DOM_Text", _p_IDOM_TextTo_p_IDOM_CharacterData},{"XML::Xerces::DOM_CharacterData"},{"XML::Xerces::DOM_Comment", _p_IDOM_CommentTo_p_IDOM_CharacterData},{"XML::Xerces::DOM_CDATASection", _p_IDOM_CDATASectionTo_p_IDOM_CharacterData},{0}};
static swig_type_info _swigt__p_IDOM_DocumentFragment[] = {{"XML::Xerces::DOM_DocumentFragment", 0, "IDOM_DocumentFragment *"},{"XML::Xerces::DOM_DocumentFragment"},{0}};
static swig_type_info _swigt__p_BinInputStream[] = {{"XML::Xerces::BinInputStream", 0, "BinInputStream *"},{"XML::Xerces::BinInputStream"},{0}};
static swig_type_info _swigt__p_URLInputSource[] = {{"XML::Xerces::URLInputSource", 0, "URLInputSource *"},{"XML::Xerces::URLInputSource"},{0}};
static swig_type_info _swigt__p_LocalFileInputSource[] = {{"XML::Xerces::LocalFileInputSource", 0, "LocalFileInputSource *"},{"XML::Xerces::LocalFileInputSource"},{0}};
static swig_type_info _swigt__p_StdInInputSource[] = {{"XML::Xerces::StdInInputSource", 0, "StdInInputSource *"},{"XML::Xerces::StdInInputSource"},{0}};
static swig_type_info _swigt__p_MemBufInputSource[] = {{"XML::Xerces::MemBufInputSource", 0, "MemBufInputSource *"},{"XML::Xerces::MemBufInputSource"},{0}};
static swig_type_info _swigt__p_InputSource[] = {{"XML::Xerces::InputSource", 0, "InputSource *"},{"XML::Xerces::InputSource"},{"XML::Xerces::MemBufInputSource", _p_MemBufInputSourceTo_p_InputSource},{"XML::Xerces::StdInInputSource", _p_StdInInputSourceTo_p_InputSource},{"XML::Xerces::LocalFileInputSource", _p_LocalFileInputSourceTo_p_InputSource},{"XML::Xerces::URLInputSource", _p_URLInputSourceTo_p_InputSource},{0}};
static swig_type_info _swigt__p_ElemStack__MapModes[] = {{"_p_ElemStack__MapModes", 0, "ElemStack::MapModes *"},{"_p_ElemStack__MapModes"},{0}};
static swig_type_info _swigt__p_IDOM_NamedNodeMap[] = {{"XML::Xerces::DOM_NamedNodeMap", 0, "IDOM_NamedNodeMap *"},{"XML::Xerces::DOM_NamedNodeMap"},{0}};
static swig_type_info _swigt__p_ReaderMgr[] = {{"XML::Xerces::ReaderMgr", 0, "ReaderMgr *"},{"XML::Xerces::ReaderMgr"},{0}};
static swig_type_info _swigt__p_IDOM_NodeList[] = {{"XML::Xerces::DOM_NodeList", 0, "IDOM_NodeList *"},{"XML::Xerces::DOM_NodeList"},{0}};
static swig_type_info _swigt__p_Grammar[] = {{"XML::Xerces::Grammar", 0, "Grammar *"},{"XML::Xerces::Grammar"},{0}};
static swig_type_info _swigt__p_SAX2XMLReader[] = {{"XML::Xerces::SAX2XMLReader", 0, "SAX2XMLReader *"},{"XML::Xerces::SAX2XMLReader"},{0}};
static swig_type_info _swigt__p_SAXParser[] = {{"XML::Xerces::SAXParser", 0, "SAXParser *"},{"XML::Xerces::SAXParser"},{0}};
static swig_type_info _swigt__p_IDOM_Comment[] = {{"XML::Xerces::DOM_Comment", 0, "IDOM_Comment *"},{"XML::Xerces::DOM_Comment"},{0}};
static swig_type_info _swigt__p_HandlerBase[] = {{"XML::Xerces::HandlerBase", 0, "HandlerBase *"},{"XML::Xerces::HandlerBase"},{0}};
static swig_type_info _swigt__p_XMLUri[] = {{"XML::Xerces::XMLUri", 0, "XMLUri *"},{"XML::Xerces::XMLUri"},{0}};
static swig_type_info _swigt__p_unsigned_int[] = {{"_p_unsigned_int", 0, "unsigned int *"},{"_p_unsigned_int"},{0}};
static swig_type_info _swigt__p_IDOM_ProcessingInstruction[] = {{"XML::Xerces::DOM_ProcessingInstruction", 0, "IDOM_ProcessingInstruction *"},{"XML::Xerces::DOM_ProcessingInstruction"},{0}};
static swig_type_info _swigt__p_IDOM_Attr[] = {{"XML::Xerces::DOM_Attr", 0, "IDOM_Attr *"},{"XML::Xerces::DOM_Attr"},{0}};
static swig_type_info _swigt__p_IDOM_CDATASection[] = {{"XML::Xerces::DOM_CDATASection", 0, "IDOM_CDATASection *"},{"XML::Xerces::DOM_CDATASection"},{0}};
static swig_type_info _swigt__p_XMLErrorReporter__ErrTypes[] = {{"_p_XMLErrorReporter__ErrTypes", 0, "XMLErrorReporter::ErrTypes *"},{"_p_XMLErrorReporter__ErrTypes"},{0}};
static swig_type_info _swigt__p_XMLPScanToken[] = {{"XML::Xerces::XMLPScanToken", 0, "XMLPScanToken *"},{"XML::Xerces::XMLPScanToken"},{0}};
static swig_type_info _swigt__p_IDOM_Element[] = {{"XML::Xerces::DOM_Element", 0, "IDOM_Element *"},{"XML::Xerces::DOM_Element"},{0}};
static swig_type_info _swigt__p_XMLValidator[] = {{"XML::Xerces::XMLValidator", 0, "XMLValidator *"},{"XML::Xerces::XMLValidator"},{0}};
static swig_type_info _swigt__p_IDOM_Entity[] = {{"XML::Xerces::DOM_Entity", 0, "IDOM_Entity *"},{"XML::Xerces::DOM_Entity"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_IDOM_Document, 
_swigt__p_IDOM_NodeIterator, 
_swigt__p_IDOM_DOMImplementation, 
_swigt__p_IDOM_Text, 
_swigt__p_XMLAttr, 
_swigt__p_AttributeList, 
_swigt__p_XMLBuffer, 
_swigt__p_bool, 
_swigt__p_IDOM_NodeFilter, 
_swigt__p_p_QName, 
_swigt__p_QName, 
_swigt__p_XMLNotationDecl, 
_swigt__p_IDOM_DocumentType, 
_swigt__p_XMLElementDecl, 
_swigt__p_void, 
_swigt__p_p_void, 
_swigt__p_IDOM_EntityReference, 
_swigt__p_int, 
_swigt__p_IDOM_Notation, 
_swigt__p_SAXParseException, 
_swigt__p_SAXNotRecognizedException, 
_swigt__p_SAXNotSupportedException, 
_swigt__p_IDOM_DOMException, 
_swigt__p_SAXException, 
_swigt__p_XMLException, 
_swigt__p_XMLErrorReporter, 
_swigt__p_IDOM_RangeException, 
_swigt__p_XMLDeleter, 
_swigt__p_Attributes, 
_swigt__p_FileHandle, 
_swigt__p_IDOMParser, 
_swigt__p_XMLScanner, 
_swigt__p_XMLByte, 
_swigt__p_XMLURL, 
_swigt__p_XMLAttDef, 
_swigt__p_EntityResolver, 
_swigt__p_DeclHandler, 
_swigt__p_XMLEntityHandler, 
_swigt__p_DocTypeHandler, 
_swigt__p_XMLDocumentHandler, 
_swigt__p_DefaultHandler, 
_swigt__p_LexicalHandler, 
_swigt__p_DTDHandler, 
_swigt__p_ErrorHandler, 
_swigt__p_ContentHandler, 
_swigt__p_DocumentHandler, 
_swigt__p_PerlCallbackHandler, 
_swigt__p_PerlNodeFilterCallbackHandler, 
_swigt__p_PerlDocumentCallbackHandler, 
_swigt__p_PerlContentCallbackHandler, 
_swigt__p_PerlEntityResolverHandler, 
_swigt__p_PerlErrorCallbackHandler, 
_swigt__p_IDOM_TreeWalker, 
_swigt__p_IDOM_Range, 
_swigt__p_IDOM_Node, 
_swigt__p_XMLValid__Codes, 
_swigt__p_DTDEntityDecl, 
_swigt__p_XMLMsgLoader, 
_swigt__p_XMLBufferMgr, 
_swigt__p_Locator, 
_swigt__p_IDOM_CharacterData, 
_swigt__p_IDOM_DocumentFragment, 
_swigt__p_BinInputStream, 
_swigt__p_URLInputSource, 
_swigt__p_LocalFileInputSource, 
_swigt__p_StdInInputSource, 
_swigt__p_MemBufInputSource, 
_swigt__p_InputSource, 
_swigt__p_ElemStack__MapModes, 
_swigt__p_IDOM_NamedNodeMap, 
_swigt__p_ReaderMgr, 
_swigt__p_IDOM_NodeList, 
_swigt__p_Grammar, 
_swigt__p_SAX2XMLReader, 
_swigt__p_SAXParser, 
_swigt__p_IDOM_Comment, 
_swigt__p_HandlerBase, 
_swigt__p_XMLUri, 
_swigt__p_unsigned_int, 
_swigt__p_IDOM_ProcessingInstruction, 
_swigt__p_IDOM_Attr, 
_swigt__p_IDOM_CDATASection, 
_swigt__p_XMLErrorReporter__ErrTypes, 
_swigt__p_XMLPScanToken, 
_swigt__p_IDOM_Element, 
_swigt__p_XMLValidator, 
_swigt__p_IDOM_Entity, 
0
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_constant_info swig_constants[] = {
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_Panic_NoTransService", (long) XMLPlatformUtils::Panic_NoTransService, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_Panic_NoDefTranscoder", (long) XMLPlatformUtils::Panic_NoDefTranscoder, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_Panic_CantFindLib", (long) XMLPlatformUtils::Panic_CantFindLib, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_Panic_UnknownMsgDomain", (long) XMLPlatformUtils::Panic_UnknownMsgDomain, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_Panic_CantLoadMsgDomain", (long) XMLPlatformUtils::Panic_CantLoadMsgDomain, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_Panic_SynchronizationErr", (long) XMLPlatformUtils::Panic_SynchronizationErr, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_Panic_SystemInit", (long) XMLPlatformUtils::Panic_SystemInit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLPlatformUtils_PanicReasons_Count", (long) XMLPlatformUtils::PanicReasons_Count, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLURL_File", (long) XMLURL::File, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLURL_HTTP", (long) XMLURL::HTTP, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLURL_FTP", (long) XMLURL::FTP, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLURL_Protocols_Count", (long) XMLURL::Protocols_Count, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLURL_Unknown", (long) XMLURL::Unknown, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NoError", (long) XMLExcepts::NoError, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_W_LowBounds", (long) XMLExcepts::W_LowBounds, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Scan_CouldNotOpenSource_Warning", (long) XMLExcepts::Scan_CouldNotOpenSource_Warning, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_W_HighBounds", (long) XMLExcepts::W_HighBounds, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_F_LowBounds", (long) XMLExcepts::F_LowBounds, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Array_BadIndex", (long) XMLExcepts::Array_BadIndex, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Array_BadNewSize", (long) XMLExcepts::Array_BadNewSize, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_AttrList_BadIndex", (long) XMLExcepts::AttrList_BadIndex, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_AttDef_BadAttType", (long) XMLExcepts::AttDef_BadAttType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_AttDef_BadDefAttType", (long) XMLExcepts::AttDef_BadDefAttType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Bitset_BadIndex", (long) XMLExcepts::Bitset_BadIndex, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Bitset_NotEqualSize", (long) XMLExcepts::Bitset_NotEqualSize, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_BufMgr_NoMoreBuffers", (long) XMLExcepts::BufMgr_NoMoreBuffers, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_BufMgr_BufferNotInPool", (long) XMLExcepts::BufMgr_BufferNotInPool, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CPtr_PointerIsZero", (long) XMLExcepts::CPtr_PointerIsZero, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_BinOpHadUnaryType", (long) XMLExcepts::CM_BinOpHadUnaryType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_MustBeMixedOrChildren", (long) XMLExcepts::CM_MustBeMixedOrChildren, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_NoPCDATAHere", (long) XMLExcepts::CM_NoPCDATAHere, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_NotValidForSpecType", (long) XMLExcepts::CM_NotValidForSpecType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_UnaryOpHadBinType", (long) XMLExcepts::CM_UnaryOpHadBinType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_UnknownCMType", (long) XMLExcepts::CM_UnknownCMType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_UnknownCMSpecType", (long) XMLExcepts::CM_UnknownCMSpecType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_NoParentCSN", (long) XMLExcepts::CM_NoParentCSN, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_CM_NotValidSpecTypeForNode", (long) XMLExcepts::CM_NotValidSpecTypeForNode, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DTD_UnknownCreateReason", (long) XMLExcepts::DTD_UnknownCreateReason, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_ElemStack_EmptyStack", (long) XMLExcepts::ElemStack_EmptyStack, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_ElemStack_BadIndex", (long) XMLExcepts::ElemStack_BadIndex, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_ElemStack_StackUnderflow", (long) XMLExcepts::ElemStack_StackUnderflow, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_ElemStack_NoParentPushed", (long) XMLExcepts::ElemStack_NoParentPushed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Enum_NoMoreElements", (long) XMLExcepts::Enum_NoMoreElements, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotOpenFile", (long) XMLExcepts::File_CouldNotOpenFile, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotGetCurPos", (long) XMLExcepts::File_CouldNotGetCurPos, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotCloseFile", (long) XMLExcepts::File_CouldNotCloseFile, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotSeekToEnd", (long) XMLExcepts::File_CouldNotSeekToEnd, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotSeekToPos", (long) XMLExcepts::File_CouldNotSeekToPos, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotDupHandle", (long) XMLExcepts::File_CouldNotDupHandle, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotReadFromFile", (long) XMLExcepts::File_CouldNotReadFromFile, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotResetFile", (long) XMLExcepts::File_CouldNotResetFile, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotGetSize", (long) XMLExcepts::File_CouldNotGetSize, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_CouldNotGetBasePathName", (long) XMLExcepts::File_CouldNotGetBasePathName, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_File_BasePathUnderflow", (long) XMLExcepts::File_BasePathUnderflow, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Gen_ParseInProgress", (long) XMLExcepts::Gen_ParseInProgress, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Gen_NoDTDValidator", (long) XMLExcepts::Gen_NoDTDValidator, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Gen_CouldNotOpenDTD", (long) XMLExcepts::Gen_CouldNotOpenDTD, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Gen_CouldNotOpenExtEntity", (long) XMLExcepts::Gen_CouldNotOpenExtEntity, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Gen_UnexpectedEOF", (long) XMLExcepts::Gen_UnexpectedEOF, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_HshTbl_ZeroModulus", (long) XMLExcepts::HshTbl_ZeroModulus, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_HshTbl_BadHashFromKey", (long) XMLExcepts::HshTbl_BadHashFromKey, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_HshTbl_NoSuchKeyExists", (long) XMLExcepts::HshTbl_NoSuchKeyExists, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Mutex_CouldNotCreate", (long) XMLExcepts::Mutex_CouldNotCreate, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Mutex_CouldNotClose", (long) XMLExcepts::Mutex_CouldNotClose, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Mutex_CouldNotLock", (long) XMLExcepts::Mutex_CouldNotLock, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Mutex_CouldNotUnlock", (long) XMLExcepts::Mutex_CouldNotUnlock, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Mutex_CouldNotDestroy", (long) XMLExcepts::Mutex_CouldNotDestroy, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NetAcc_InternalError", (long) XMLExcepts::NetAcc_InternalError, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NetAcc_InitFailed", (long) XMLExcepts::NetAcc_InitFailed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NetAcc_TargetResolution", (long) XMLExcepts::NetAcc_TargetResolution, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NetAcc_CreateSocket", (long) XMLExcepts::NetAcc_CreateSocket, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NetAcc_ConnSocket", (long) XMLExcepts::NetAcc_ConnSocket, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NetAcc_WriteSocket", (long) XMLExcepts::NetAcc_WriteSocket, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NetAcc_ReadSocket", (long) XMLExcepts::NetAcc_ReadSocket, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Pool_ElemAlreadyExists", (long) XMLExcepts::Pool_ElemAlreadyExists, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Pool_BadHashFromKey", (long) XMLExcepts::Pool_BadHashFromKey, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Pool_InvalidId", (long) XMLExcepts::Pool_InvalidId, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Pool_ZeroModulus", (long) XMLExcepts::Pool_ZeroModulus, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_RdrMgr_ReaderIdNotFound", (long) XMLExcepts::RdrMgr_ReaderIdNotFound, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Reader_BadAutoEncoding", (long) XMLExcepts::Reader_BadAutoEncoding, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Reader_CouldNotDecodeFirstLine", (long) XMLExcepts::Reader_CouldNotDecodeFirstLine, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Reader_EOIInMultiSeq", (long) XMLExcepts::Reader_EOIInMultiSeq, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Reader_SrcOfsNotSupported", (long) XMLExcepts::Reader_SrcOfsNotSupported, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Reader_EncodingStrRequired", (long) XMLExcepts::Reader_EncodingStrRequired, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Scan_CouldNotOpenSource", (long) XMLExcepts::Scan_CouldNotOpenSource, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Scan_UnbalancedStartEnd", (long) XMLExcepts::Scan_UnbalancedStartEnd, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Scan_BadPScanToken", (long) XMLExcepts::Scan_BadPScanToken, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Stack_BadIndex", (long) XMLExcepts::Stack_BadIndex, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Stack_EmptyStack", (long) XMLExcepts::Stack_EmptyStack, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Str_ZeroSizedTargetBuf", (long) XMLExcepts::Str_ZeroSizedTargetBuf, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Str_UnknownRadix", (long) XMLExcepts::Str_UnknownRadix, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Str_TargetBufTooSmall", (long) XMLExcepts::Str_TargetBufTooSmall, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Str_StartIndexPastEnd", (long) XMLExcepts::Str_StartIndexPastEnd, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Str_ConvertOverflow", (long) XMLExcepts::Str_ConvertOverflow, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Strm_StdErrWriteFailure", (long) XMLExcepts::Strm_StdErrWriteFailure, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Strm_StdOutWriteFailure", (long) XMLExcepts::Strm_StdOutWriteFailure, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Strm_ConWriteFailure", (long) XMLExcepts::Strm_ConWriteFailure, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_StrPool_IllegalId", (long) XMLExcepts::StrPool_IllegalId, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_CouldNotCreateDefCvtr", (long) XMLExcepts::Trans_CouldNotCreateDefCvtr, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_InvalidSizeReq", (long) XMLExcepts::Trans_InvalidSizeReq, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_Unrepresentable", (long) XMLExcepts::Trans_Unrepresentable, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_NotValidForEncoding", (long) XMLExcepts::Trans_NotValidForEncoding, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_BadBlockSize", (long) XMLExcepts::Trans_BadBlockSize, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_BadSrcSeq", (long) XMLExcepts::Trans_BadSrcSeq, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_BadSrcCP", (long) XMLExcepts::Trans_BadSrcCP, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_BadTrailingSurrogate", (long) XMLExcepts::Trans_BadTrailingSurrogate, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Trans_CantCreateCvtrFor", (long) XMLExcepts::Trans_CantCreateCvtrFor, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_MalformedURL", (long) XMLExcepts::URL_MalformedURL, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_UnsupportedProto", (long) XMLExcepts::URL_UnsupportedProto, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_UnsupportedProto1", (long) XMLExcepts::URL_UnsupportedProto1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_OnlyLocalHost", (long) XMLExcepts::URL_OnlyLocalHost, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_NoProtocolPresent", (long) XMLExcepts::URL_NoProtocolPresent, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_ExpectingTwoSlashes", (long) XMLExcepts::URL_ExpectingTwoSlashes, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_IncorrectEscapedCharRef", (long) XMLExcepts::URL_IncorrectEscapedCharRef, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_UnterminatedHostComponent", (long) XMLExcepts::URL_UnterminatedHostComponent, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_RelativeBaseURL", (long) XMLExcepts::URL_RelativeBaseURL, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_BaseUnderflow", (long) XMLExcepts::URL_BaseUnderflow, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_URL_BadPortField", (long) XMLExcepts::URL_BadPortField, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Vector_BadIndex", (long) XMLExcepts::Vector_BadIndex, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Val_InvalidElemId", (long) XMLExcepts::Val_InvalidElemId, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Val_CantHaveIntSS", (long) XMLExcepts::Val_CantHaveIntSS, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLRec_UnknownEncoding", (long) XMLExcepts::XMLRec_UnknownEncoding, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Parse1", (long) XMLExcepts::Parser_Parse1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Parse2", (long) XMLExcepts::Parser_Parse2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Next1", (long) XMLExcepts::Parser_Next1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Next2", (long) XMLExcepts::Parser_Next2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Next3", (long) XMLExcepts::Parser_Next3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Next4", (long) XMLExcepts::Parser_Next4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Factor1", (long) XMLExcepts::Parser_Factor1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Factor2", (long) XMLExcepts::Parser_Factor2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Factor3", (long) XMLExcepts::Parser_Factor3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Factor4", (long) XMLExcepts::Parser_Factor4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Factor5", (long) XMLExcepts::Parser_Factor5, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Factor6", (long) XMLExcepts::Parser_Factor6, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Atom1", (long) XMLExcepts::Parser_Atom1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Atom2", (long) XMLExcepts::Parser_Atom2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Atom3", (long) XMLExcepts::Parser_Atom3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Atom4", (long) XMLExcepts::Parser_Atom4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Atom5", (long) XMLExcepts::Parser_Atom5, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_CC1", (long) XMLExcepts::Parser_CC1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_CC2", (long) XMLExcepts::Parser_CC2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_CC3", (long) XMLExcepts::Parser_CC3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_CC4", (long) XMLExcepts::Parser_CC4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_CC5", (long) XMLExcepts::Parser_CC5, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_CC6", (long) XMLExcepts::Parser_CC6, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_CC7", (long) XMLExcepts::Parser_CC7, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Ope1", (long) XMLExcepts::Parser_Ope1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Ope2", (long) XMLExcepts::Parser_Ope2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Ope3", (long) XMLExcepts::Parser_Ope3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Descape1", (long) XMLExcepts::Parser_Descape1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Descape2", (long) XMLExcepts::Parser_Descape2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Descape3", (long) XMLExcepts::Parser_Descape3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Descape4", (long) XMLExcepts::Parser_Descape4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Descape5", (long) XMLExcepts::Parser_Descape5, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Process1", (long) XMLExcepts::Parser_Process1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Parser_Process2", (long) XMLExcepts::Parser_Process2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Gen_NoSchemaValidator", (long) XMLExcepts::Gen_NoSchemaValidator, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XUTIL_UnCopyableNodeType", (long) XMLExcepts::XUTIL_UnCopyableNodeType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_SubGrpComparator_NGR", (long) XMLExcepts::SubGrpComparator_NGR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_Len", (long) XMLExcepts::FACET_Invalid_Len, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_maxLen", (long) XMLExcepts::FACET_Invalid_maxLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_minLen", (long) XMLExcepts::FACET_Invalid_minLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_NonNeg_Len", (long) XMLExcepts::FACET_NonNeg_Len, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_NonNeg_maxLen", (long) XMLExcepts::FACET_NonNeg_maxLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_NonNeg_minLen", (long) XMLExcepts::FACET_NonNeg_minLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Len_maxLen", (long) XMLExcepts::FACET_Len_maxLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Len_minLen", (long) XMLExcepts::FACET_Len_minLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxLen_minLen", (long) XMLExcepts::FACET_maxLen_minLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_bool_Pattern", (long) XMLExcepts::FACET_bool_Pattern, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_Tag", (long) XMLExcepts::FACET_Invalid_Tag, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Len_baseLen", (long) XMLExcepts::FACET_Len_baseLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minLen_baseminLen", (long) XMLExcepts::FACET_minLen_baseminLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minLen_basemaxLen", (long) XMLExcepts::FACET_minLen_basemaxLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxLen_basemaxLen", (long) XMLExcepts::FACET_maxLen_basemaxLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxLen_baseminLen", (long) XMLExcepts::FACET_maxLen_baseminLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_enum_base", (long) XMLExcepts::FACET_enum_base, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_WS", (long) XMLExcepts::FACET_Invalid_WS, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_WS_collapse", (long) XMLExcepts::FACET_WS_collapse, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_WS_replace", (long) XMLExcepts::FACET_WS_replace, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_MaxIncl", (long) XMLExcepts::FACET_Invalid_MaxIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_MaxExcl", (long) XMLExcepts::FACET_Invalid_MaxExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_MinIncl", (long) XMLExcepts::FACET_Invalid_MinIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_MinExcl", (long) XMLExcepts::FACET_Invalid_MinExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_TotalDigit", (long) XMLExcepts::FACET_Invalid_TotalDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Invalid_FractDigit", (long) XMLExcepts::FACET_Invalid_FractDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_NonNeg_TotalDigit", (long) XMLExcepts::FACET_NonNeg_TotalDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_NonNeg_FractDigit", (long) XMLExcepts::FACET_NonNeg_FractDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_max_Incl_Excl", (long) XMLExcepts::FACET_max_Incl_Excl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_min_Incl_Excl", (long) XMLExcepts::FACET_min_Incl_Excl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_minExcl", (long) XMLExcepts::FACET_maxExcl_minExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_minIncl", (long) XMLExcepts::FACET_maxExcl_minIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_minExcl", (long) XMLExcepts::FACET_maxIncl_minExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_minIncl", (long) XMLExcepts::FACET_maxIncl_minIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_TotDigit_FractDigit", (long) XMLExcepts::FACET_TotDigit_FractDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_base_maxExcl", (long) XMLExcepts::FACET_maxIncl_base_maxExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_base_maxIncl", (long) XMLExcepts::FACET_maxIncl_base_maxIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_base_minIncl", (long) XMLExcepts::FACET_maxIncl_base_minIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_base_minExcl", (long) XMLExcepts::FACET_maxIncl_base_minExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_base_maxExcl", (long) XMLExcepts::FACET_maxExcl_base_maxExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_base_maxIncl", (long) XMLExcepts::FACET_maxExcl_base_maxIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_base_minIncl", (long) XMLExcepts::FACET_maxExcl_base_minIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_base_minExcl", (long) XMLExcepts::FACET_maxExcl_base_minExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minExcl_base_maxExcl", (long) XMLExcepts::FACET_minExcl_base_maxExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minExcl_base_maxIncl", (long) XMLExcepts::FACET_minExcl_base_maxIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minExcl_base_minIncl", (long) XMLExcepts::FACET_minExcl_base_minIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minExcl_base_minExcl", (long) XMLExcepts::FACET_minExcl_base_minExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minIncl_base_maxExcl", (long) XMLExcepts::FACET_minIncl_base_maxExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minIncl_base_maxIncl", (long) XMLExcepts::FACET_minIncl_base_maxIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minIncl_base_minIncl", (long) XMLExcepts::FACET_minIncl_base_minIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minIncl_base_minExcl", (long) XMLExcepts::FACET_minIncl_base_minExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_notFromBase", (long) XMLExcepts::FACET_maxIncl_notFromBase, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_notFromBase", (long) XMLExcepts::FACET_maxExcl_notFromBase, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minIncl_notFromBase", (long) XMLExcepts::FACET_minIncl_notFromBase, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minExcl_notFromBase", (long) XMLExcepts::FACET_minExcl_notFromBase, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_totalDigit_base_totalDigit", (long) XMLExcepts::FACET_totalDigit_base_totalDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_fractDigit_base_totalDigit", (long) XMLExcepts::FACET_fractDigit_base_totalDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_fractDigit_base_fractDigit", (long) XMLExcepts::FACET_fractDigit_base_fractDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxIncl_base_fixed", (long) XMLExcepts::FACET_maxIncl_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxExcl_base_fixed", (long) XMLExcepts::FACET_maxExcl_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minIncl_base_fixed", (long) XMLExcepts::FACET_minIncl_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minExcl_base_fixed", (long) XMLExcepts::FACET_minExcl_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_totalDigit_base_fixed", (long) XMLExcepts::FACET_totalDigit_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_fractDigit_base_fixed", (long) XMLExcepts::FACET_fractDigit_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_maxLen_base_fixed", (long) XMLExcepts::FACET_maxLen_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_minLen_base_fixed", (long) XMLExcepts::FACET_minLen_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_len_base_fixed", (long) XMLExcepts::FACET_len_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_whitespace_base_fixed", (long) XMLExcepts::FACET_whitespace_base_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_internalError_fixed", (long) XMLExcepts::FACET_internalError_fixed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_List_Null_baseValidator", (long) XMLExcepts::FACET_List_Null_baseValidator, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Union_Null_memberTypeValidators", (long) XMLExcepts::FACET_Union_Null_memberTypeValidators, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Union_Null_baseValidator", (long) XMLExcepts::FACET_Union_Null_baseValidator, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_FACET_Union_invalid_baseValidatorType", (long) XMLExcepts::FACET_Union_invalid_baseValidatorType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_NotMatch_Pattern", (long) XMLExcepts::VALUE_NotMatch_Pattern, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_Not_Base64", (long) XMLExcepts::VALUE_Not_Base64, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_Not_HexBin", (long) XMLExcepts::VALUE_Not_HexBin, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_GT_maxLen", (long) XMLExcepts::VALUE_GT_maxLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_LT_minLen", (long) XMLExcepts::VALUE_LT_minLen, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_NE_Len", (long) XMLExcepts::VALUE_NE_Len, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_NotIn_Enumeration", (long) XMLExcepts::VALUE_NotIn_Enumeration, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_exceed_totalDigit", (long) XMLExcepts::VALUE_exceed_totalDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_exceed_fractDigit", (long) XMLExcepts::VALUE_exceed_fractDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_exceed_maxIncl", (long) XMLExcepts::VALUE_exceed_maxIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_exceed_maxExcl", (long) XMLExcepts::VALUE_exceed_maxExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_exceed_minIncl", (long) XMLExcepts::VALUE_exceed_minIncl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_exceed_minExcl", (long) XMLExcepts::VALUE_exceed_minExcl, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_WS_replaced", (long) XMLExcepts::VALUE_WS_replaced, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_WS_collapsed", (long) XMLExcepts::VALUE_WS_collapsed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_Invalid_NCName", (long) XMLExcepts::VALUE_Invalid_NCName, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_Invalid_Name", (long) XMLExcepts::VALUE_Invalid_Name, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_ID_Not_Unique", (long) XMLExcepts::VALUE_ID_Not_Unique, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_ENTITY_Invalid", (long) XMLExcepts::VALUE_ENTITY_Invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_QName_Invalid", (long) XMLExcepts::VALUE_QName_Invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_NOTATION_Invalid", (long) XMLExcepts::VALUE_NOTATION_Invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_no_match_memberType", (long) XMLExcepts::VALUE_no_match_memberType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_VALUE_URI_Malformed", (long) XMLExcepts::VALUE_URI_Malformed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_emptyString", (long) XMLExcepts::XMLNUM_emptyString, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_WSString", (long) XMLExcepts::XMLNUM_WSString, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_2ManyDecPoint", (long) XMLExcepts::XMLNUM_2ManyDecPoint, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_Inv_chars", (long) XMLExcepts::XMLNUM_Inv_chars, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_null_ptr", (long) XMLExcepts::XMLNUM_null_ptr, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_Component_Empty", (long) XMLExcepts::XMLNUM_URI_Component_Empty, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_Component_for_GenURI_Only", (long) XMLExcepts::XMLNUM_URI_Component_for_GenURI_Only, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_Component_Invalid_EscapeSequence", (long) XMLExcepts::XMLNUM_URI_Component_Invalid_EscapeSequence, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_Component_Invalid_Char", (long) XMLExcepts::XMLNUM_URI_Component_Invalid_Char, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_Component_Set_Null", (long) XMLExcepts::XMLNUM_URI_Component_Set_Null, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_Component_Not_Conformant", (long) XMLExcepts::XMLNUM_URI_Component_Not_Conformant, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_No_Scheme", (long) XMLExcepts::XMLNUM_URI_No_Scheme, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_NullHost", (long) XMLExcepts::XMLNUM_URI_NullHost, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_NullPath", (long) XMLExcepts::XMLNUM_URI_NullPath, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_Component_inPath", (long) XMLExcepts::XMLNUM_URI_Component_inPath, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_URI_PortNo_Invalid", (long) XMLExcepts::XMLNUM_URI_PortNo_Invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_DBL_FLT_maxNeg", (long) XMLExcepts::XMLNUM_DBL_FLT_maxNeg, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_DBL_FLT_maxPos", (long) XMLExcepts::XMLNUM_DBL_FLT_maxPos, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_DBL_FLT_minNegPos", (long) XMLExcepts::XMLNUM_DBL_FLT_minNegPos, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_DBL_FLT_InvalidType", (long) XMLExcepts::XMLNUM_DBL_FLT_InvalidType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XMLNUM_DBL_FLT_No_Exponent", (long) XMLExcepts::XMLNUM_DBL_FLT_No_Exponent, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_Result_Not_Set", (long) XMLExcepts::Regex_Result_Not_Set, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_CompactRangesError", (long) XMLExcepts::Regex_CompactRangesError, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_MergeRangesTypeMismatch", (long) XMLExcepts::Regex_MergeRangesTypeMismatch, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_SubtractRangesError", (long) XMLExcepts::Regex_SubtractRangesError, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_IntersectRangesError", (long) XMLExcepts::Regex_IntersectRangesError, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_ComplementRangesInvalidArg", (long) XMLExcepts::Regex_ComplementRangesInvalidArg, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_InvalidCategoryName", (long) XMLExcepts::Regex_InvalidCategoryName, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_KeywordNotFound", (long) XMLExcepts::Regex_KeywordNotFound, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_BadRefNo", (long) XMLExcepts::Regex_BadRefNo, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_UnknownOption", (long) XMLExcepts::Regex_UnknownOption, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_UnknownTokenType", (long) XMLExcepts::Regex_UnknownTokenType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_RangeTokenGetError", (long) XMLExcepts::Regex_RangeTokenGetError, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_NotSupported", (long) XMLExcepts::Regex_NotSupported, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_InvalidChildIndex", (long) XMLExcepts::Regex_InvalidChildIndex, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Regex_InvalidQuantifier", (long) XMLExcepts::Regex_InvalidQuantifier, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NEL_RepeatedCalls", (long) XMLExcepts::NEL_RepeatedCalls, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_RethrowError", (long) XMLExcepts::RethrowError, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_Out_Of_Memory", (long) XMLExcepts::Out_Of_Memory, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DV_InvalidOperation", (long) XMLExcepts::DV_InvalidOperation, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoAttrSelector", (long) XMLExcepts::XPath_NoAttrSelector, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoUnionAtStart", (long) XMLExcepts::XPath_NoUnionAtStart, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoMultipleUnion", (long) XMLExcepts::XPath_NoMultipleUnion, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_MissingAttr", (long) XMLExcepts::XPath_MissingAttr, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_ExpectedToken1", (long) XMLExcepts::XPath_ExpectedToken1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_PrefixNoURI", (long) XMLExcepts::XPath_PrefixNoURI, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoDoubleColon", (long) XMLExcepts::XPath_NoDoubleColon, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_ExpectedStep1", (long) XMLExcepts::XPath_ExpectedStep1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_ExpectedStep2", (long) XMLExcepts::XPath_ExpectedStep2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_ExpectedStep3", (long) XMLExcepts::XPath_ExpectedStep3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoForwardSlash", (long) XMLExcepts::XPath_NoForwardSlash, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoDoubleForwardSlash", (long) XMLExcepts::XPath_NoDoubleForwardSlash, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoForwardSlashAtStart", (long) XMLExcepts::XPath_NoForwardSlashAtStart, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoSelectionOfRoot", (long) XMLExcepts::XPath_NoSelectionOfRoot, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_EmptyExpr", (long) XMLExcepts::XPath_EmptyExpr, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_NoUnionAtEnd", (long) XMLExcepts::XPath_NoUnionAtEnd, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_InvalidChar", (long) XMLExcepts::XPath_InvalidChar, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_TokenNotSupported", (long) XMLExcepts::XPath_TokenNotSupported, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_XPath_FindSolution", (long) XMLExcepts::XPath_FindSolution, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_Assert_Buffer_Fail", (long) XMLExcepts::DateTime_Assert_Buffer_Fail, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_dt_missingT", (long) XMLExcepts::DateTime_dt_missingT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_gDay_invalid", (long) XMLExcepts::DateTime_gDay_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_gMth_invalid", (long) XMLExcepts::DateTime_gMth_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_gMthDay_invalid", (long) XMLExcepts::DateTime_gMthDay_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_dur_Start_dashP", (long) XMLExcepts::DateTime_dur_Start_dashP, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_dur_noP", (long) XMLExcepts::DateTime_dur_noP, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_dur_DashNotFirst", (long) XMLExcepts::DateTime_dur_DashNotFirst, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_dur_inv_b4T", (long) XMLExcepts::DateTime_dur_inv_b4T, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_dur_NoTimeAfterT", (long) XMLExcepts::DateTime_dur_NoTimeAfterT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_dur_NoElementAtAll", (long) XMLExcepts::DateTime_dur_NoElementAtAll, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_date_incomplete", (long) XMLExcepts::DateTime_date_incomplete, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_date_invalid", (long) XMLExcepts::DateTime_date_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_time_incomplete", (long) XMLExcepts::DateTime_time_incomplete, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_time_invalid", (long) XMLExcepts::DateTime_time_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_ms_noDigit", (long) XMLExcepts::DateTime_ms_noDigit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_ym_incomplete", (long) XMLExcepts::DateTime_ym_incomplete, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_ym_invalid", (long) XMLExcepts::DateTime_ym_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_year_tooShort", (long) XMLExcepts::DateTime_year_tooShort, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_year_leadingZero", (long) XMLExcepts::DateTime_year_leadingZero, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_ym_noMonth", (long) XMLExcepts::DateTime_ym_noMonth, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_tz_noUTCsign", (long) XMLExcepts::DateTime_tz_noUTCsign, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_tz_stuffAfterZ", (long) XMLExcepts::DateTime_tz_stuffAfterZ, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_tz_invalid", (long) XMLExcepts::DateTime_tz_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_year_zero", (long) XMLExcepts::DateTime_year_zero, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_mth_invalid", (long) XMLExcepts::DateTime_mth_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_day_invalid", (long) XMLExcepts::DateTime_day_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_hour_invalid", (long) XMLExcepts::DateTime_hour_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_min_invalid", (long) XMLExcepts::DateTime_min_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_second_invalid", (long) XMLExcepts::DateTime_second_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_DateTime_tz_hh_invalid", (long) XMLExcepts::DateTime_tz_hh_invalid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NSCompat1", (long) XMLExcepts::PD_NSCompat1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_OccurRangeE", (long) XMLExcepts::PD_OccurRangeE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NameTypeOK1", (long) XMLExcepts::PD_NameTypeOK1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NameTypeOK2", (long) XMLExcepts::PD_NameTypeOK2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NameTypeOK3", (long) XMLExcepts::PD_NameTypeOK3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NameTypeOK4", (long) XMLExcepts::PD_NameTypeOK4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NameTypeOK5", (long) XMLExcepts::PD_NameTypeOK5, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NameTypeOK6", (long) XMLExcepts::PD_NameTypeOK6, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NameTypeOK7", (long) XMLExcepts::PD_NameTypeOK7, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_RecurseAsIfGroup", (long) XMLExcepts::PD_RecurseAsIfGroup, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_Recurse1", (long) XMLExcepts::PD_Recurse1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_Recurse2", (long) XMLExcepts::PD_Recurse2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_ForbiddenRes1", (long) XMLExcepts::PD_ForbiddenRes1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_ForbiddenRes2", (long) XMLExcepts::PD_ForbiddenRes2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_ForbiddenRes3", (long) XMLExcepts::PD_ForbiddenRes3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_ForbiddenRes4", (long) XMLExcepts::PD_ForbiddenRes4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NSSubset1", (long) XMLExcepts::PD_NSSubset1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NSSubset2", (long) XMLExcepts::PD_NSSubset2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_NSRecurseCheckCardinality1", (long) XMLExcepts::PD_NSRecurseCheckCardinality1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_RecurseUnordered", (long) XMLExcepts::PD_RecurseUnordered, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_MapAndSum", (long) XMLExcepts::PD_MapAndSum, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_PD_InvalidContentType", (long) XMLExcepts::PD_InvalidContentType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_NodeIDMap_GrowErr", (long) XMLExcepts::NodeIDMap_GrowErr, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_F_HighBounds", (long) XMLExcepts::F_HighBounds, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_E_LowBounds", (long) XMLExcepts::E_LowBounds, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLExcepts_E_HighBounds", (long) XMLExcepts::E_HighBounds, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Decl_Text", (long) XMLScanner::Decl_Text, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Decl_XML", (long) XMLScanner::Decl_XML, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_EntityExp_Pushed", (long) XMLScanner::EntityExp_Pushed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_EntityExp_Returned", (long) XMLScanner::EntityExp_Returned, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_EntityExp_Failed", (long) XMLScanner::EntityExp_Failed, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_CData", (long) XMLScanner::Token_CData, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_CharData", (long) XMLScanner::Token_CharData, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_Comment", (long) XMLScanner::Token_Comment, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_EndTag", (long) XMLScanner::Token_EndTag, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_EOF", (long) XMLScanner::Token_EOF, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_PI", (long) XMLScanner::Token_PI, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_StartTag", (long) XMLScanner::Token_StartTag, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Token_Unknown", (long) XMLScanner::Token_Unknown, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Val_Never", (long) XMLScanner::Val_Never, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Val_Always", (long) XMLScanner::Val_Always, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "XMLScanner_Val_Auto", (long) XMLScanner::Val_Auto, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SAX2XMLReader_Val_Never", (long) SAX2XMLReader::Val_Never, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SAX2XMLReader_Val_Always", (long) SAX2XMLReader::Val_Always, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SAX2XMLReader_Val_Auto", (long) SAX2XMLReader::Val_Auto, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SAXParser_Val_Never", (long) SAXParser::Val_Never, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SAXParser_Val_Always", (long) SAXParser::Val_Always, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "SAXParser_Val_Auto", (long) SAXParser::Val_Auto, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOMParser_Val_Never", (long) IDOMParser::Val_Never, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOMParser_Val_Always", (long) IDOMParser::Val_Always, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOMParser_Val_Auto", (long) IDOMParser::Val_Auto, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "Grammar_DTDGrammarType", (long) Grammar::DTDGrammarType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "Grammar_SchemaGrammarType", (long) Grammar::SchemaGrammarType, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "Grammar_UNKNOWN_SCOPE", (long) Grammar::UNKNOWN_SCOPE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "Grammar_TOP_LEVEL_SCOPE", (long) Grammar::TOP_LEVEL_SCOPE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_ELEMENT_NODE", (long) IDOM_Node::ELEMENT_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_ATTRIBUTE_NODE", (long) IDOM_Node::ATTRIBUTE_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_TEXT_NODE", (long) IDOM_Node::TEXT_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_CDATA_SECTION_NODE", (long) IDOM_Node::CDATA_SECTION_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_ENTITY_REFERENCE_NODE", (long) IDOM_Node::ENTITY_REFERENCE_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_ENTITY_NODE", (long) IDOM_Node::ENTITY_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_PROCESSING_INSTRUCTION_NODE", (long) IDOM_Node::PROCESSING_INSTRUCTION_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_COMMENT_NODE", (long) IDOM_Node::COMMENT_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_DOCUMENT_NODE", (long) IDOM_Node::DOCUMENT_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_DOCUMENT_TYPE_NODE", (long) IDOM_Node::DOCUMENT_TYPE_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_DOCUMENT_FRAGMENT_NODE", (long) IDOM_Node::DOCUMENT_FRAGMENT_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_NOTATION_NODE", (long) IDOM_Node::NOTATION_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Node_XML_DECL_NODE", (long) IDOM_Node::XML_DECL_NODE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_INDEX_SIZE_ERR", (long) IDOM_DOMException::INDEX_SIZE_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_DOMSTRING_SIZE_ERR", (long) IDOM_DOMException::DOMSTRING_SIZE_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_HIERARCHY_REQUEST_ERR", (long) IDOM_DOMException::HIERARCHY_REQUEST_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_WRONG_DOCUMENT_ERR", (long) IDOM_DOMException::WRONG_DOCUMENT_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_INVALID_CHARACTER_ERR", (long) IDOM_DOMException::INVALID_CHARACTER_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_NO_DATA_ALLOWED_ERR", (long) IDOM_DOMException::NO_DATA_ALLOWED_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_NO_MODIFICATION_ALLOWED_ERR", (long) IDOM_DOMException::NO_MODIFICATION_ALLOWED_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_NOT_FOUND_ERR", (long) IDOM_DOMException::NOT_FOUND_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_NOT_SUPPORTED_ERR", (long) IDOM_DOMException::NOT_SUPPORTED_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_INUSE_ATTRIBUTE_ERR", (long) IDOM_DOMException::INUSE_ATTRIBUTE_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_INVALID_STATE_ERR", (long) IDOM_DOMException::INVALID_STATE_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_SYNTAX_ERR", (long) IDOM_DOMException::SYNTAX_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_INVALID_MODIFICATION_ERR", (long) IDOM_DOMException::INVALID_MODIFICATION_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_NAMESPACE_ERR", (long) IDOM_DOMException::NAMESPACE_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_DOMException_INVALID_ACCESS_ERR", (long) IDOM_DOMException::INVALID_ACCESS_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_FILTER_ACCEPT", (long) IDOM_NodeFilter::FILTER_ACCEPT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_FILTER_REJECT", (long) IDOM_NodeFilter::FILTER_REJECT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_FILTER_SKIP", (long) IDOM_NodeFilter::FILTER_SKIP, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_ALL", (long) IDOM_NodeFilter::SHOW_ALL, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_ELEMENT", (long) IDOM_NodeFilter::SHOW_ELEMENT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_ATTRIBUTE", (long) IDOM_NodeFilter::SHOW_ATTRIBUTE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_TEXT", (long) IDOM_NodeFilter::SHOW_TEXT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_CDATA_SECTION", (long) IDOM_NodeFilter::SHOW_CDATA_SECTION, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_ENTITY_REFERENCE", (long) IDOM_NodeFilter::SHOW_ENTITY_REFERENCE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_ENTITY", (long) IDOM_NodeFilter::SHOW_ENTITY, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_PROCESSING_INSTRUCTION", (long) IDOM_NodeFilter::SHOW_PROCESSING_INSTRUCTION, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_COMMENT", (long) IDOM_NodeFilter::SHOW_COMMENT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_DOCUMENT", (long) IDOM_NodeFilter::SHOW_DOCUMENT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_DOCUMENT_TYPE", (long) IDOM_NodeFilter::SHOW_DOCUMENT_TYPE, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_DOCUMENT_FRAGMENT", (long) IDOM_NodeFilter::SHOW_DOCUMENT_FRAGMENT, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_NodeFilter_SHOW_NOTATION", (long) IDOM_NodeFilter::SHOW_NOTATION, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Range_START_TO_START", (long) IDOM_Range::START_TO_START, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Range_START_TO_END", (long) IDOM_Range::START_TO_END, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Range_END_TO_END", (long) IDOM_Range::END_TO_END, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_Range_END_TO_START", (long) IDOM_Range::END_TO_START, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_RangeException_BAD_BOUNDARYPOINTS_ERR", (long) IDOM_RangeException::BAD_BOUNDARYPOINTS_ERR, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DOM_RangeException_INVALID_NODE_TYPE_ERR", (long) IDOM_RangeException::INVALID_NODE_TYPE_ERR, 0, 0, 0},
{0}
};
#ifdef __cplusplus
}
#endif
static swig_variable_info swig_variables[] = {
    { "XML::Xercesc::DEBUG_UTF8_OUT", MAGIC_CLASS _wrap_set_DEBUG_UTF8_OUT, MAGIC_CLASS _wrap_val_DEBUG_UTF8_OUT,0 },
    { "XML::Xercesc::DEBUG_UTF8_IN", MAGIC_CLASS _wrap_set_DEBUG_UTF8_IN, MAGIC_CLASS _wrap_val_DEBUG_UTF8_IN,0 },
{0}
};
static swig_command_info swig_commands[] = {
{"XML::Xercesc::new_PerlNodeFilterCallbackHandler", _wrap_new_PerlNodeFilterCallbackHandler},
{"XML::Xercesc::new_PerlNodeFilterCallbackHandler__constructor__arg", _wrap_new_PerlNodeFilterCallbackHandler__constructor__arg},
{"XML::Xercesc::PerlNodeFilterCallbackHandler_set_callback_obj", _wrap_PerlNodeFilterCallbackHandler_set_callback_obj},
{"XML::Xercesc::new_PerlDocumentCallbackHandler", _wrap_new_PerlDocumentCallbackHandler},
{"XML::Xercesc::new_PerlDocumentCallbackHandler__constructor__arg", _wrap_new_PerlDocumentCallbackHandler__constructor__arg},
{"XML::Xercesc::PerlDocumentCallbackHandler_set_callback_obj", _wrap_PerlDocumentCallbackHandler_set_callback_obj},
{"XML::Xercesc::new_PerlContentCallbackHandler", _wrap_new_PerlContentCallbackHandler},
{"XML::Xercesc::new_PerlContentCallbackHandler__constructor__arg", _wrap_new_PerlContentCallbackHandler__constructor__arg},
{"XML::Xercesc::PerlContentCallbackHandler_set_callback_obj", _wrap_PerlContentCallbackHandler_set_callback_obj},
{"XML::Xercesc::new_PerlEntityResolverHandler", _wrap_new_PerlEntityResolverHandler},
{"XML::Xercesc::new_PerlEntityResolverHandler__constructor__arg", _wrap_new_PerlEntityResolverHandler__constructor__arg},
{"XML::Xercesc::PerlEntityResolverHandler_set_callback_obj", _wrap_PerlEntityResolverHandler_set_callback_obj},
{"XML::Xercesc::new_PerlErrorCallbackHandler", _wrap_new_PerlErrorCallbackHandler},
{"XML::Xercesc::new_PerlErrorCallbackHandler__constructor__arg", _wrap_new_PerlErrorCallbackHandler__constructor__arg},
{"XML::Xercesc::PerlErrorCallbackHandler_set_callback_obj", _wrap_PerlErrorCallbackHandler_set_callback_obj},
{"XML::Xercesc::delete_XMLDeleter", _wrap_delete_XMLDeleter},
{"XML::Xercesc::XMLPlatformUtils_Initialize", _wrap_XMLPlatformUtils_Initialize},
{"XML::Xercesc::XMLPlatformUtils_Terminate", _wrap_XMLPlatformUtils_Terminate},
{"XML::Xercesc::XMLPlatformUtils_panic", _wrap_XMLPlatformUtils_panic},
{"XML::Xercesc::XMLPlatformUtils_curFilePos", _wrap_XMLPlatformUtils_curFilePos},
{"XML::Xercesc::XMLPlatformUtils_closeFile", _wrap_XMLPlatformUtils_closeFile},
{"XML::Xercesc::XMLPlatformUtils_fileSize", _wrap_XMLPlatformUtils_fileSize},
{"XML::Xercesc::XMLPlatformUtils_openFile", _wrap_XMLPlatformUtils_openFile},
{"XML::Xercesc::XMLPlatformUtils_openStdInHandle", _wrap_XMLPlatformUtils_openStdInHandle},
{"XML::Xercesc::XMLPlatformUtils_readFileBuffer", _wrap_XMLPlatformUtils_readFileBuffer},
{"XML::Xercesc::XMLPlatformUtils_resetFile", _wrap_XMLPlatformUtils_resetFile},
{"XML::Xercesc::XMLPlatformUtils_getFullPath", _wrap_XMLPlatformUtils_getFullPath},
{"XML::Xercesc::XMLPlatformUtils_isRelative", _wrap_XMLPlatformUtils_isRelative},
{"XML::Xercesc::XMLPlatformUtils_weavePaths", _wrap_XMLPlatformUtils_weavePaths},
{"XML::Xercesc::XMLPlatformUtils_getCurrentMillis", _wrap_XMLPlatformUtils_getCurrentMillis},
{"XML::Xercesc::XMLPlatformUtils_closeMutex", _wrap_XMLPlatformUtils_closeMutex},
{"XML::Xercesc::XMLPlatformUtils_lockMutex", _wrap_XMLPlatformUtils_lockMutex},
{"XML::Xercesc::XMLPlatformUtils_makeMutex", _wrap_XMLPlatformUtils_makeMutex},
{"XML::Xercesc::XMLPlatformUtils_unlockMutex", _wrap_XMLPlatformUtils_unlockMutex},
{"XML::Xercesc::XMLPlatformUtils_loadMsgSet", _wrap_XMLPlatformUtils_loadMsgSet},
{"XML::Xercesc::XMLPlatformUtils_compareAndSwap", _wrap_XMLPlatformUtils_compareAndSwap},
{"XML::Xercesc::XMLPlatformUtils_atomicIncrement", _wrap_XMLPlatformUtils_atomicIncrement},
{"XML::Xercesc::XMLPlatformUtils_atomicDecrement", _wrap_XMLPlatformUtils_atomicDecrement},
{"XML::Xercesc::XMLPlatformUtils_recognizeNEL", _wrap_XMLPlatformUtils_recognizeNEL},
{"XML::Xercesc::XMLPlatformUtils_isNELRecognized", _wrap_XMLPlatformUtils_isNELRecognized},
{"XML::Xercesc::XMLURL_lookupByName", _wrap_XMLURL_lookupByName},
{"XML::Xercesc::new_XMLURL", _wrap_new_XMLURL},
{"XML::Xercesc::new_XMLURL__constructor__base", _wrap_new_XMLURL__constructor__base},
{"XML::Xercesc::new_XMLURL__constructor__url_base", _wrap_new_XMLURL__constructor__url_base},
{"XML::Xercesc::new_XMLURL__constructor__text", _wrap_new_XMLURL__constructor__text},
{"XML::Xercesc::new_XMLURL__constructor__copy", _wrap_new_XMLURL__constructor__copy},
{"XML::Xercesc::delete_XMLURL", _wrap_delete_XMLURL},
{"XML::Xercesc::XMLURL_operator_assignment", _wrap_XMLURL_operator_assignment},
{"XML::Xercesc::XMLURL_operator_equal_to", _wrap_XMLURL_operator_equal_to},
{"XML::Xercesc::XMLURL_operator_not_equal_to", _wrap_XMLURL_operator_not_equal_to},
{"XML::Xercesc::XMLURL_getFragment", _wrap_XMLURL_getFragment},
{"XML::Xercesc::XMLURL_getHost", _wrap_XMLURL_getHost},
{"XML::Xercesc::XMLURL_getPassword", _wrap_XMLURL_getPassword},
{"XML::Xercesc::XMLURL_getPath", _wrap_XMLURL_getPath},
{"XML::Xercesc::XMLURL_getPortNum", _wrap_XMLURL_getPortNum},
{"XML::Xercesc::XMLURL_getProtocol", _wrap_XMLURL_getProtocol},
{"XML::Xercesc::XMLURL_getProtocolName", _wrap_XMLURL_getProtocolName},
{"XML::Xercesc::XMLURL_getQuery", _wrap_XMLURL_getQuery},
{"XML::Xercesc::XMLURL_getURLText", _wrap_XMLURL_getURLText},
{"XML::Xercesc::XMLURL_getUser", _wrap_XMLURL_getUser},
{"XML::Xercesc::XMLURL_setURL", _wrap_XMLURL_setURL},
{"XML::Xercesc::XMLURL_setURL__overload__string", _wrap_XMLURL_setURL__overload__string},
{"XML::Xercesc::XMLURL_setURL__overload__XMLURL", _wrap_XMLURL_setURL__overload__XMLURL},
{"XML::Xercesc::XMLURL_isRelative", _wrap_XMLURL_isRelative},
{"XML::Xercesc::XMLURL_makeNewStream", _wrap_XMLURL_makeNewStream},
{"XML::Xercesc::XMLURL_makeRelativeTo", _wrap_XMLURL_makeRelativeTo},
{"XML::Xercesc::XMLURL_makeRelativeTo__overload__XMLURL", _wrap_XMLURL_makeRelativeTo__overload__XMLURL},
{"XML::Xercesc::new_XMLUri__constructor__uri", _wrap_new_XMLUri__constructor__uri},
{"XML::Xercesc::new_XMLUri", _wrap_new_XMLUri},
{"XML::Xercesc::delete_XMLUri", _wrap_delete_XMLUri},
{"XML::Xercesc::XMLUri_getScheme", _wrap_XMLUri_getScheme},
{"XML::Xercesc::XMLUri_getUserInfo", _wrap_XMLUri_getUserInfo},
{"XML::Xercesc::XMLUri_getHost", _wrap_XMLUri_getHost},
{"XML::Xercesc::XMLUri_getPort", _wrap_XMLUri_getPort},
{"XML::Xercesc::XMLUri_getPath", _wrap_XMLUri_getPath},
{"XML::Xercesc::XMLUri_getQueryString", _wrap_XMLUri_getQueryString},
{"XML::Xercesc::XMLUri_getFragment", _wrap_XMLUri_getFragment},
{"XML::Xercesc::XMLUri_setScheme", _wrap_XMLUri_setScheme},
{"XML::Xercesc::XMLUri_setUserInfo", _wrap_XMLUri_setUserInfo},
{"XML::Xercesc::XMLUri_setHost", _wrap_XMLUri_setHost},
{"XML::Xercesc::XMLUri_setPort", _wrap_XMLUri_setPort},
{"XML::Xercesc::XMLUri_setPath", _wrap_XMLUri_setPath},
{"XML::Xercesc::XMLUri_setQueryString", _wrap_XMLUri_setQueryString},
{"XML::Xercesc::XMLUri_setFragment", _wrap_XMLUri_setFragment},
{"XML::Xercesc::new_QName", _wrap_new_QName},
{"XML::Xercesc::delete_QName", _wrap_delete_QName},
{"XML::Xercesc::QName_getPrefix", _wrap_QName_getPrefix},
{"XML::Xercesc::QName_getLocalPart", _wrap_QName_getLocalPart},
{"XML::Xercesc::QName_getURI", _wrap_QName_getURI},
{"XML::Xercesc::QName_getRawName", _wrap_QName_getRawName},
{"XML::Xercesc::QName_setName", _wrap_QName_setName},
{"XML::Xercesc::QName_setPrefix", _wrap_QName_setPrefix},
{"XML::Xercesc::QName_setLocalPart", _wrap_QName_setLocalPart},
{"XML::Xercesc::QName_setNPrefix", _wrap_QName_setNPrefix},
{"XML::Xercesc::QName_setNLocalPart", _wrap_QName_setNLocalPart},
{"XML::Xercesc::QName_setURI", _wrap_QName_setURI},
{"XML::Xercesc::QName_setValues", _wrap_QName_setValues},
{"XML::Xercesc::QName_operator_equal_to", _wrap_QName_operator_equal_to},
{"XML::Xercesc::QName_cleanUp", _wrap_QName_cleanUp},
{"XML::Xercesc::HexBin_getDataLength", _wrap_HexBin_getDataLength},
{"XML::Xercesc::HexBin_isArrayByteHex", _wrap_HexBin_isArrayByteHex},
{"XML::Xercesc::Base64_encode", _wrap_Base64_encode},
{"XML::Xercesc::Base64_decode", _wrap_Base64_decode},
{"XML::Xercesc::Base64_getDataLength", _wrap_Base64_getDataLength},
{"XML::Xercesc::delete_XMLException", _wrap_delete_XMLException},
{"XML::Xercesc::XMLException_getType", _wrap_XMLException_getType},
{"XML::Xercesc::XMLException_getCode", _wrap_XMLException_getCode},
{"XML::Xercesc::XMLException_getMessage", _wrap_XMLException_getMessage},
{"XML::Xercesc::XMLException_getSrcFile", _wrap_XMLException_getSrcFile},
{"XML::Xercesc::XMLException_getSrcLine", _wrap_XMLException_getSrcLine},
{"XML::Xercesc::XMLException_getErrorType", _wrap_XMLException_getErrorType},
{"XML::Xercesc::XMLException_setPosition", _wrap_XMLException_setPosition},
{"XML::Xercesc::XMLException_operator_assignment", _wrap_XMLException_operator_assignment},
{"XML::Xercesc::XMLException_reinitMsgMutex", _wrap_XMLException_reinitMsgMutex},
{"XML::Xercesc::XMLException_reinitMsgLoader", _wrap_XMLException_reinitMsgLoader},
{"XML::Xercesc::delete_XMLValidator", _wrap_delete_XMLValidator},
{"XML::Xercesc::XMLValidator_checkContent", _wrap_XMLValidator_checkContent},
{"XML::Xercesc::XMLValidator_faultInAttr", _wrap_XMLValidator_faultInAttr},
{"XML::Xercesc::XMLValidator_preContentValidation", _wrap_XMLValidator_preContentValidation},
{"XML::Xercesc::XMLValidator_postParseValidation", _wrap_XMLValidator_postParseValidation},
{"XML::Xercesc::XMLValidator_reset", _wrap_XMLValidator_reset},
{"XML::Xercesc::XMLValidator_requiresNamespaces", _wrap_XMLValidator_requiresNamespaces},
{"XML::Xercesc::XMLValidator_validateAttrValue", _wrap_XMLValidator_validateAttrValue},
{"XML::Xercesc::XMLValidator_validateElement", _wrap_XMLValidator_validateElement},
{"XML::Xercesc::XMLValidator_getGrammar", _wrap_XMLValidator_getGrammar},
{"XML::Xercesc::XMLValidator_setGrammar", _wrap_XMLValidator_setGrammar},
{"XML::Xercesc::XMLValidator_handlesDTD", _wrap_XMLValidator_handlesDTD},
{"XML::Xercesc::XMLValidator_handlesSchema", _wrap_XMLValidator_handlesSchema},
{"XML::Xercesc::XMLValidator_setScannerInfo", _wrap_XMLValidator_setScannerInfo},
{"XML::Xercesc::XMLValidator_setErrorReporter", _wrap_XMLValidator_setErrorReporter},
{"XML::Xercesc::XMLValidator_emitError", _wrap_XMLValidator_emitError},
{"XML::Xercesc::XMLValidator_checkRootElement", _wrap_XMLValidator_checkRootElement},
{"XML::Xercesc::XMLValidator_reinitMsgMutex", _wrap_XMLValidator_reinitMsgMutex},
{"XML::Xercesc::XMLValidator_reinitMsgLoader", _wrap_XMLValidator_reinitMsgLoader},
{"XML::Xercesc::new_SAXException", _wrap_new_SAXException},
{"XML::Xercesc::delete_SAXException", _wrap_delete_SAXException},
{"XML::Xercesc::SAXException_operator_assignment", _wrap_SAXException_operator_assignment},
{"XML::Xercesc::SAXException_getMessage", _wrap_SAXException_getMessage},
{"XML::Xercesc::new_SAXNotSupportedException", _wrap_new_SAXNotSupportedException},
{"XML::Xercesc::new_SAXNotRecognizedException", _wrap_new_SAXNotRecognizedException},
{"XML::Xercesc::new_SAXParseException", _wrap_new_SAXParseException},
{"XML::Xercesc::delete_SAXParseException", _wrap_delete_SAXParseException},
{"XML::Xercesc::SAXParseException_operator_assignment", _wrap_SAXParseException_operator_assignment},
{"XML::Xercesc::SAXParseException_getColumnNumber", _wrap_SAXParseException_getColumnNumber},
{"XML::Xercesc::SAXParseException_getLineNumber", _wrap_SAXParseException_getLineNumber},
{"XML::Xercesc::SAXParseException_getPublicId", _wrap_SAXParseException_getPublicId},
{"XML::Xercesc::SAXParseException_getSystemId", _wrap_SAXParseException_getSystemId},
{"XML::Xercesc::delete_ErrorHandler", _wrap_delete_ErrorHandler},
{"XML::Xercesc::ErrorHandler_warning", _wrap_ErrorHandler_warning},
{"XML::Xercesc::ErrorHandler_error", _wrap_ErrorHandler_error},
{"XML::Xercesc::ErrorHandler_fatalError", _wrap_ErrorHandler_fatalError},
{"XML::Xercesc::ErrorHandler_resetErrors", _wrap_ErrorHandler_resetErrors},
{"XML::Xercesc::delete_DTDHandler", _wrap_delete_DTDHandler},
{"XML::Xercesc::DTDHandler_notationDecl", _wrap_DTDHandler_notationDecl},
{"XML::Xercesc::DTDHandler_unparsedEntityDecl", _wrap_DTDHandler_unparsedEntityDecl},
{"XML::Xercesc::DTDHandler_resetDocType", _wrap_DTDHandler_resetDocType},
{"XML::Xercesc::delete_DocumentHandler", _wrap_delete_DocumentHandler},
{"XML::Xercesc::DocumentHandler_characters", _wrap_DocumentHandler_characters},
{"XML::Xercesc::DocumentHandler_endDocument", _wrap_DocumentHandler_endDocument},
{"XML::Xercesc::DocumentHandler_endElement", _wrap_DocumentHandler_endElement},
{"XML::Xercesc::DocumentHandler_ignorableWhitespace", _wrap_DocumentHandler_ignorableWhitespace},
{"XML::Xercesc::DocumentHandler_processingInstruction", _wrap_DocumentHandler_processingInstruction},
{"XML::Xercesc::DocumentHandler_resetDocument", _wrap_DocumentHandler_resetDocument},
{"XML::Xercesc::DocumentHandler_setDocumentLocator", _wrap_DocumentHandler_setDocumentLocator},
{"XML::Xercesc::DocumentHandler_startDocument", _wrap_DocumentHandler_startDocument},
{"XML::Xercesc::DocumentHandler_startElement", _wrap_DocumentHandler_startElement},
{"XML::Xercesc::delete_EntityResolver", _wrap_delete_EntityResolver},
{"XML::Xercesc::EntityResolver_resolveEntity", _wrap_EntityResolver_resolveEntity},
{"XML::Xercesc::delete_AttributeList", _wrap_delete_AttributeList},
{"XML::Xercesc::AttributeList_getLength", _wrap_AttributeList_getLength},
{"XML::Xercesc::AttributeList_getName", _wrap_AttributeList_getName},
{"XML::Xercesc::AttributeList_getType__overload__index", _wrap_AttributeList_getType__overload__index},
{"XML::Xercesc::AttributeList_getValue__overload__index", _wrap_AttributeList_getValue__overload__index},
{"XML::Xercesc::AttributeList_getType", _wrap_AttributeList_getType},
{"XML::Xercesc::AttributeList_getValue", _wrap_AttributeList_getValue},
{"XML::Xercesc::HandlerBase_characters", _wrap_HandlerBase_characters},
{"XML::Xercesc::HandlerBase_endDocument", _wrap_HandlerBase_endDocument},
{"XML::Xercesc::HandlerBase_endElement", _wrap_HandlerBase_endElement},
{"XML::Xercesc::HandlerBase_ignorableWhitespace", _wrap_HandlerBase_ignorableWhitespace},
{"XML::Xercesc::HandlerBase_processingInstruction", _wrap_HandlerBase_processingInstruction},
{"XML::Xercesc::HandlerBase_resetDocument", _wrap_HandlerBase_resetDocument},
{"XML::Xercesc::HandlerBase_setDocumentLocator", _wrap_HandlerBase_setDocumentLocator},
{"XML::Xercesc::HandlerBase_startDocument", _wrap_HandlerBase_startDocument},
{"XML::Xercesc::HandlerBase_startElement", _wrap_HandlerBase_startElement},
{"XML::Xercesc::HandlerBase_resolveEntity", _wrap_HandlerBase_resolveEntity},
{"XML::Xercesc::HandlerBase_error", _wrap_HandlerBase_error},
{"XML::Xercesc::HandlerBase_fatalError", _wrap_HandlerBase_fatalError},
{"XML::Xercesc::HandlerBase_warning", _wrap_HandlerBase_warning},
{"XML::Xercesc::HandlerBase_resetErrors", _wrap_HandlerBase_resetErrors},
{"XML::Xercesc::HandlerBase_notationDecl", _wrap_HandlerBase_notationDecl},
{"XML::Xercesc::HandlerBase_resetDocType", _wrap_HandlerBase_resetDocType},
{"XML::Xercesc::HandlerBase_unparsedEntityDecl", _wrap_HandlerBase_unparsedEntityDecl},
{"XML::Xercesc::delete_Locator", _wrap_delete_Locator},
{"XML::Xercesc::Locator_getPublicId", _wrap_Locator_getPublicId},
{"XML::Xercesc::Locator_getSystemId", _wrap_Locator_getSystemId},
{"XML::Xercesc::Locator_getLineNumber", _wrap_Locator_getLineNumber},
{"XML::Xercesc::Locator_getColumnNumber", _wrap_Locator_getColumnNumber},
{"XML::Xercesc::delete_Attributes", _wrap_delete_Attributes},
{"XML::Xercesc::Attributes_getLength", _wrap_Attributes_getLength},
{"XML::Xercesc::Attributes_getURI", _wrap_Attributes_getURI},
{"XML::Xercesc::Attributes_getLocalName", _wrap_Attributes_getLocalName},
{"XML::Xercesc::Attributes_getQName", _wrap_Attributes_getQName},
{"XML::Xercesc::Attributes_getType__overload__index", _wrap_Attributes_getType__overload__index},
{"XML::Xercesc::Attributes_getValue__overload__index", _wrap_Attributes_getValue__overload__index},
{"XML::Xercesc::Attributes_getIndex", _wrap_Attributes_getIndex},
{"XML::Xercesc::Attributes_getIndex__overload__qname", _wrap_Attributes_getIndex__overload__qname},
{"XML::Xercesc::Attributes_getType", _wrap_Attributes_getType},
{"XML::Xercesc::Attributes_getType__overload__qname", _wrap_Attributes_getType__overload__qname},
{"XML::Xercesc::Attributes_getValue", _wrap_Attributes_getValue},
{"XML::Xercesc::Attributes_getValue__overload__qname", _wrap_Attributes_getValue__overload__qname},
{"XML::Xercesc::delete_ContentHandler", _wrap_delete_ContentHandler},
{"XML::Xercesc::ContentHandler_characters", _wrap_ContentHandler_characters},
{"XML::Xercesc::ContentHandler_endDocument", _wrap_ContentHandler_endDocument},
{"XML::Xercesc::ContentHandler_endElement", _wrap_ContentHandler_endElement},
{"XML::Xercesc::ContentHandler_ignorableWhitespace", _wrap_ContentHandler_ignorableWhitespace},
{"XML::Xercesc::ContentHandler_processingInstruction", _wrap_ContentHandler_processingInstruction},
{"XML::Xercesc::ContentHandler_setDocumentLocator", _wrap_ContentHandler_setDocumentLocator},
{"XML::Xercesc::ContentHandler_startDocument", _wrap_ContentHandler_startDocument},
{"XML::Xercesc::ContentHandler_startElement", _wrap_ContentHandler_startElement},
{"XML::Xercesc::ContentHandler_startPrefixMapping", _wrap_ContentHandler_startPrefixMapping},
{"XML::Xercesc::ContentHandler_endPrefixMapping", _wrap_ContentHandler_endPrefixMapping},
{"XML::Xercesc::ContentHandler_skippedEntity", _wrap_ContentHandler_skippedEntity},
{"XML::Xercesc::delete_LexicalHandler", _wrap_delete_LexicalHandler},
{"XML::Xercesc::LexicalHandler_comment", _wrap_LexicalHandler_comment},
{"XML::Xercesc::LexicalHandler_endCDATA", _wrap_LexicalHandler_endCDATA},
{"XML::Xercesc::LexicalHandler_endDTD", _wrap_LexicalHandler_endDTD},
{"XML::Xercesc::LexicalHandler_endEntity", _wrap_LexicalHandler_endEntity},
{"XML::Xercesc::LexicalHandler_startCDATA", _wrap_LexicalHandler_startCDATA},
{"XML::Xercesc::LexicalHandler_startDTD", _wrap_LexicalHandler_startDTD},
{"XML::Xercesc::LexicalHandler_startEntity", _wrap_LexicalHandler_startEntity},
{"XML::Xercesc::DefaultHandler_characters", _wrap_DefaultHandler_characters},
{"XML::Xercesc::DefaultHandler_endDocument", _wrap_DefaultHandler_endDocument},
{"XML::Xercesc::DefaultHandler_endElement", _wrap_DefaultHandler_endElement},
{"XML::Xercesc::DefaultHandler_ignorableWhitespace", _wrap_DefaultHandler_ignorableWhitespace},
{"XML::Xercesc::DefaultHandler_processingInstruction", _wrap_DefaultHandler_processingInstruction},
{"XML::Xercesc::DefaultHandler_resetDocument", _wrap_DefaultHandler_resetDocument},
{"XML::Xercesc::DefaultHandler_setDocumentLocator", _wrap_DefaultHandler_setDocumentLocator},
{"XML::Xercesc::DefaultHandler_startDocument", _wrap_DefaultHandler_startDocument},
{"XML::Xercesc::DefaultHandler_startElement", _wrap_DefaultHandler_startElement},
{"XML::Xercesc::DefaultHandler_startPrefixMapping", _wrap_DefaultHandler_startPrefixMapping},
{"XML::Xercesc::DefaultHandler_endPrefixMapping", _wrap_DefaultHandler_endPrefixMapping},
{"XML::Xercesc::DefaultHandler_skippedEntity", _wrap_DefaultHandler_skippedEntity},
{"XML::Xercesc::DefaultHandler_resolveEntity", _wrap_DefaultHandler_resolveEntity},
{"XML::Xercesc::DefaultHandler_error", _wrap_DefaultHandler_error},
{"XML::Xercesc::DefaultHandler_fatalError", _wrap_DefaultHandler_fatalError},
{"XML::Xercesc::DefaultHandler_warning", _wrap_DefaultHandler_warning},
{"XML::Xercesc::DefaultHandler_resetErrors", _wrap_DefaultHandler_resetErrors},
{"XML::Xercesc::DefaultHandler_notationDecl", _wrap_DefaultHandler_notationDecl},
{"XML::Xercesc::DefaultHandler_resetDocType", _wrap_DefaultHandler_resetDocType},
{"XML::Xercesc::DefaultHandler_unparsedEntityDecl", _wrap_DefaultHandler_unparsedEntityDecl},
{"XML::Xercesc::DefaultHandler_comment", _wrap_DefaultHandler_comment},
{"XML::Xercesc::DefaultHandler_endCDATA", _wrap_DefaultHandler_endCDATA},
{"XML::Xercesc::DefaultHandler_endDTD", _wrap_DefaultHandler_endDTD},
{"XML::Xercesc::DefaultHandler_endEntity", _wrap_DefaultHandler_endEntity},
{"XML::Xercesc::DefaultHandler_startCDATA", _wrap_DefaultHandler_startCDATA},
{"XML::Xercesc::DefaultHandler_startDTD", _wrap_DefaultHandler_startDTD},
{"XML::Xercesc::DefaultHandler_startEntity", _wrap_DefaultHandler_startEntity},
{"XML::Xercesc::DefaultHandler_elementDecl", _wrap_DefaultHandler_elementDecl},
{"XML::Xercesc::DefaultHandler_attributeDecl", _wrap_DefaultHandler_attributeDecl},
{"XML::Xercesc::DefaultHandler_internalEntityDecl", _wrap_DefaultHandler_internalEntityDecl},
{"XML::Xercesc::DefaultHandler_externalEntityDecl", _wrap_DefaultHandler_externalEntityDecl},
{"XML::Xercesc::XMLReaderFactory_createXMLReader", _wrap_XMLReaderFactory_createXMLReader},
{"XML::Xercesc::delete_InputSource", _wrap_delete_InputSource},
{"XML::Xercesc::InputSource_makeStream", _wrap_InputSource_makeStream},
{"XML::Xercesc::InputSource_getEncoding", _wrap_InputSource_getEncoding},
{"XML::Xercesc::InputSource_getPublicId", _wrap_InputSource_getPublicId},
{"XML::Xercesc::InputSource_getSystemId", _wrap_InputSource_getSystemId},
{"XML::Xercesc::InputSource_getIssueFatalErrorIfNotFound", _wrap_InputSource_getIssueFatalErrorIfNotFound},
{"XML::Xercesc::InputSource_setEncoding", _wrap_InputSource_setEncoding},
{"XML::Xercesc::InputSource_setPublicId", _wrap_InputSource_setPublicId},
{"XML::Xercesc::InputSource_setSystemId", _wrap_InputSource_setSystemId},
{"XML::Xercesc::InputSource_setIssueFatalErrorIfNotFound", _wrap_InputSource_setIssueFatalErrorIfNotFound},
{"XML::Xercesc::new_MemBufInputSource", _wrap_new_MemBufInputSource},
{"XML::Xercesc::delete_MemBufInputSource", _wrap_delete_MemBufInputSource},
{"XML::Xercesc::MemBufInputSource_makeStream", _wrap_MemBufInputSource_makeStream},
{"XML::Xercesc::MemBufInputSource_setCopyBufToStream", _wrap_MemBufInputSource_setCopyBufToStream},
{"XML::Xercesc::new_StdInInputSource", _wrap_new_StdInInputSource},
{"XML::Xercesc::delete_StdInInputSource", _wrap_delete_StdInInputSource},
{"XML::Xercesc::StdInInputSource_makeStream", _wrap_StdInInputSource_makeStream},
{"XML::Xercesc::new_LocalFileInputSource__constructor__base", _wrap_new_LocalFileInputSource__constructor__base},
{"XML::Xercesc::new_LocalFileInputSource", _wrap_new_LocalFileInputSource},
{"XML::Xercesc::delete_LocalFileInputSource", _wrap_delete_LocalFileInputSource},
{"XML::Xercesc::LocalFileInputSource_makeStream", _wrap_LocalFileInputSource_makeStream},
{"XML::Xercesc::new_URLInputSource", _wrap_new_URLInputSource},
{"XML::Xercesc::new_URLInputSource__constructor__sys", _wrap_new_URLInputSource__constructor__sys},
{"XML::Xercesc::new_URLInputSource__constructor__pub", _wrap_new_URLInputSource__constructor__pub},
{"XML::Xercesc::delete_URLInputSource", _wrap_delete_URLInputSource},
{"XML::Xercesc::URLInputSource_makeStream", _wrap_URLInputSource_makeStream},
{"XML::Xercesc::URLInputSource_urlSrc", _wrap_URLInputSource_urlSrc},
{"XML::Xercesc::delete_$ignore", _wrap_delete__ignore___},
{"XML::Xercesc::XMLScanner_getSrcOffset", _wrap_XMLScanner_getSrcOffset},
{"XML::Xercesc::XMLScanner_getEntityDecl", _wrap_XMLScanner_getEntityDecl},
{"XML::Xercesc::XMLScanner_getEmptyNamespaceId", _wrap_XMLScanner_getEmptyNamespaceId},
{"XML::Xercesc::XMLScanner_getUnknownNamespaceId", _wrap_XMLScanner_getUnknownNamespaceId},
{"XML::Xercesc::XMLScanner_getXMLNamespaceId", _wrap_XMLScanner_getXMLNamespaceId},
{"XML::Xercesc::XMLScanner_getXMLNSNamespaceId", _wrap_XMLScanner_getXMLNSNamespaceId},
{"XML::Xercesc::XMLScanner_resolveQName", _wrap_XMLScanner_resolveQName},
{"XML::Xercesc::XMLScanner_isValidatorFromUser", _wrap_XMLScanner_isValidatorFromUser},
{"XML::Xercesc::XMLScanner_setDocHandler", _wrap_XMLScanner_setDocHandler},
{"XML::Xercesc::XMLScanner_setDocTypeHandler", _wrap_XMLScanner_setDocTypeHandler},
{"XML::Xercesc::XMLScanner_setDoNamespaces", _wrap_XMLScanner_setDoNamespaces},
{"XML::Xercesc::XMLScanner_setEntityHandler", _wrap_XMLScanner_setEntityHandler},
{"XML::Xercesc::XMLScanner_setEntityResolver", _wrap_XMLScanner_setEntityResolver},
{"XML::Xercesc::XMLScanner_setErrorReporter", _wrap_XMLScanner_setErrorReporter},
{"XML::Xercesc::XMLScanner_setErrorHandler", _wrap_XMLScanner_setErrorHandler},
{"XML::Xercesc::XMLScanner_setExitOnFirstFatal", _wrap_XMLScanner_setExitOnFirstFatal},
{"XML::Xercesc::XMLScanner_setValidationConstraintFatal", _wrap_XMLScanner_setValidationConstraintFatal},
{"XML::Xercesc::XMLScanner_setValidationScheme", _wrap_XMLScanner_setValidationScheme},
{"XML::Xercesc::XMLScanner_setValidator", _wrap_XMLScanner_setValidator},
{"XML::Xercesc::XMLScanner_setDoSchema", _wrap_XMLScanner_setDoSchema},
{"XML::Xercesc::XMLScanner_setValidationSchemaFullChecking", _wrap_XMLScanner_setValidationSchemaFullChecking},
{"XML::Xercesc::XMLScanner_setHasNoDTD", _wrap_XMLScanner_setHasNoDTD},
{"XML::Xercesc::XMLScanner_setRootElemName", _wrap_XMLScanner_setRootElemName},
{"XML::Xercesc::XMLScanner_incrementErrorCount", _wrap_XMLScanner_incrementErrorCount},
{"XML::Xercesc::XMLScanner_getDoValidation", _wrap_XMLScanner_getDoValidation},
{"XML::Xercesc::XMLScanner_setDoValidation", _wrap_XMLScanner_setDoValidation},
{"XML::Xercesc::XMLScanner_scanNext", _wrap_XMLScanner_scanNext},
{"XML::Xercesc::XMLScanner_scanReset", _wrap_XMLScanner_scanReset},
{"XML::Xercesc::XMLScanner_checkXMLDecl", _wrap_XMLScanner_checkXMLDecl},
{"XML::Xercesc::XMLScanner_reinitScannerMutex", _wrap_XMLScanner_reinitScannerMutex},
{"XML::Xercesc::XMLScanner_reinitMsgLoader", _wrap_XMLScanner_reinitMsgLoader},
{"XML::Xercesc::new_XMLPScanToken", _wrap_new_XMLPScanToken},
{"XML::Xercesc::delete_XMLPScanToken", _wrap_delete_XMLPScanToken},
{"XML::Xercesc::XMLPScanToken_operator_assignment", _wrap_XMLPScanToken_operator_assignment},
{"XML::Xercesc::delete_SAX2XMLReader", _wrap_delete_SAX2XMLReader},
{"XML::Xercesc::SAX2XMLReader_getErrorCount", _wrap_SAX2XMLReader_getErrorCount},
{"XML::Xercesc::SAX2XMLReader_getContentHandler", _wrap_SAX2XMLReader_getContentHandler},
{"XML::Xercesc::SAX2XMLReader_getDTDHandler", _wrap_SAX2XMLReader_getDTDHandler},
{"XML::Xercesc::SAX2XMLReader_getEntityResolver", _wrap_SAX2XMLReader_getEntityResolver},
{"XML::Xercesc::SAX2XMLReader_getErrorHandler", _wrap_SAX2XMLReader_getErrorHandler},
{"XML::Xercesc::SAX2XMLReader_getLexicalHandler", _wrap_SAX2XMLReader_getLexicalHandler},
{"XML::Xercesc::SAX2XMLReader_getDeclarationHandler", _wrap_SAX2XMLReader_getDeclarationHandler},
{"XML::Xercesc::SAX2XMLReader_getFeature", _wrap_SAX2XMLReader_getFeature},
{"XML::Xercesc::SAX2XMLReader_getProperty", _wrap_SAX2XMLReader_getProperty},
{"XML::Xercesc::SAX2XMLReader_getExitOnFirstFatalError", _wrap_SAX2XMLReader_getExitOnFirstFatalError},
{"XML::Xercesc::SAX2XMLReader_getValidationConstraintFatal", _wrap_SAX2XMLReader_getValidationConstraintFatal},
{"XML::Xercesc::SAX2XMLReader_parse", _wrap_SAX2XMLReader_parse},
{"XML::Xercesc::SAX2XMLReader_setContentHandler", _wrap_SAX2XMLReader_setContentHandler},
{"XML::Xercesc::SAX2XMLReader_setDTDHandler", _wrap_SAX2XMLReader_setDTDHandler},
{"XML::Xercesc::SAX2XMLReader_setEntityResolver", _wrap_SAX2XMLReader_setEntityResolver},
{"XML::Xercesc::SAX2XMLReader_setErrorHandler", _wrap_SAX2XMLReader_setErrorHandler},
{"XML::Xercesc::SAX2XMLReader_setLexicalHandler", _wrap_SAX2XMLReader_setLexicalHandler},
{"XML::Xercesc::SAX2XMLReader_setDeclarationHandler", _wrap_SAX2XMLReader_setDeclarationHandler},
{"XML::Xercesc::SAX2XMLReader_setExitOnFirstFatalError", _wrap_SAX2XMLReader_setExitOnFirstFatalError},
{"XML::Xercesc::SAX2XMLReader_setValidationConstraintFatal", _wrap_SAX2XMLReader_setValidationConstraintFatal},
{"XML::Xercesc::SAX2XMLReader_setFeature", _wrap_SAX2XMLReader_setFeature},
{"XML::Xercesc::SAX2XMLReader_setProperty", _wrap_SAX2XMLReader_setProperty},
{"XML::Xercesc::SAX2XMLReader_parseFirst", _wrap_SAX2XMLReader_parseFirst},
{"XML::Xercesc::SAX2XMLReader_parseFirst__overload__is", _wrap_SAX2XMLReader_parseFirst__overload__is},
{"XML::Xercesc::SAX2XMLReader_parseNext", _wrap_SAX2XMLReader_parseNext},
{"XML::Xercesc::SAX2XMLReader_parseReset", _wrap_SAX2XMLReader_parseReset},
{"XML::Xercesc::SAX2XMLReader_setValidator", _wrap_SAX2XMLReader_setValidator},
{"XML::Xercesc::SAX2XMLReader_getValidator", _wrap_SAX2XMLReader_getValidator},
{"XML::Xercesc::SAX2XMLReader_installAdvDocHandler", _wrap_SAX2XMLReader_installAdvDocHandler},
{"XML::Xercesc::SAX2XMLReader_removeAdvDocHandler", _wrap_SAX2XMLReader_removeAdvDocHandler},
{"XML::Xercesc::new_SAXParser", _wrap_new_SAXParser},
{"XML::Xercesc::delete_SAXParser", _wrap_delete_SAXParser},
{"XML::Xercesc::SAXParser_getDocumentHandler", _wrap_SAXParser_getDocumentHandler},
{"XML::Xercesc::SAXParser_getEntityResolver", _wrap_SAXParser_getEntityResolver},
{"XML::Xercesc::SAXParser_getErrorHandler", _wrap_SAXParser_getErrorHandler},
{"XML::Xercesc::SAXParser_getScanner", _wrap_SAXParser_getScanner},
{"XML::Xercesc::SAXParser_getValidator", _wrap_SAXParser_getValidator},
{"XML::Xercesc::SAXParser_getValidationScheme", _wrap_SAXParser_getValidationScheme},
{"XML::Xercesc::SAXParser_getDoSchema", _wrap_SAXParser_getDoSchema},
{"XML::Xercesc::SAXParser_getValidationSchemaFullChecking", _wrap_SAXParser_getValidationSchemaFullChecking},
{"XML::Xercesc::SAXParser_getErrorCount", _wrap_SAXParser_getErrorCount},
{"XML::Xercesc::SAXParser_getDoNamespaces", _wrap_SAXParser_getDoNamespaces},
{"XML::Xercesc::SAXParser_getExitOnFirstFatalError", _wrap_SAXParser_getExitOnFirstFatalError},
{"XML::Xercesc::SAXParser_getValidationConstraintFatal", _wrap_SAXParser_getValidationConstraintFatal},
{"XML::Xercesc::SAXParser_getExternalSchemaLocation", _wrap_SAXParser_getExternalSchemaLocation},
{"XML::Xercesc::SAXParser_getExternalNoNamespaceSchemaLocation", _wrap_SAXParser_getExternalNoNamespaceSchemaLocation},
{"XML::Xercesc::SAXParser_setDoNamespaces", _wrap_SAXParser_setDoNamespaces},
{"XML::Xercesc::SAXParser_setValidationScheme", _wrap_SAXParser_setValidationScheme},
{"XML::Xercesc::SAXParser_setDoSchema", _wrap_SAXParser_setDoSchema},
{"XML::Xercesc::SAXParser_setValidationSchemaFullChecking", _wrap_SAXParser_setValidationSchemaFullChecking},
{"XML::Xercesc::SAXParser_setExitOnFirstFatalError", _wrap_SAXParser_setExitOnFirstFatalError},
{"XML::Xercesc::SAXParser_setValidationConstraintFatal", _wrap_SAXParser_setValidationConstraintFatal},
{"XML::Xercesc::SAXParser_setExternalSchemaLocation", _wrap_SAXParser_setExternalSchemaLocation},
{"XML::Xercesc::SAXParser_setExternalNoNamespaceSchemaLocation", _wrap_SAXParser_setExternalNoNamespaceSchemaLocation},
{"XML::Xercesc::SAXParser_installAdvDocHandler", _wrap_SAXParser_installAdvDocHandler},
{"XML::Xercesc::SAXParser_removeAdvDocHandler", _wrap_SAXParser_removeAdvDocHandler},
{"XML::Xercesc::SAXParser_parse__overload__is", _wrap_SAXParser_parse__overload__is},
{"XML::Xercesc::SAXParser_parse", _wrap_SAXParser_parse},
{"XML::Xercesc::SAXParser_setDocumentHandler", _wrap_SAXParser_setDocumentHandler},
{"XML::Xercesc::SAXParser_setDTDHandler", _wrap_SAXParser_setDTDHandler},
{"XML::Xercesc::SAXParser_setErrorHandler", _wrap_SAXParser_setErrorHandler},
{"XML::Xercesc::SAXParser_setEntityResolver", _wrap_SAXParser_setEntityResolver},
{"XML::Xercesc::SAXParser_parseFirst", _wrap_SAXParser_parseFirst},
{"XML::Xercesc::SAXParser_parseFirst__overload__is", _wrap_SAXParser_parseFirst__overload__is},
{"XML::Xercesc::SAXParser_parseNext", _wrap_SAXParser_parseNext},
{"XML::Xercesc::SAXParser_parseReset", _wrap_SAXParser_parseReset},
{"XML::Xercesc::SAXParser_error", _wrap_SAXParser_error},
{"XML::Xercesc::SAXParser_resetErrors", _wrap_SAXParser_resetErrors},
{"XML::Xercesc::new_DOMParser", _wrap_new_DOMParser},
{"XML::Xercesc::delete_DOMParser", _wrap_delete_DOMParser},
{"XML::Xercesc::DOMParser_reset", _wrap_DOMParser_reset},
{"XML::Xercesc::DOMParser_resetDocumentPool", _wrap_DOMParser_resetDocumentPool},
{"XML::Xercesc::DOMParser_getDocument", _wrap_DOMParser_getDocument},
{"XML::Xercesc::DOMParser_getErrorHandler", _wrap_DOMParser_getErrorHandler},
{"XML::Xercesc::DOMParser_getEntityResolver", _wrap_DOMParser_getEntityResolver},
{"XML::Xercesc::DOMParser_getValidator", _wrap_DOMParser_getValidator},
{"XML::Xercesc::DOMParser_getValidationScheme", _wrap_DOMParser_getValidationScheme},
{"XML::Xercesc::DOMParser_getDoSchema", _wrap_DOMParser_getDoSchema},
{"XML::Xercesc::DOMParser_getValidationSchemaFullChecking", _wrap_DOMParser_getValidationSchemaFullChecking},
{"XML::Xercesc::DOMParser_getErrorCount", _wrap_DOMParser_getErrorCount},
{"XML::Xercesc::DOMParser_getDoNamespaces", _wrap_DOMParser_getDoNamespaces},
{"XML::Xercesc::DOMParser_getExitOnFirstFatalError", _wrap_DOMParser_getExitOnFirstFatalError},
{"XML::Xercesc::DOMParser_getValidationConstraintFatal", _wrap_DOMParser_getValidationConstraintFatal},
{"XML::Xercesc::DOMParser_getExpandEntityReferences", _wrap_DOMParser_getExpandEntityReferences},
{"XML::Xercesc::DOMParser_getCreateEntityReferenceNodes", _wrap_DOMParser_getCreateEntityReferenceNodes},
{"XML::Xercesc::DOMParser_getIncludeIgnorableWhitespace", _wrap_DOMParser_getIncludeIgnorableWhitespace},
{"XML::Xercesc::DOMParser_getExternalSchemaLocation", _wrap_DOMParser_getExternalSchemaLocation},
{"XML::Xercesc::DOMParser_getExternalNoNamespaceSchemaLocation", _wrap_DOMParser_getExternalNoNamespaceSchemaLocation},
{"XML::Xercesc::DOMParser_setErrorHandler", _wrap_DOMParser_setErrorHandler},
{"XML::Xercesc::DOMParser_setEntityResolver", _wrap_DOMParser_setEntityResolver},
{"XML::Xercesc::DOMParser_setDoNamespaces", _wrap_DOMParser_setDoNamespaces},
{"XML::Xercesc::DOMParser_setExitOnFirstFatalError", _wrap_DOMParser_setExitOnFirstFatalError},
{"XML::Xercesc::DOMParser_setValidationConstraintFatal", _wrap_DOMParser_setValidationConstraintFatal},
{"XML::Xercesc::DOMParser_setExpandEntityReferences", _wrap_DOMParser_setExpandEntityReferences},
{"XML::Xercesc::DOMParser_setCreateEntityReferenceNodes", _wrap_DOMParser_setCreateEntityReferenceNodes},
{"XML::Xercesc::DOMParser_setIncludeIgnorableWhitespace", _wrap_DOMParser_setIncludeIgnorableWhitespace},
{"XML::Xercesc::DOMParser_setValidationScheme", _wrap_DOMParser_setValidationScheme},
{"XML::Xercesc::DOMParser_setDoSchema", _wrap_DOMParser_setDoSchema},
{"XML::Xercesc::DOMParser_setValidationSchemaFullChecking", _wrap_DOMParser_setValidationSchemaFullChecking},
{"XML::Xercesc::DOMParser_setExternalSchemaLocation", _wrap_DOMParser_setExternalSchemaLocation},
{"XML::Xercesc::DOMParser_setExternalNoNamespaceSchemaLocation", _wrap_DOMParser_setExternalNoNamespaceSchemaLocation},
{"XML::Xercesc::DOMParser_parse__overload__is", _wrap_DOMParser_parse__overload__is},
{"XML::Xercesc::DOMParser_parse", _wrap_DOMParser_parse},
{"XML::Xercesc::DOMParser_parseFirst", _wrap_DOMParser_parseFirst},
{"XML::Xercesc::DOMParser_parseFirst__overload__is", _wrap_DOMParser_parseFirst__overload__is},
{"XML::Xercesc::DOMParser_parseNext", _wrap_DOMParser_parseNext},
{"XML::Xercesc::DOMParser_parseReset", _wrap_DOMParser_parseReset},
{"XML::Xercesc::DOMParser_error", _wrap_DOMParser_error},
{"XML::Xercesc::DOMParser_resetErrors", _wrap_DOMParser_resetErrors},
{"XML::Xercesc::delete_Grammar", _wrap_delete_Grammar},
{"XML::Xercesc::Grammar_getGrammarType", _wrap_Grammar_getGrammarType},
{"XML::Xercesc::Grammar_getTargetNamespace", _wrap_Grammar_getTargetNamespace},
{"XML::Xercesc::Grammar_findOrAddElemDecl", _wrap_Grammar_findOrAddElemDecl},
{"XML::Xercesc::Grammar_getElemId", _wrap_Grammar_getElemId},
{"XML::Xercesc::Grammar_getElemDecl", _wrap_Grammar_getElemDecl},
{"XML::Xercesc::Grammar_getNotationDecl", _wrap_Grammar_getNotationDecl},
{"XML::Xercesc::Grammar_putElemDecl", _wrap_Grammar_putElemDecl},
{"XML::Xercesc::Grammar_putNotationDecl", _wrap_Grammar_putNotationDecl},
{"XML::Xercesc::Grammar_reset", _wrap_Grammar_reset},
{"XML::Xercesc::delete_DOM_Node", _wrap_delete_DOM_Node},
{"XML::Xercesc::DOM_Node_getNodeName", _wrap_DOM_Node_getNodeName},
{"XML::Xercesc::DOM_Node_getNodeValue", _wrap_DOM_Node_getNodeValue},
{"XML::Xercesc::DOM_Node_getNodeType", _wrap_DOM_Node_getNodeType},
{"XML::Xercesc::DOM_Node_getParentNode", _wrap_DOM_Node_getParentNode},
{"XML::Xercesc::DOM_Node_getChildNodes", _wrap_DOM_Node_getChildNodes},
{"XML::Xercesc::DOM_Node_getFirstChild", _wrap_DOM_Node_getFirstChild},
{"XML::Xercesc::DOM_Node_getLastChild", _wrap_DOM_Node_getLastChild},
{"XML::Xercesc::DOM_Node_getPreviousSibling", _wrap_DOM_Node_getPreviousSibling},
{"XML::Xercesc::DOM_Node_getNextSibling", _wrap_DOM_Node_getNextSibling},
{"XML::Xercesc::DOM_Node_getAttributes", _wrap_DOM_Node_getAttributes},
{"XML::Xercesc::DOM_Node_getOwnerDocument", _wrap_DOM_Node_getOwnerDocument},
{"XML::Xercesc::DOM_Node_cloneNode", _wrap_DOM_Node_cloneNode},
{"XML::Xercesc::DOM_Node_insertBefore", _wrap_DOM_Node_insertBefore},
{"XML::Xercesc::DOM_Node_replaceChild", _wrap_DOM_Node_replaceChild},
{"XML::Xercesc::DOM_Node_removeChild", _wrap_DOM_Node_removeChild},
{"XML::Xercesc::DOM_Node_appendChild", _wrap_DOM_Node_appendChild},
{"XML::Xercesc::DOM_Node_hasChildNodes", _wrap_DOM_Node_hasChildNodes},
{"XML::Xercesc::DOM_Node_setNodeValue", _wrap_DOM_Node_setNodeValue},
{"XML::Xercesc::DOM_Node_normalize", _wrap_DOM_Node_normalize},
{"XML::Xercesc::DOM_Node_isSupported", _wrap_DOM_Node_isSupported},
{"XML::Xercesc::DOM_Node_getNamespaceURI", _wrap_DOM_Node_getNamespaceURI},
{"XML::Xercesc::DOM_Node_getLocalName", _wrap_DOM_Node_getLocalName},
{"XML::Xercesc::DOM_Node_setPrefix", _wrap_DOM_Node_setPrefix},
{"XML::Xercesc::DOM_Node_hasAttributes", _wrap_DOM_Node_hasAttributes},
{"XML::Xercesc::DOM_Node_operator_equal_to", _wrap_DOM_Node_operator_equal_to},
{"XML::Xercesc::DOM_Node_operator_not_equal_to", _wrap_DOM_Node_operator_not_equal_to},
{"XML::Xercesc::delete_DOM_Attr", _wrap_delete_DOM_Attr},
{"XML::Xercesc::DOM_Attr_getName", _wrap_DOM_Attr_getName},
{"XML::Xercesc::DOM_Attr_getSpecified", _wrap_DOM_Attr_getSpecified},
{"XML::Xercesc::DOM_Attr_getValue", _wrap_DOM_Attr_getValue},
{"XML::Xercesc::DOM_Attr_setValue", _wrap_DOM_Attr_setValue},
{"XML::Xercesc::DOM_Attr_getOwnerElement", _wrap_DOM_Attr_getOwnerElement},
{"XML::Xercesc::delete_DOM_CharacterData", _wrap_delete_DOM_CharacterData},
{"XML::Xercesc::DOM_CharacterData_getData", _wrap_DOM_CharacterData_getData},
{"XML::Xercesc::DOM_CharacterData_getLength", _wrap_DOM_CharacterData_getLength},
{"XML::Xercesc::DOM_CharacterData_substringData", _wrap_DOM_CharacterData_substringData},
{"XML::Xercesc::DOM_CharacterData_appendData", _wrap_DOM_CharacterData_appendData},
{"XML::Xercesc::DOM_CharacterData_insertData", _wrap_DOM_CharacterData_insertData},
{"XML::Xercesc::DOM_CharacterData_deleteData", _wrap_DOM_CharacterData_deleteData},
{"XML::Xercesc::DOM_CharacterData_replaceData", _wrap_DOM_CharacterData_replaceData},
{"XML::Xercesc::DOM_CharacterData_setData", _wrap_DOM_CharacterData_setData},
{"XML::Xercesc::delete_DOM_Text", _wrap_delete_DOM_Text},
{"XML::Xercesc::DOM_Text_splitText", _wrap_DOM_Text_splitText},
{"XML::Xercesc::DOM_Text_isIgnorableWhitespace", _wrap_DOM_Text_isIgnorableWhitespace},
{"XML::Xercesc::delete_DOM_CDATASection", _wrap_delete_DOM_CDATASection},
{"XML::Xercesc::delete_DOM_Comment", _wrap_delete_DOM_Comment},
{"XML::Xercesc::delete_DOM_Document", _wrap_delete_DOM_Document},
{"XML::Xercesc::DOM_Document_createEntity", _wrap_DOM_Document_createEntity},
{"XML::Xercesc::DOM_Document_createElement", _wrap_DOM_Document_createElement},
{"XML::Xercesc::DOM_Document_createDocumentFragment", _wrap_DOM_Document_createDocumentFragment},
{"XML::Xercesc::DOM_Document_createTextNode", _wrap_DOM_Document_createTextNode},
{"XML::Xercesc::DOM_Document_createComment", _wrap_DOM_Document_createComment},
{"XML::Xercesc::DOM_Document_createCDATASection", _wrap_DOM_Document_createCDATASection},
{"XML::Xercesc::DOM_Document_createDocumentType", _wrap_DOM_Document_createDocumentType},
{"XML::Xercesc::DOM_Document_createNotation", _wrap_DOM_Document_createNotation},
{"XML::Xercesc::DOM_Document_createProcessingInstruction", _wrap_DOM_Document_createProcessingInstruction},
{"XML::Xercesc::DOM_Document_createAttribute", _wrap_DOM_Document_createAttribute},
{"XML::Xercesc::DOM_Document_createEntityReference", _wrap_DOM_Document_createEntityReference},
{"XML::Xercesc::DOM_Document_createNodeIterator", _wrap_DOM_Document_createNodeIterator},
{"XML::Xercesc::DOM_Document_createTreeWalker", _wrap_DOM_Document_createTreeWalker},
{"XML::Xercesc::DOM_Document_createRange", _wrap_DOM_Document_createRange},
{"XML::Xercesc::DOM_Document_getDoctype", _wrap_DOM_Document_getDoctype},
{"XML::Xercesc::DOM_Document_getImplementation", _wrap_DOM_Document_getImplementation},
{"XML::Xercesc::DOM_Document_getDocumentElement", _wrap_DOM_Document_getDocumentElement},
{"XML::Xercesc::DOM_Document_getElementsByTagName", _wrap_DOM_Document_getElementsByTagName},
{"XML::Xercesc::DOM_Document_importNode", _wrap_DOM_Document_importNode},
{"XML::Xercesc::DOM_Document_createElementNS", _wrap_DOM_Document_createElementNS},
{"XML::Xercesc::DOM_Document_createAttributeNS", _wrap_DOM_Document_createAttributeNS},
{"XML::Xercesc::DOM_Document_getElementsByTagNameNS", _wrap_DOM_Document_getElementsByTagNameNS},
{"XML::Xercesc::DOM_Document_getElementById", _wrap_DOM_Document_getElementById},
{"XML::Xercesc::delete_DOM_DocumentFragment", _wrap_delete_DOM_DocumentFragment},
{"XML::Xercesc::delete_DOM_DocumentType", _wrap_delete_DOM_DocumentType},
{"XML::Xercesc::DOM_DocumentType_getName", _wrap_DOM_DocumentType_getName},
{"XML::Xercesc::DOM_DocumentType_getEntities", _wrap_DOM_DocumentType_getEntities},
{"XML::Xercesc::DOM_DocumentType_getNotations", _wrap_DOM_DocumentType_getNotations},
{"XML::Xercesc::DOM_DocumentType_getPublicId", _wrap_DOM_DocumentType_getPublicId},
{"XML::Xercesc::DOM_DocumentType_getSystemId", _wrap_DOM_DocumentType_getSystemId},
{"XML::Xercesc::DOM_DocumentType_getInternalSubset", _wrap_DOM_DocumentType_getInternalSubset},
{"XML::Xercesc::new_DOM_DOMException", _wrap_new_DOM_DOMException},
{"XML::Xercesc::delete_DOM_DOMException", _wrap_delete_DOM_DOMException},
{"XML::Xercesc::DOM_DOMException_code_set", _wrap_DOM_DOMException_code_set},
{"XML::Xercesc::DOM_DOMException_code_get", _wrap_DOM_DOMException_code_get},
{"XML::Xercesc::DOM_DOMException_msg_set", _wrap_DOM_DOMException_msg_set},
{"XML::Xercesc::DOM_DOMException_msg_get", _wrap_DOM_DOMException_msg_get},
{"XML::Xercesc::DOM_DOMImplementation_getImplementation", _wrap_DOM_DOMImplementation_getImplementation},
{"XML::Xercesc::delete_DOM_DOMImplementation", _wrap_delete_DOM_DOMImplementation},
{"XML::Xercesc::DOM_DOMImplementation_hasFeature", _wrap_DOM_DOMImplementation_hasFeature},
{"XML::Xercesc::DOM_DOMImplementation_createDocumentType", _wrap_DOM_DOMImplementation_createDocumentType},
{"XML::Xercesc::DOM_DOMImplementation_createDocument", _wrap_DOM_DOMImplementation_createDocument},
{"XML::Xercesc::delete_DOM_Element", _wrap_delete_DOM_Element},
{"XML::Xercesc::DOM_Element_getTagName", _wrap_DOM_Element_getTagName},
{"XML::Xercesc::DOM_Element_getAttribute", _wrap_DOM_Element_getAttribute},
{"XML::Xercesc::DOM_Element_getAttributeNode", _wrap_DOM_Element_getAttributeNode},
{"XML::Xercesc::DOM_Element_getElementsByTagName", _wrap_DOM_Element_getElementsByTagName},
{"XML::Xercesc::DOM_Element_setAttribute", _wrap_DOM_Element_setAttribute},
{"XML::Xercesc::DOM_Element_setAttributeNode", _wrap_DOM_Element_setAttributeNode},
{"XML::Xercesc::DOM_Element_removeAttributeNode", _wrap_DOM_Element_removeAttributeNode},
{"XML::Xercesc::DOM_Element_removeAttribute", _wrap_DOM_Element_removeAttribute},
{"XML::Xercesc::DOM_Element_getAttributeNS", _wrap_DOM_Element_getAttributeNS},
{"XML::Xercesc::DOM_Element_setAttributeNS", _wrap_DOM_Element_setAttributeNS},
{"XML::Xercesc::DOM_Element_removeAttributeNS", _wrap_DOM_Element_removeAttributeNS},
{"XML::Xercesc::DOM_Element_getAttributeNodeNS", _wrap_DOM_Element_getAttributeNodeNS},
{"XML::Xercesc::DOM_Element_setAttributeNodeNS", _wrap_DOM_Element_setAttributeNodeNS},
{"XML::Xercesc::DOM_Element_getElementsByTagNameNS", _wrap_DOM_Element_getElementsByTagNameNS},
{"XML::Xercesc::DOM_Element_hasAttribute", _wrap_DOM_Element_hasAttribute},
{"XML::Xercesc::DOM_Element_hasAttributeNS", _wrap_DOM_Element_hasAttributeNS},
{"XML::Xercesc::delete_DOM_Entity", _wrap_delete_DOM_Entity},
{"XML::Xercesc::DOM_Entity_getPublicId", _wrap_DOM_Entity_getPublicId},
{"XML::Xercesc::DOM_Entity_getSystemId", _wrap_DOM_Entity_getSystemId},
{"XML::Xercesc::DOM_Entity_getNotationName", _wrap_DOM_Entity_getNotationName},
{"XML::Xercesc::delete_DOM_EntityReference", _wrap_delete_DOM_EntityReference},
{"XML::Xercesc::delete_DOM_NamedNodeMap", _wrap_delete_DOM_NamedNodeMap},
{"XML::Xercesc::DOM_NamedNodeMap_setNamedItem", _wrap_DOM_NamedNodeMap_setNamedItem},
{"XML::Xercesc::DOM_NamedNodeMap_item", _wrap_DOM_NamedNodeMap_item},
{"XML::Xercesc::DOM_NamedNodeMap_getNamedItem", _wrap_DOM_NamedNodeMap_getNamedItem},
{"XML::Xercesc::DOM_NamedNodeMap_getLength", _wrap_DOM_NamedNodeMap_getLength},
{"XML::Xercesc::DOM_NamedNodeMap_removeNamedItem", _wrap_DOM_NamedNodeMap_removeNamedItem},
{"XML::Xercesc::DOM_NamedNodeMap_getNamedItemNS", _wrap_DOM_NamedNodeMap_getNamedItemNS},
{"XML::Xercesc::DOM_NamedNodeMap_setNamedItemNS", _wrap_DOM_NamedNodeMap_setNamedItemNS},
{"XML::Xercesc::DOM_NamedNodeMap_removeNamedItemNS", _wrap_DOM_NamedNodeMap_removeNamedItemNS},
{"XML::Xercesc::DOM_NodeFilter_acceptNode", _wrap_DOM_NodeFilter_acceptNode},
{"XML::Xercesc::DOM_NodeIterator_getRoot", _wrap_DOM_NodeIterator_getRoot},
{"XML::Xercesc::DOM_NodeIterator_getWhatToShow", _wrap_DOM_NodeIterator_getWhatToShow},
{"XML::Xercesc::DOM_NodeIterator_getFilter", _wrap_DOM_NodeIterator_getFilter},
{"XML::Xercesc::DOM_NodeIterator_getExpandEntityReferences", _wrap_DOM_NodeIterator_getExpandEntityReferences},
{"XML::Xercesc::DOM_NodeIterator_nextNode", _wrap_DOM_NodeIterator_nextNode},
{"XML::Xercesc::DOM_NodeIterator_previousNode", _wrap_DOM_NodeIterator_previousNode},
{"XML::Xercesc::DOM_NodeIterator_detach", _wrap_DOM_NodeIterator_detach},
{"XML::Xercesc::delete_DOM_NodeList", _wrap_delete_DOM_NodeList},
{"XML::Xercesc::DOM_NodeList_item", _wrap_DOM_NodeList_item},
{"XML::Xercesc::DOM_NodeList_getLength", _wrap_DOM_NodeList_getLength},
{"XML::Xercesc::delete_DOM_Notation", _wrap_delete_DOM_Notation},
{"XML::Xercesc::DOM_Notation_getPublicId", _wrap_DOM_Notation_getPublicId},
{"XML::Xercesc::DOM_Notation_getSystemId", _wrap_DOM_Notation_getSystemId},
{"XML::Xercesc::delete_DOM_ProcessingInstruction", _wrap_delete_DOM_ProcessingInstruction},
{"XML::Xercesc::DOM_ProcessingInstruction_getTarget", _wrap_DOM_ProcessingInstruction_getTarget},
{"XML::Xercesc::DOM_ProcessingInstruction_getData", _wrap_DOM_ProcessingInstruction_getData},
{"XML::Xercesc::DOM_ProcessingInstruction_setData", _wrap_DOM_ProcessingInstruction_setData},
{"XML::Xercesc::delete_DOM_Range", _wrap_delete_DOM_Range},
{"XML::Xercesc::DOM_Range_getStartContainer", _wrap_DOM_Range_getStartContainer},
{"XML::Xercesc::DOM_Range_getStartOffset", _wrap_DOM_Range_getStartOffset},
{"XML::Xercesc::DOM_Range_getEndContainer", _wrap_DOM_Range_getEndContainer},
{"XML::Xercesc::DOM_Range_getEndOffset", _wrap_DOM_Range_getEndOffset},
{"XML::Xercesc::DOM_Range_getCollapsed", _wrap_DOM_Range_getCollapsed},
{"XML::Xercesc::DOM_Range_getCommonAncestorContainer", _wrap_DOM_Range_getCommonAncestorContainer},
{"XML::Xercesc::DOM_Range_setStart", _wrap_DOM_Range_setStart},
{"XML::Xercesc::DOM_Range_setEnd", _wrap_DOM_Range_setEnd},
{"XML::Xercesc::DOM_Range_setStartBefore", _wrap_DOM_Range_setStartBefore},
{"XML::Xercesc::DOM_Range_setStartAfter", _wrap_DOM_Range_setStartAfter},
{"XML::Xercesc::DOM_Range_setEndBefore", _wrap_DOM_Range_setEndBefore},
{"XML::Xercesc::DOM_Range_setEndAfter", _wrap_DOM_Range_setEndAfter},
{"XML::Xercesc::DOM_Range_collapse", _wrap_DOM_Range_collapse},
{"XML::Xercesc::DOM_Range_selectNode", _wrap_DOM_Range_selectNode},
{"XML::Xercesc::DOM_Range_selectNodeContents", _wrap_DOM_Range_selectNodeContents},
{"XML::Xercesc::DOM_Range_compareBoundaryPoints", _wrap_DOM_Range_compareBoundaryPoints},
{"XML::Xercesc::DOM_Range_deleteContents", _wrap_DOM_Range_deleteContents},
{"XML::Xercesc::DOM_Range_extractContents", _wrap_DOM_Range_extractContents},
{"XML::Xercesc::DOM_Range_cloneContents", _wrap_DOM_Range_cloneContents},
{"XML::Xercesc::DOM_Range_insertNode", _wrap_DOM_Range_insertNode},
{"XML::Xercesc::DOM_Range_surroundContents", _wrap_DOM_Range_surroundContents},
{"XML::Xercesc::DOM_Range_cloneRange", _wrap_DOM_Range_cloneRange},
{"XML::Xercesc::DOM_Range_toString", _wrap_DOM_Range_toString},
{"XML::Xercesc::DOM_Range_detach", _wrap_DOM_Range_detach},
{"XML::Xercesc::new_DOM_RangeException", _wrap_new_DOM_RangeException},
{"XML::Xercesc::delete_DOM_RangeException", _wrap_delete_DOM_RangeException},
{"XML::Xercesc::DOM_RangeException_code_set", _wrap_DOM_RangeException_code_set},
{"XML::Xercesc::DOM_RangeException_code_get", _wrap_DOM_RangeException_code_get},
{"XML::Xercesc::DOM_TreeWalker_getRoot", _wrap_DOM_TreeWalker_getRoot},
{"XML::Xercesc::DOM_TreeWalker_getWhatToShow", _wrap_DOM_TreeWalker_getWhatToShow},
{"XML::Xercesc::DOM_TreeWalker_getFilter", _wrap_DOM_TreeWalker_getFilter},
{"XML::Xercesc::DOM_TreeWalker_getExpandEntityReferences", _wrap_DOM_TreeWalker_getExpandEntityReferences},
{"XML::Xercesc::DOM_TreeWalker_getCurrentNode", _wrap_DOM_TreeWalker_getCurrentNode},
{"XML::Xercesc::DOM_TreeWalker_parentNode", _wrap_DOM_TreeWalker_parentNode},
{"XML::Xercesc::DOM_TreeWalker_firstChild", _wrap_DOM_TreeWalker_firstChild},
{"XML::Xercesc::DOM_TreeWalker_lastChild", _wrap_DOM_TreeWalker_lastChild},
{"XML::Xercesc::DOM_TreeWalker_previousSibling", _wrap_DOM_TreeWalker_previousSibling},
{"XML::Xercesc::DOM_TreeWalker_nextSibling", _wrap_DOM_TreeWalker_nextSibling},
{"XML::Xercesc::DOM_TreeWalker_previousNode", _wrap_DOM_TreeWalker_previousNode},
{"XML::Xercesc::DOM_TreeWalker_nextNode", _wrap_DOM_TreeWalker_nextNode},
{"XML::Xercesc::DOM_TreeWalker_setCurrentNode", _wrap_DOM_TreeWalker_setCurrentNode},
{0,0}
};

#ifdef __cplusplus
extern "C"
#endif

XS(SWIG_init) {
    dXSARGS;
    int i;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    
    /* Install commands */
    // we create the global transcoder for UTF-8 to UTF-16
    XMLTransService::Codes failReason;
    XMLPlatformUtils::Initialize(); // first we must create the transservice
    UTF8_ENCODING = XMLString::transcode("UTF-8");
    UTF8_TRANSCODER =
      XMLPlatformUtils::fgTransService->makeNewTranscoderFor(UTF8_ENCODING,
                                                             failReason,
                                                             1024);
    if (! UTF8_TRANSCODER) {
	croak("ERROR: XML::Xerces: INIT: Could not create UTF-8 transcoder");
    }

    ISO_8859_1_ENCODING = XMLString::transcode("ISO-8859-1");
    ISO_8859_1_TRANSCODER =
      XMLPlatformUtils::fgTransService->makeNewTranscoderFor(ISO_8859_1_ENCODING,
                                                             failReason,
                                                             1024);
    if (! ISO_8859_1_TRANSCODER) {
	croak("ERROR: XML::Xerces: INIT: Could not create ISO-8859-1 transcoder");
    }

    for (i = 0; swig_commands[i].name; i++) {
        newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
    }
    
    /* Install variables */
    for (i = 0; swig_variables[i].name; i++) {
        SV *sv;
        sv = perl_get_sv((char*) swig_variables[i].name, TRUE | 0x2);
        if (swig_variables[i].type) {
            SWIG_MakePtr(sv,(void *)1, *swig_variables[i].type);
        }else {
            sv_setiv(sv,(IV) 0);
        }
        swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get); 
    }
    
    /* Install constant */
    for (i = 0; swig_constants[i].type; i++) {
        SV *sv;
        sv = perl_get_sv((char*)swig_constants[i].name, TRUE | 0x2);
        switch(swig_constants[i].type) {
            case SWIG_INT:
            sv_setiv(sv, (IV) swig_constants[i].lvalue);
            break;
            case SWIG_FLOAT:
            sv_setnv(sv, (double) swig_constants[i].dvalue);
            break;
            case SWIG_STRING:
            sv_setpv(sv, (char *) swig_constants[i].pvalue);
            break;
            case SWIG_POINTER:
            SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype));
            break;
            case SWIG_BINARY:
            /*      obj = SWIG_NewPackedObj(swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype)); */
            break;
            default:
            break;
        }
        SvREADONLY_on(sv);
    }
    
    
    SWIGTYPE_p_IDOM_Node->dcast = (swig_dycast_func) IDOM_Node_dynamic_cast;
    
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}

